---
layout: post
title: Disabilitare un indice in PostgreSQL
date: '2013-11-17T17:59:00.000+01:00'
author: Luca Ferrari
tags:
- postgresql
modified_time: '2013-11-17T17:59:00.938+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-8325887195923286199
blogger_orig_url: http://fluca1978.blogspot.com/2013/11/disabilitare-un-indice-in-postgresql.html
---

<div style="text-align: justify;">Ho gia' scritto in precedenti post come PostgreSQL sia un database fortemente orientato al catalogo: ogni azione che il database esegue e' fortemente dipendente dal catalogo di sistema.</div><div style="text-align: justify;">Anche gli indici usabili lo sono, ed essere a conoscenza di come disabilitare temporaneamente un indice puo' risultare molto importante. PostgreSQL infatti non mette a disposizione, per scelta, i "query hints", ovvero non e' possibile specificare con quale indice PostgreSQL deve forzatamente eseguire una query. Come conseguenza, a volte puo' risultare molto complicato valutare l'efficacia di un indice, e spesso il modo che si usa e' quello di disabilitare, a livello di intero cluster, alcuni metodi di accesso. Ma ecco che tramite il catalogo di sistema e' possibile inibire un singolo indice al fine di escluderlo dalle scelte possibili dell'ottimizzatore, e quindi di valutare gli indici rimanenti.</div><br /><div style="text-align: justify;">Per prima cosa si crei un semplice use case fatto da una sola tabella piena di tuple casuali:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">CREATE TABLE people( name text,</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">surname text,</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">pk serial not null,</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">primary key(pk) );</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">INSERT INTO people( pk, name, surname )</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT generate_series(1, 100000),</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">md5( random()::text ),</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">md5( random()::text );</span><br /><br />Si passi poi alla creazione di due indici sui campi della tabella:<br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">CREATE INDEX name_idx ON people(name);</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">CREATE INDEX surname_idx ON people(surname);</span><br /><br /><div style="text-align: justify;">E' ora possibile verificare che uno dei due indici viene usato in query sufficientemente filtranti:</div><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">EXPLAIN SELECT surname, name FROM people WHERE surname like 'f%';</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">QUERY PLAN                                  </span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">-----------------------------------------------------------------------------</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Bitmap Heap Scan on people  (cost=21.54..967.48 rows=500 width=64)</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Filter: (surname ~~ 'f%'::text)</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">-&gt;  Bitmap Index Scan on surname_idx  (cost=0.00..21.42 rows=500 width=0)</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Index Cond: ((surname &gt;= 'f'::text) AND (surname &lt; 'g'::text))&nbsp;</span></span><br /><br /><br />&nbsp;Il catalogo di sistema pg_index fornisce informazioni circa la disponibilita' degli indici su ogni tabella, e quindi e' possibile ottenere lo stato "attuale" degli indici per una tabella specifica con una query simile alla seguente:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT cc.relname, indexrelid, indnatts, indisclustered, indisvalid, indisready FROM pg_index JOIN pg_class c ON c.oid = indrelid JOIN pg_class cc ON indexrelid = cc.oid WHERE c.relname = 'people' AND c.relkind = 'r' AND cc.relkind = 'i';&nbsp;</span></span><br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">relname   | indexrelid | indnatts | indisclustered | indisvalid | indisready  -------------+------------+----------+----------------+------------+------------  people_pkey |      16541 |        1 | f              | t          | t&nbsp;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">name_idx    |      16558 |        1 | f              | t          | t&nbsp;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">surname_idx |      16559 |        1 | f              | t          | t&nbsp;</span></span><br /><br /><div style="text-align: justify;">La colonna <i>indnatts</i> indica quanti attributi della tabella fanno parte dell'indice; la colonna <i>indisclustered</i> indica la cluster-ness dell'indice, o meglio se la tabella e' ordinata in base a questo indice. La colonna <i>indisvalid</i> e' quella forse piu' importante: indica se l'indice e' usabile dall'ottimizzatore, o meglio se usabile in modo "sicuro". In altre parole, un valore false in questa colonna indica che l'indice al momento non deve essere preso in considerazione perche', ad esempio, una operazione di INSERT/UPDATE sulla tabella e' ancora in corso e a seguito di questa l'indice deve essere riorganizzato. L'ultima colonna mostrata, <i>indisready</i>, indica se l'indice e' pronto a subire modifiche, ossia puo' essere aggiornato a seguito di modifiche nella tabella che referenzia. Da quanto descritto sopra si puo' concludere che indisvalid contribuisce a dare "visibilita'" e "validita'" all'indice, e quindi valori false nelle colonne indicano a PostgreSQL di ignorare l'indice.  E' facile verificare quanto appena detto disabilitando un indice nel catalogo di sistema (ammesso che sia super utente):&nbsp;</div><br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">UPDATE pg_index SET indisvalid = false WHERE indexrelid = 16559;  e il piano di esecuzione ora cambia:   EXPLAIN SELECT surname, name FROM people WHERE surname like 'f%';                          QUERY PLAN                          ------------------------------------------------------------&nbsp;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Seq Scan on people  (cost=0.00..2485.00 rows=500 width=64)&nbsp;</span></span><br /><br /><br /><div style="text-align: justify;">Con questa semplice modifica al catalogo e' quindi possibile verificare altri indici, scartati a priori dall'ottimizzatore, senza intaccare il funzionamento dell'intero cluster. Si noti che l'ottimizzatore di PostgreSQL e' molto bravo nel fare il suo lavoro, e quindi se ha deciso di scartare altri metodi di accesso e' quasi certo che questi ultimi siano poco efficienti.   E' possibile verificare il comportamento degli indici anche a seguito di una operazione di UPDATE:&nbsp;</div><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">EXPLAIN UPDATE people SET surname = 'TEST' WHERE surname like 'f%';                             QUERY PLAN                             ------------------------------------------------------------------  Update on people  (cost=0.00..2485.00 rows=500 width=42)    -&gt;  Seq Scan on people  (cost=0.00..2485.00 rows=500 width=42)</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Filter: (surname ~~ 'f%'::text)</span></span><br /><br />e riabilitando l'indice si ottiene che questo viene nuovamente usato:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">UPDATE pg_index SET indisvalid = true WHERE indexrelid = 16559;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">EXPLAIN UPDATE people SET surname = 'TEST' WHERE surname like 'f%';</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">QUERY PLAN                                     </span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">-----------------------------------------------------------------------------------</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Update on people  (cost=21.54..967.48 rows=500 width=42)</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">-&gt;  Bitmap Heap Scan on people  (cost=21.54..967.48 rows=500 width=42)</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Filter: (surname ~~ 'f%'::text)</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">-&gt;  Bitmap Index Scan on surname_idx  (cost=0.00..21.42 rows=500 width=0)</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Index Cond: ((surname &gt;= 'f'::text) AND (surname &lt; 'g'::text))</span></span>