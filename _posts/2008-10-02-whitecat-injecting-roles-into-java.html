---
layout: post
title: 'WhiteCat: injecting roles into Java agents/proxies'
date: '2008-10-02T12:49:00.001+02:00'
author: Luca Ferrari
tags:
- aglets
- research
- WhiteCat
- java
modified_time: '2009-03-23T12:53:46.705+01:00'
thumbnail: http://2.bp.blogspot.com/_yhEX77VFKnM/SOSpNZIW-sI/AAAAAAAAAKM/4nw4_ORurNY/s72-c/sito1.png
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-1021639119812967286
blogger_orig_url: http://fluca1978.blogspot.com/2008/10/whitecat-injecting-roles-into-java.html
---

In the past few months I developed the prototype of a role system for Java agents that I called WhiteCat, in contrast to <a href="http://www.agentgroup.ing.unimo.it/MOON/papers/pdf/SCP05a.pdf">RoleX</a> (also known as BlackCat).<br />The prototype is developed in 100% Java and is based, as its precedessor, on the Javassist bytecode manipulation library. The idea is the same as in RoleX: Java agents should be enhanced thru roles (i.e., Java third party libraries) dynamically at run-time, and must be merged with the role they assume, becoming a single entity with their roles. The aim is thus to support role external visibility, that is the capability to recognize a role played by an agent simply looking at it. Since in Java "looking" at an object and retrieving its class information, the WhiteCat approach must manipulate the agent class structure in order to make the role visible as a part of the agent itself.<br />For a more detailed explaination of the inspiration behind this role approach please see <a href="http://researchweb.watson.ibm.com/journal/sj/441/cabriref.html">this article on the IBM Systems Journal</a>.<br /><br />There are a few drawbacks in the RoleX design that lead me to the design of the WhiteCat approach:<br /><ul><li>RoleX merges the role in the agent changing the whole agent class structure. This means that not only the bottom of the agent class inheritance chain is modified, but that each level of the agent inheritance is changed depending on the role class structure. This is a time consuming activity.</li><li>RoleX requires a different class loader for each role assumption/release. This means that if the same agent assumes different roles at different times, each assumption requires a different class loader (called role loader). This is resource consuming.</li><li>RoleX requires developers to deal with reflection and invocation translators to make injected features (i.e., role features) available. This is complex to understand and to develop/mantain.</li><li>RoleX provides only one kind of role, that is a publicly visible role. Each assumed role is automatically visible to external entities, and this could lead to security and privacy problems.</li><li>RoleX injects the role into the agent class, without taking into account that the agent could be hidden behind a proxy (see for example <a href="http://sourceforge.net/projects/aglets/">Aglets</a>), and thus the role external visibility is not exploitable.</li><li>RoleX requires the role to be not instantiated and used by anything that is not the role loader. In other words you are not free to create a role object, since the role engine will workonly with the role classes, and thus having a role object will not provide you any meaningful capability.</li><li>RoleX creates different class definitions at run-time, so you could have two classes with the same name and different implementation. It can thus be difficult to deal with objects, since you could not knowor recognize which one is the original (i.e., never manipulated) one. Moreover, this way of working requires that developers discard the old (i.e., not manipulated) agent reference and use the new one provided by the role engine. Of course, there is no way to enforce this practice, so a malicious developer could keep a reference to both.</li></ul><br />Starting from the above drawbacks I decide to design a new approach with the same base concepts, but faster, simpler and with more role visibility options. The result is the WhiteCat prototype that provides three level of role visibility:<br /><br /><ul><li>invisible: the role is not visible at all from an external point of view. This means that an agent has assumed and uses a role without letting any other agent to be able to autonomously knowing it;</li><li>visible: the role is visible to any external entity;</li><li>public: the role is visible and can even be used from external entities.</li></ul><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_yhEX77VFKnM/SOSpNZIW-sI/AAAAAAAAAKM/4nw4_ORurNY/s1600-h/sito1.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://2.bp.blogspot.com/_yhEX77VFKnM/SOSpNZIW-sI/AAAAAAAAAKM/4nw4_ORurNY/s320/sito1.png" alt="" id="BLOGGER_PHOTO_ID_5252509112970181314" border="0" /></a><br /><br />Role visibility is defined thru interfaces and annotations, so that the role loader can recognize how and where to apply changes to the agent (or its proxy).<br /><br />Moreover WhiteCat allows the manipulation of either the agent class structure or its proxy one. In the case the agent is hidden behind a proxy, and the role is visible or public, the proxy class structure is changed in order to make the role perceivable; in the case the role is directly accessible (i.e., there's no proxy) its class structure is directly changed in order to apply changes.<br /><br /><br /><br />As an example consider the following application snippet:<br /><br /><pre> // role class<br />Class roleClass = root.loadClass("whitecat.example.DatabaseAdministrator");<br />DatabaseAdministrator dbaRole = (DatabaseAdministrator) roleClass.newInstance();<br />AgentProxy proxy = .... // get the proxy in the way your platform  allows you<br /><br />// get a new role loader engine<br />RoleEngine engine = new RoleEngine();<br />// add the dbarole to the current agent<br />AgentProxy newproxy = engine.injectPublicRole(proxy, dbaRole);<br /><br />if( newproxy instanceof IDatabaseAdministrator ) {<br />// the proxy can work as a IDatabaseAdministrator object from here!<br />}<br /><br /></pre><br /><br /><br />As you can see the agent proxy is simply injected with the role. Please note that a role instance is used, not a role class. This means that the role can be instantiated and initialized as you like, and can injected to the agent or its proxy when you want, and of course the role will keep its state.<br />Just after the injectPublicRole() call, the agent proxy is perceivable (thru instanceof) as implementing the public role interface, that in the above example is the IDatabaseAdministrator one. In order to achieve this, the agent proxy class structure is extended by the role one, meaning that it is like the agent proxy has new subclasses with the role properties. Since the agent proxy class structure is extended (i.e., all the classes up to the agent proxy are not touched), there's no need to discard the "old" object reference. If the developer does not use the new proxy reference (i.e., newproxy in the code above), it will simply not be able to exploit role capabilities, but he will be able to exploit all<br />original proxy capabilities.<br />The RoleEngine is a special class loader that performs bytecode manipulation in order to extend the agent proxy class chain. The RoleEngine exploits the Javassist library in order to manipulate the class structure, and appends<br />to each new class a unique number, so that the same class can be manipulated different times by the same RoleLoader as the result will have a different name and so will not clashes with other already manipulated classes. Moreover the role adoption model is simpler than in RoleX, since the developers will handle roles in straight way: once the injectPublicRole() is called, the developer could<br />test the agent proxy against the injected role and cast the agent proxy to such role. Last but not least, since WhiteCat does not manipulate a whole inheritance chain, rather it appends a chain to another, the approach is much faster than the RoleX one.<br /><br />Of course, as shown in the figure, the manipulation process can be repeated as many times as needed (i.e., one for every role assumption).<br /><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_yhEX77VFKnM/SOSpdCyP5vI/AAAAAAAAAKU/x8eY_NaALpI/s1600-h/sito2.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://2.bp.blogspot.com/_yhEX77VFKnM/SOSpdCyP5vI/AAAAAAAAAKU/x8eY_NaALpI/s400/sito2.png" alt="" id="BLOGGER_PHOTO_ID_5252509381849769714" border="0" /></a><br /><br />In my opinion WhiteCat represents a very enhanced role approach than RoleX, and even if still a prototype, it is enough stable to be used in role based applications.<br />I'm still working on WhiteCat, and I will release it under the GNU GPLv3 license. If you are interested in WhiteCat and want to know more details or discuss with me, please e-mail me (fluca1978 at gmail.com) and I will be happy to provide more information.<br />I'd like to thanks Mr. <a href="http://www.csg.is.titech.ac.jp/%7Echiba/javassist/index.html">Shigeru Chiba</a> and the <a href="http://www.jboss.org/">JBoss</a> team and community for their work and support on <a href="http://www.jboss.org/javassist/">Javassist</a>.