---
layout: post
title: Diamonds in Perl
date: '2017-05-10T21:06:00.000+02:00'
author: Luca Ferrari
tags:
- perl
- planet-perl-ironman
modified_time: '2017-05-11T09:01:31.035+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-2718196149325767025
blogger_orig_url: http://fluca1978.blogspot.com/2017/05/a-diamond-ascii-is-geometric-structure.html
---

A <i>diamond ascii</i> is a geometric structure represented as, ehm, a diamond. For example, in the case of letters it becomes something like:<br /><br /><br /><pre class="example">      a<br />    b  b<br />   c    c<br />  d      d<br /> e        e<br />f          f<br /> e        e<br />  d      d<br />   c    c<br />    b  b<br />     a<br /></pre><br />How hard can it be to build a Perl program to represent a diamond like the above one?<br />Well, not so much hard, but we have to observe some geometric properties:<br /><br /><ul class="org-ul"><li>the diamond is simmetric (in the sense it becomes and ends with the same letters), but the<br />central row is reproduced only once (that is, the <code>f</code> appears only on one line, not two!);<br /></li><li>each letter or couple of letters is vertically centered around the number of letters in the whole diamond, that is<br />the letter <code>a</code> (vertical centre) is shifted to right of 6 chars (the total number of letters is a..f = 6);<br /></li><li>each couple of letters has a <i>left</i> and <i>right</i> position, and both are equally distant from the vertical<br />centre of the diamond.<br /></li></ul><br />Ok, so here it comes my shorter solution:<br /><br /><br /><div class="org-src-container"><br /><pre class="src src-perl">#!env perl<br /><br />use v5.20;<br /><br />my @letters = qw( a b c d e f );<br /><br />my %index;<br />@index{ @letters } = ( 0 .. $#letters );<br /><br /><br />    say {*STDOUT}<br />  " " x ( $#letters - $index{ $_ } )<br /> , $_<br /> , " " x ( $index{ $_ } * 2 )<br /> ,( $index{ $_ } &gt; 0 ? $_ : '' )<br />     for  ( ( @letters, reverse @letters[ 0 .. $#letters - 1 ] ) );<br /></pre></div><br />Allow me to explain it in all its pieces.<br /><br /><br />First of all, <code>@letters</code> contains the letters to be printed in the right order, and this of course could come from user's input, a sequence, an array slice, or whatever, it does not mind here. Since I have to place letters depending on <i>where</i> they are in the array of <code>@letters</code>, I need to have an handy way to get the index within the array for each letter, so I build up an hash where the keys are the letters themselves and the values are the positions of such letters. In other words, <code>$index{a} = 0</code>, <code>$index{f] = 5 </code>and so on.<br /><br /><br />Finally, I print a line every time I need with <code>say</code>. Let's dissect the <code>say</code> statement:<br /><br /><ul class="org-ul"><li><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">" " x ( $#letters - $index{ $_ } )</span> shifts to right a number of spaces required to reach the vertical centre or the right distance from it, in other words it is the <i>left</i> position. For example, for the letter <code>a</code> it comes<br />down to <code>5 - 0 = 5</code>, while for <code>b</code> it comes to <code>5 - 1 = 4</code> and so on.<br /></li><li>then I print <code>$_</code> that is the current char;<br /></li><li>then I move again to the right of <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">" " x ( $index{ $_ } * 2 )</span>, that is in the case of <code>a</code> <i>nothing</i>, in the case of <code>b</code> by 2, and so on;<br /></li><li>then if required I print again the char. Here "required" means the char is not the first one (i.e., not the one at index 0), since that is the only one character printed <i>exactly one time per line</i>.<br /></li></ul><br />The <code>say</code> is repeated over the whole <code>@letters</code> array, so this produces the first part of the diamond:<br /><br /><br /><pre class="example"><a href="https://www.blogger.com/blogger.g?blogID=1836481905487384887" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"></a>      a<br />    b  b<br />   c    c<br />  d      d<br /> e        e<br />f          f<br /></pre><br />then I need to get the bottom, so I need to iterate over the <code>reverse @letters</code> with the exception of the last element, that is I need to iterate over a reversed slice of <code>@letters</code> with the missing <code>f</code>: <code>reverse @letters[ 0 .. $#letters - 1 ] )</code>. This provides me the whole bottom of the diamond.