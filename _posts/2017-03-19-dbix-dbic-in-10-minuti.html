---
layout: post
title: DBIx (DBIC) in 10 minuti
date: '2017-03-19T17:37:00.000+01:00'
author: Luca Ferrari
tags:
- perl
- programmazione
modified_time: '2017-03-19T17:37:06.474+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-2472218699009823996
blogger_orig_url: http://fluca1978.blogspot.com/2017/03/dbix-dbic-in-10-minuti.html
---

 Per chi proviene dal mondo "classico" della programmazione ORM (Object  Relational Mapping), il componente DBIX può risultare un po' ostico. Il problema principale, a mio avviso, è nella terminologia e nella  modalità di utilizzo. Se un ORM classico infatti richiede solitamente un livello intermedio di  persistenza (tipicamente tramite una sessione, dao, ecc), DBIX tende a fornire oggetti (proxy-zzati) molto piu' autonomi. <br />   In questo brevissimo articolo voglio mostrare come può essere usato DBIX agilmente nelle operazioni piu' comuni. <br />  <div class="outline-2" id="outline-container-sec-1"><h2 id="sec-1"><span class="section-number-2">1</span> Creazione del database</h2><div class="outline-text-2" id="text-1"> Si supponga di creare uno schema SQLite3 molto semplice: <br /> <div class="org-src-container"> <pre class="src src-sh">sqlite3 database.db<br />sqlite&gt; CREATE TABLE events( pk integer primary key autoincrement,<br />ts timestamp default current_timestamp,<br />description varchar(200) );<br /></pre></div></div></div><div class="outline-2" id="outline-container-sec-2"><h2 id="sec-2"><span class="section-number-2">2</span> Eseguire il dump dello schema</h2><div class="outline-text-2" id="text-2"> Il programma <code>dbicdump</code> permette il dump di uno schema database, ovvero la creazione degli oggetti <i>result</i> che rappresentano ciascuno una tabella singola del database/schema. <br />  <div class="org-src-container"> <pre class="src src-sh"> dbicdump -o dump_directory=./lib -o components='["InflateColumn::DateTime"]' \<br />  Test::Schema<br />  dbi:SQLite:database.db<br />Dumping manual schema for Test::Schema to directory ./lib ...<br />Schema dump completed.<br /></pre></div>Dopo aver eseguito questo comando si avrà una directory <code>lib</code> che contiene un file <code>Schema.pm</code> (che dichiara il namespace) e il relativo albero di directory <code>Schema/Result</code> con un file <code>pm</code> per ogni DBIX result, ovvero un file per tabella. In particolare, per la singola tabella <code>event</code> rappresentata dalla classe nel file <code>Event.pm</code> si ha che: <br />  <div class="org-src-container"> <pre class="src src-perl">__PACKAGE__-&gt;add_columns(<br />  "pk",<br />  { data_type =&gt; "integer", is_auto_increment =&gt; 1, is_nullable =&gt; 0 },<br />  "ts",<br />  {<br />    data_type     =&gt; "timestamp",<br />    default_value =&gt; \"current_timestamp",<br />    is_nullable   =&gt; 1,<br />  },<br />  "description",<br />  { data_type =&gt; "varchar", is_nullable =&gt; 1, size =&gt; 200 },<br />);<br /></pre></div>Si nota come il sistema di gestione dei <i>result</i> sia di tipo dichiarativo: ogni classe (Perl) indica in modo dichiarativo i propri membri, e ciascun membro corrisponde sostanzialmente ad una colonna del database. <br />   L'utilizzo di DBIX risulta veramente veloce e semplice (dal punto di vista della quantità del codice). La classe <i>schema</i> eredita da <i>DBIX::Schema</i> e quindi dispone del metodo <code>connect</code> che consente la connessione al database. Ogni azione che si vuole fare su un database (istanza) deve avvenire attraverso lo <i>schema</i>. Lo <i>schema</i> raccoglie una serie di tuple raggruppate in un <i>result set</i> (inteso qui differentemente rispetto a JDBC, DBI, ecc). Ogni operazione che si vuole svolgere su una tupla deve passare attraverso un result set. In sostanza si potrebbe affermare che l'analogia fra DBI e DBIX è la seguente: <br />  <table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">  <colgroup><col class="left"></col> <col class="left"></col> <col class="left"></col></colgroup><thead><tr><th class="left" scope="col">DBI - JDBC - similari</th><th class="left" scope="col">DBIX</th><th class="left" scope="col">Significato</th></tr></thead><tbody><tr><td class="left">database handler</td><td class="left">schema</td><td class="left">Connessione al database (istanza)</td></tr><tr><td class="left">result set</td><td class="left">array di oggetti</td><td class="left">Risultati da una query</td></tr><tr><td class="left">statement su tabella</td><td class="left">result set</td><td class="left">Interazione lettura/scrittura con una tabella</td></tr></tbody></table></div></div><div class="outline-2" id="outline-container-sec-3"><h2 id="sec-3"><span class="section-number-2">3</span> Un primo esempio</h2><div class="outline-text-2" id="text-3"> Ecco quindi un programma di esempio: <br />  <div class="org-src-container"> <pre class="src src-perl">use Test::Schema;<br /><br />my $schema_connection = Test::Schema-&gt;connect( 'dbi:SQLite:/home/luca/tmp/dbix/database.db' );<br /><br /><br />for ( 1..100 ){<br />    my $event = $schema_connection<br /> -&gt;resultset( 'Event' )<br /> -&gt;create( { description =&gt; "Evento $_" } );<br /><br />    # update !<br />    $event-&gt;update();<br />}<br /><br /># ricerca di eventi<br />my $result_set = $schema_connection-&gt;resultset( 'Event' )-&gt;search( { pk =&gt;{ '&gt;' =&gt; 50, '&lt;' =&gt; 87 }  } );<br /><br />while ( ( my $event = $result_set-&gt;next() ) ){<br />    say "Evento " . $event-&gt;pk . " = " . $event-&gt;description;<br />}<br />#+end-perl<br /><br />La prima parte carica lo schema e gli oggetti creati appositamente da ~dbicdump~.<br />Successivamente si crea lo schema, ovvero ci si collega al database (istanza).<br />Poi si effettua un semplice ciclo per inserire 100 righe nella tabella /events/, corrispondente all'oggetto Perl ~Event~.<br />Si noti che tali oggetti sono creati con il metodo ~create~ sul result set, che a sua volta è agganciato alla tabella /events/.<br />In altre parole la riga<br /><br />#+negin_src perl<br />my $event = $schema_connection<br /> -&gt;resultset( 'Event' )<br /> -&gt;create( { description =&gt; "Evento $_" } );<br /></pre></div>esegue: <br /> <ol class="org-ol"><li>una connessione al database (istanza) usando lo <i>Schema</i>; </li><li>decide di lavorare sul result set <i>Event</i>, ovvero sulla tabella corrispondente <code>events</code>; </li><li>chiedendo di creare un oggetto che rappresenta una singola riga nella tabella. </li></ol>Giunti a questo punto DBIX sa tutto quello che gli serve per memorizzare  in modo permanente sul database l'oggetto, e quindi tradurlo in una  riga di SQL. Da notare che l'oggetto creato tramite il metodo <code>create</code> è un oggetto Perl a tutti gli effetti, ovvero è possibile usare i metodi accessor per impostare i valori. <br />   Fino a qui DBIX si è solo "preparato", ma non ha eseguito nulla di  fatto. Nel momento in cui l'oggetto si aggiorna, ovvero si invoca il  metodo <code>update</code>, questo viene inserito/aggiornato nella tabella. <br />   Questo è un punto nodale che rappresenta una differenza fondamentale  nell'approccio DBIX rispetto ad altri ORM (es. Hibernate): invece che  creare degli oggetti slegati dal database e richiedere ad un servizio <i>DAO</i> di rendere persistente tali oggetti, DBIX crea oggetti <i>collegati</i> alla propria tabella e al proprio database, così che tali oggetti "sappiano" dove andare ad  "inserirsi" o "aggiornarsi". Nessuna cosa, entità o servizio di  persistenza esterno viene invocato. <br />   Successivamente è possibile rileggere i dati inseriti, ancora una volta passando per il result set: <br /> <ol class="org-ol"><li>si usa la connessione al database (istanza), ovvero lo <i>Schema</i>; </li><li>si dichiara di voler lavorare sullo schema <i>Event</i>, ovvero la tabella fisica <code>events</code>; </li><li>si effettua una ricerca specificando, per ogni colonna che si vuole cercare, i valori da mettere in and-logico. Nell'esempio di cui sopra si ha che si prendono tutte le tuple con <code>pk</code> compreso fra 51 e 86 inclusi. L'oggetto ritornato è un <i>Result Set</i>, da intendersi come collezione di oggetti del tipo <code>Event</code>. </li></ol>Si può allora iterare sul result set per ottenere tutti gli oggetti di tipo <code>Event</code> richiesti. Da notare che è possibile specificare delle clausole <code>where</code> letterali, il metodo search può accettare diversi formati di parametri. Inoltre esiste un metodo <code>find</code> per la ricerca secca di un record per chiave primaria. <br /> </div></div><div class="outline-2" id="outline-container-sec-4"><h2 id="sec-4"><span class="section-number-2">4</span> Update massivo</h2><div class="outline-text-2" id="text-4"> Ci sono due strade per effettuare un aggiornamento massivo di record: <br /> <ol class="org-ol"><li>iterare su ogni oggetto collegato ad una tupla ed eseguire un <code>update</code> singolo; </li><li>eseguire un <code>update</code> sul result set trovato da una query di ricerca. </li></ol>Il primo metodo potrebbe riassumersi così: <br />  <div class="org-src-container"> <pre class="src src-perl">my $result_set = $schema_connection-&gt;resultset( 'Event' )-&gt;search( { pk =&gt;{ '&gt;' =&gt; 50, '&lt;' =&gt; 87 }  } );<br /><br />while ( ( my $event = $result_set-&gt;next() ) ){<br />    $event-&gt;description( " AGGIORNATO " . $event-&gt;description() );<br />    $event-&gt;update();<br />}<br /></pre></div>L'idea è semplice: si effettua una ricerca, si prendono uno ad uno gli oggetti <code>Event</code> (ciascuno dei quali corrisponde ad una tupla) e lo si aggiorna tramite <code>update</code>. DBIX è sufficientemente intelligente per capire che deve eseguire una <code>UPDATE</code> verso il database, siccome la riga proveniva da una query. <br />   Il secondo approccio, sicuramente piu' compatto e simile, come concetto, alla query SQL che si vorrebbe eseguire, è il seguente: <br />  <div class="org-src-container"> <pre class="src src-perl">my $result_set = $schema_connection-&gt;resultset( 'Event' )-&gt;search( { pk =&gt;{ '&gt;' =&gt; 50, '&lt;' =&gt; 87 }  } );<br />$result_set-&gt;update( { description =&gt; 'AGGIORNATO' } );<br /></pre></div>La differenza, ovvia, è che non si possono chiamare degli accessor nel caso di <code>update</code> di un intero result set, e quindi questa tecnica è effettivamente utile quando si devono impostare tutti i valori ad un letterale prestabilito. <br /> </div></div><div class="outline-2" id="outline-container-sec-5"><h2 id="sec-5"><span class="section-number-2">5</span> Colonne modificate, annullare le modifiche</h2><div class="outline-text-2" id="text-5"> Un singolo oggetto collegato ad un result set è in grado di sapere quali colonne sono state modificate: <br />  <div class="org-src-container"> <pre class="src src-perl">$event-&gt;description( " AGGIORNATO " . $event-&gt;description() );<br />    my %cols = $event-&gt;get_dirty_columns();<br />    for my $col ( keys %cols ){<br /> say "Evento " . $event-&gt;pk . " con colonna $col modificata " ;<br />    }<br /></pre></div>e quindi è anche possibile evitare di eseguire delle query qualora l'oggetto non sia stato modificato: <br />  <div class="org-src-container"> <pre class="src src-perl">$event-&gt;update() if ( $event-&gt;get_dirty_columns() );<br /></pre></div></div></div><div class="outline-2" id="outline-container-sec-6"><h2 id="sec-6"><span class="section-number-2">6</span> Cancellazione</h2><div class="outline-text-2" id="text-6"> Beh, come ci si puo' aspettare, <code>delete</code> esegue lo scopo: <br />  <div class="org-src-container"> <pre class="src src-perl">$event-&gt;delete;<br /></pre></div></div></div><div class="outline-2" id="outline-container-sec-7"><h2 id="sec-7"><span class="section-number-2">7</span> Insert o Update?</h2><div class="outline-text-2" id="text-7"> Inizialmente ho mentito: non è necessario chiamare <code>update</code> per eseguire una query <code>INSERT</code> o una query <code>UPDATE</code>. Come ci si può aspettare il metodo <code>update</code> esegue…eh.. <code>UPDATE</code>! Esiste infatti un metodo <code>insert</code> da richiamare su un oggetto risultato per eseguire l'inserimento nella tabella corrispondente. Il motivo per il quale nel primo esempio si è usato <code>update</code> è che lo schema ha creato l'oggetto con <code>create</code>, che inserisce di fatto una tupla nella tabella corrispondete. L'<code>update</code> successiva aggiorna tale tupla. E' possibile creare un oggetto senza inserirlo nel database usando il metodo <code>new</code> sul result set, che restituisce un oggetto sul quale occorre poi fare una <code>insert</code> esplicita: <br />  <div class="org-src-container"> <pre class="src src-perl">my $event = $schema_connection<br />    -&gt;resultset( 'Event' )<br />    -&gt;new( { description =&gt; "!!Evento $_" } );<br /><br />$event-&gt;insert;<br /></pre></div></div></div><div class="outline-2" id="outline-container-sec-8"><h2 id="sec-8"><span class="section-number-2">8</span> Aggiungere foreign keys</h2><div class="outline-text-2" id="text-8"> Supponiamo di voler dotare ogni evento di un "tag": <br />  <div class="org-src-container"> <pre class="src src-sql">sqlite&gt; CREATE TABLE tags( pk integer primary key autoincrement, description varchar(20) );<br />sqlite&gt; INSERT INTO tags( description) VALUES( 'Tag1' ), ( 'Tag2' );<br />sqlite&gt; DROP TABLE events;<br />sqlite&gt; CREATE TABLE events( pk integer primary key autoincrement,<br />   ...&gt;    ts timestamp default current_timestamp,<br />   ...&gt;    description varchar(200),<br />   ...&gt;    tag_pk integer,<br />   ...&gt;    FOREIGN KEY(tag_pk) REFERENCES tags(pk) );<br /></pre></div>Se si ricostruisce il modello Perl con <code>dbicdump</code> si ha che viene creata una classe <i>Tag</i> che contiene nella definizione il seguente blocco: <br />  <div class="org-src-container"> <pre class="src src-perl">=head1 RELATIONS<br /><br />=head2 events<br /><br />Type: has_many<br /><br />Related object: L<test::schema::result::event><br /><br />=cut<br /><br />__PACKAGE__-&gt;has_many(<br />  "events",<br />  "Test::Schema::Result::Event",<br />  { "foreign.tag_pk" =&gt; "self.pk" },<br />  { cascade_copy =&gt; 0, cascade_delete =&gt; 0 },<br />);<br /></test::schema::result::event></pre></div>che istruisce DBIX sul fatto che <i>Event</i> e <i>Tag</i> sono in relazione attraverso le chiavi esterne. Analogamente <i>Event</i> viene modificato rispetto a prima: <br />  <div class="org-src-container"> <pre class="src src-perl">__PACKAGE__-&gt;belongs_to(<br />  "tag_pk",<br />  "Test::Schema::Result::Tag",<br />  { pk =&gt; "tag_pk" },<br />  {<br />    is_deferrable =&gt; 0,<br />    join_type     =&gt; "LEFT",<br />    on_delete     =&gt; "NO ACTION",<br />    on_update     =&gt; "NO ACTION",<br />  },<br />);<br /></pre></div>Vediamo ora come è possibile inserire delle tuple che agiscano su entrambe le tabelle: <br />  <div class="org-src-container"> <pre class="src src-perl">use Test::Schema;<br /><br />my $schema_connection = Test::Schema-&gt;connect( 'dbi:SQLite:/home/luca/tmp/dbix/database.db' );<br /><br /><br />for ( 1..100 ){<br />    my $tag = $schema_connection<br /> -&gt;resultset( 'Tag' )<br /> -&gt;find( ( $_ % 2 ) + 1 );<br /><br />    my $event = $schema_connection<br /> -&gt;resultset( 'Event' )<br /> -&gt;new( { description =&gt; "Evento $_" } );<br /><br />    $event-&gt;tag_pk( $tag );<br />    $event-&gt;insert;<br />}<br /></pre></div>Come si può notare si seleziona in modo "random" un tag dal resultset <i>Tag</i>, e poi lo si imposta nell'oggetto <i>Event</i>che viene poi inserito tramite <code>insert</code>. Da notare una bruttura: DBIX chiama il metodo accessor della relazione come la colonna stessa della tabella, in questo caso <code>tag_pk</code>. Ovviamente non è DBIX, quanto <code>dbicdump</code>, quindi questa cosa va tenuta presente e/o modificata a mano per rendere piu' leggibile il codice Perl (dopotutto <code>tag_pk()</code> agisce su un oggetto <i>Tag</i> e non su un oggetto integer). Se ad esempio si modifica <code>Event.pm</code> come segue: <br />  <div class="org-src-container"> <pre class="src src-perl">__PACKAGE__-&gt;belongs_to(<br />  "tag",  # era tag_pk<br />  "Test::Schema::Result::Tag",<br />  { pk =&gt; "tag_pk" },<br />  {<br />    is_deferrable =&gt; 0,<br />    join_type     =&gt; "LEFT",<br />    on_delete     =&gt; "NO ACTION",<br />    on_update     =&gt; "NO ACTION",<br />  },<br />);<br /></pre></div>allora il seguente codice usa il metodo mnemonico <code>tag</code> che ricorda meglio l'oggetto risultato <i>Tag</i>: <br />  <div class="org-src-container"> <pre class="src src-perl">for ( 1..100 ){<br />    my $tag = $schema_connection<br /> -&gt;resultset( 'Tag' )<br /> -&gt;find( ( $_ % 2 ) + 1 );<br /><br />    my $event = $schema_connection<br /> -&gt;resultset( 'Event' )<br /> -&gt;new( { description =&gt; "Evento $_" } );<br /><br /><br />    $event-&gt;tag( $tag ); # era tag_pk<br />    $event-&gt;insert;<br />}<br /></pre></div>A questo punto si può procedere in maniera analoga alla ricerca dei dati, il metodo <code>Event::tag</code> fornirà un oggetto di tipo <i>Tag</i>mentre <code>Tag::events</code> fornirà una lista di oggetti <i>Event</i>. Ad esempio: <br />  <div class="org-src-container"> <pre class="src src-perl">my $result_set = $schema_connection-&gt;resultset( 'Tag' )-&gt;find( 1 );<br /><br />for my $event ( $result_set-&gt;events() ){<br />    say "Evento trovato " . $event-&gt;description;<br />}<br /></pre></div>da notare che sul result set non si deve effettuare nessuna operazione poiché il metodo <code>find</code> restituisce un solo valore <i>Tag</i>. <br /> </div></div><div class="outline-2" id="outline-container-sec-9"><h2 id="sec-9"><span class="section-number-2">9</span> Riassunto</h2><div class="outline-text-2" id="text-9"> DBIX è un meccanismo molto flessibile e potente, che opera a livello  semi-dichiarativo: come si è potuto notare ogni oggetto collegato ad una tupla database è espresso tramite invocazioni di metodi che ne  definiscono struttura e relazioni (es. <code>belongs_to</code>). Il concetto chiave di DBIX è, a mio avviso, il fatto che il <i>result set</i> non rappresenta un set di risultati quanto una tabella fisica (o un join di tabelle), e che di conseguenza ogni singola tupla di tabella/e diventa un oggetto capace di agire autonomamente sulla propria persistenza. Ne consegue che ogni volta che si vuole interagire con una tabella si deve passare per un <i>result set</i>, sia per aggiungere, aggiornare, cancellare o selezionare tuple, che a loro volta diventano oggetti, che includono la logica <i>dao</i> al proprio interno. <br /> </div></div>