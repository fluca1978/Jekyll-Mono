---
layout: post
title: PostgreSQL e uso dello spazio di storage
date: '2013-11-12T19:47:00.000+01:00'
author: Luca Ferrari
tags:
- postgresql
modified_time: '2013-11-12T19:47:00.293+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-3704197880727945803
blogger_orig_url: http://fluca1978.blogspot.com/2013/11/postgresql-e-uso-dello-spazio-di-storage.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<div style="text-align: justify;">PostgreSQL tenta di minimizzare, o meglio di ritardare il piu' possibile, gli accessi allo storage fisico. In questo port voglio mostrare come anche una operazione apparentemente banale come la cancellazione di una colonna da una tabella non produca immediati effetti su disco.</div><div style="text-align: justify;">&nbsp;</div><div style="text-align: justify;">Per prima cosa occorre creare una tabella di esempio da popolare con un po' di dati di prova per valutare come cambi l'uso dello storage secondo le modifiche alla struttura della tabella stessa:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">CREATE TABLE dropping_test( pk SERIAL NOT NULL, description text, PRIMARY KEY(pk) );</span><br /><br /><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">WITH RECURSIVE counter(pk) AS</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">( SELECT 1 UNION SELECT pk + 1&nbsp;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; FROM counter WHERE pk &lt; 1000000 )</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">INSERT INTO dropping_test(pk, description)</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT c.pk,  'A fake description for entry ' || c.pk</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">FROM counter c;</span><br /><br /><br /><br /><div style="text-align: justify;">La query di cui sopra vuota la tabella e la riempie di un milione di tuple sostanzialmente identiche. La dimensione finale della tabella risulta essere di circa 60 MB:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT pg_size_pretty( pg_relation_size( 'dropping_test' ) );</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">pg_size_pretty </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">----------------</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">65 MB</span><br /><br /><br /><div style="text-align: justify;">A questo punto si puo' procedere alla rimozione della colonna description, che e' quella che occupa la maggior parte dello spazio di storage essendo formata da testo libero. Da notare che dopo la rimozione della colonna il catalogo di sistema mostra l'attributo (colonna) come "deprecato". Cio' significa che l'attributo e' stato eliminato logicamente dalla tabella ma non fisicamente (poiche' ancora presente nel catalogo di sistema).</div><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ALTER TABLE dropping_test DROP COLUMN description;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ALTER TABLE</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Time: 92.774 ms</span><br /><br /><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Da notare la velocita' di eliminazione (logica) della colonna: di fatto non e' successo molto sullo storage, e quindi il sistema non ha perso tempo nel rimuovere la colonna.</div><div style="text-align: justify;">Una colonna rimossa diventa sostanzialmente invisibile al parser, ossia non e' usabile lato SQL. Se si interroga il catalogo di sistema si ottiene l'informazioni circa la rimozione della colonna, che pero' ha perso il proprio nome (il drop di una colonna non e' una operazione recuperabile):</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT attname, attisdropped FROM pg_attribute a JOIN pg_class c ON a.attrelid = c.oid WHERE c.relname = 'dropping_test';</span><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">attname            | attisdropped </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">------------------------------+--------------</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">tableoid                     | f</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">cmax                         | f</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">xmax                         | f</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">cmin                         | f</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">xmin                         | f</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ctid                         | f</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">pk                           | f</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">........pg.dropped.2........ | t</span><br /><br /><br /><div style="text-align: justify;">In realta', se e' vero che si e' perso il nome della colonna, si ha qualche informazione circa la sua posizione: il nome nel catalogo degli attributi riporta la posizione ordinale della colonna appena eliminata. In altre parole, 'pg.dropped.2' indica che e' stata eliminata la colonna numero 2 della tabella, come si puo' evincere dal file sorgente <i>heap.c</i>:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">/*                                                                                                                     </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">* Change the column name to something&nbsp;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">* that isn't likely to conflict                                                   </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">*/</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">snprintf(newattname, sizeof(newattname),</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">"........pg.dropped.%d........", attnum);</span><br /><br /><br /><div style="text-align: justify;">E la tabella, dal punto di vista fisico, come e' cambiata? Di fatto non e' cambiata, visto che lo storage non e' stato toccato:</div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT pg_size_pretty( pg_relation_size( 'dropping_test' ) ); pg_size_pretty </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">----------------</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">65 MB</span><br /><br /><br /><div style="text-align: justify;">A questo punto si puo' far intervenire vacuum per vedere cosa succede lato fisico e logico; in particolare il processo di vacuuming andra' a riscrivere le pagine dati rimuovendo lo spazio occupato dalla colonna rimossa. Il risultato, al termine dell'operazione, e' una riduzione della dimensione della tabelle e la scomparsa dell'attributo droppato nel catalogo di sistema:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">VACUUM FULL VERBOSE dropping_test;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">INFO:  vacuuming "public.dropping_test"</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">INFO:  "dropping_test": found 0 removable, 1000000 nonremovable row versions in 8334 pages</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">DETAIL:  0 dead row versions cannot be removed yet.</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">CPU 0.61s/0.53u sec elapsed 2.29 sec.</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">VACUUM</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Time: 4593.219 ms</span><br /><br />Che ci porta ad avere una tabella "compressa":<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT pg_size_pretty( pg_relation_size( 'dropping_test' ) );</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">pg_size_pretty </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">----------------</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">31 MB</span><br /><br /><br /><br /><div style="text-align: justify;">Si presti attenzione: tutto questo e' stato possibile perche' autovacuum era disabilitato:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SHOW autovacuum;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">autovacuum </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">------------</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">off</span><br /><br /><div style="text-align: justify;">Se autovacuum fosse stato attivo, come normalmente e', la riorganizzazione della tabella sarebbe avvenuta quasi subito e quindi la dimensione della tabella sarebbe cambiata sotto al naso dell'operatore.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Si noti che l'operazione inversa, l'aggiunta di una colonna, si comporta sostanzialmente in modo analogo: quando viene aggiunta una colonna il sistema memorizza nel catalogo la disponibilita' della nuova colonna, ma non opera sullo storage.</div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ALTER TABLE dropping_test ADD COLUMN description text;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ALTER TABLE</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Time: 19.337 ms</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT pg_size_pretty( pg_relation_size( 'dropping_test' ) );</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">pg_size_pretty </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">----------------</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">31 MB</span><br /><br /><div style="text-align: justify;">E si noti anche che la scrittura di una tupla non implica la riorganizzazione di tutta la tabella: di fatto, grazie ad MVCC, le tuple "nuove" sono in append sui dati e quindi le tuple "vecchie", prive di colonna aggiunta, non vengono riorganizzate:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">UPDATE dropping_test&nbsp;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SET description = 'Hello World' WHERE pk = 1;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT pg_size_pretty( pg_relation_size( 'dropping_test' ) );</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">pg_size_pretty </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">----------------</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">31 MB</span><br /><br /><div style="text-align: justify;">Discorso differente se si aggiunge una colonna con valore di default, cosa che forza il sistema a scrivere il valore di default su ogni tupla e quindi ad invalidare ogni tupla vecchia con conseguente raddoppiamento delle tuple e aumento di spazio:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ALTER TABLE dropping_test&nbsp;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ADD COLUMN description_initialized text&nbsp;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">default 'A fake description as default here!';</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ALTER TABLE</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Time: 4356.180 ms</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT pg_size_pretty( pg_relation_size( 'dropping_test' ) ); pg_size_pretty </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">----------------</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">65 MB</span><br /><br /><div style="text-align: justify;">In conclusione, PostgreSQL cerca di utilizzare lo storage fisico in modo molto efficiente ritardando il piu' possibile le scritture (o riscritture) su disco. Ancora una volta si evince come il comportamento di PostgreSQL sia molto guidato dal catalogo di sistema.</div>