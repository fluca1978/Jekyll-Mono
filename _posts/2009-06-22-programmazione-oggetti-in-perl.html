---
layout: post
title: Programmazione a oggetti in Perl
date: '2009-06-22T12:28:00.018+02:00'
author: Luca Ferrari
tags:
- perl
- università
- programmazione
modified_time: '2009-06-24T12:45:49.806+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-2115704792895662770
blogger_orig_url: http://fluca1978.blogspot.com/2009/06/programmazione-oggetti-in-perl.html
---

Perl è un linguaggio molto elegante e potente, che viene spesso insegnato per evidenziare concetti un po' più evoluti riguardo lo <span style="font-style: italic;">scripting</span>.<br />Pur supportando la programmazione ad oggetti, Perl non fornisce alcun costrutto particolare per la realizzazione di classi e tipi di dato astratto. Si può paragonare Perl a un C che viene programmato ad-hoc per implementare un comportamento ad oggetti.<br />Imparare a programmare Perl a oggetti è molto interessante, soprattutto perché permette di vedere effettivamente come molti compilatori a oggetti si comportano. Inoltre gran parte della libreria Perl/CPAN è orientata agli oggetti, e quindi è indispensabile avere nozioni di OOP. Non è comunque facile trovare una guida sulla programmazione OOP in Perl, perciò ho deciso di scrivere questo articolo introduttivo. Da notare che farò riferimento a versioni di Perl inferiori alla 6, dove la scrittura di classi e oggetti cambierà grazie alla presenza di apposite parole chiave.<br /><br />Il seguente elenco mostra i punti per me fondamentali da tenere a mente quando si vuole implementare una classe e di conseguenza usare degli oggetti.<br /><span style="font-style: italic;"><br /><span style="font-weight: bold;">Gli oggetti possono essere acceduti solo per riferimento.</span></span><br />Ogni istanza di oggetto viene mantenuta in un riferimento, in maniera simile a come avviene in Java<span style="font-style: italic;">.<br /><br /><span style="font-weight: bold;">Un riferimento ad un oggetto è un normale riferimento scalare</span></span><span style="font-weight: bold;">. </span><br />Come i riferimenti alle strutture dati native (hash, array) sono contenuti in variabili scalari, così pure i riferimenti agli oggetti sono mantenuti in variabili scalari.<span style="font-style: italic;"><br /><br /><span style="font-weight: bold;">Una classe corrisponde ad uno spazio dei nomi, e quindi si implementa tramite un package. </span></span><br />In Perl una classe è una entità sul quale sono richiamati dei metodi. Per la precisione, un metodo di classe è un metodo al quale viene passato un parametro che indica lo spazio dei nomi nel quale si agisce. Ecco quindi che assegnare un metodo ad una classe corrisponde ad inserire un metodo in un determinato package: il metodo potrà essere invocato solo nell'ambito di quello spazio dei nomi (classe/package).<br /><br /><span style="font-style: italic; font-weight: bold;">Se la struttura dati dell'oggetto è complessa, allora essa deve essere realizzata tramite un array o un hash, e il riferimento all'oggetto diventa il riferimento all'array/hash</span><span style="font-weight: bold;">. </span><br />Questo punto va chiarito bene: in Perl esistono solo tre tipi di variabili (scalari, array, hash) e una classe sarà presumibilmente composta da diverse variabili di tale tipo. Dovendo però usare un riferimento ordinario (si vedano i punti precedenti) per l'oggetto, si ha che tale riferimento deve essere il punto di ingresso di una struttura più complessa. Di conseguenza, il riferimento all'oggetto deve essere un riferimento ad un array/hash che contenga tutte le altre variabili di istanza. Per meglio comprendere, se in Java una definizione di classe <span style="font-style: italic;">Person</span> potrebbe essere così strutturata:<br /><pre></pre><blockquote><pre>public class Person{<br />   private String name = null;<br />   private String surname = null;<br />}</pre> </blockquote><br />In Perl non potrebbe avere la definizione duale, ossia:<br /><br /><pre><blockquote>package Person;<br /><br />$name = undef();<br />$surname = undef();</blockquote></pre>poiché, così facendo, si avrebbe che lo spazio dei nomi della persona (<span style="font-style: italic;">Person</span>) contiene due variabili scalari, ed è impossibile ritornare un singolo riferimento che fornisca accesso ad entrambe le variabili. E' quindi necessario incapsulare le variabili di classe all'interno di un unico contenitore e fornire accesso attraverso tale contenitore:<br /><blockquote><br /><pre>package Person;<br />...<br />$this = { name    => undef(),<br />      surname => undef(),<br />     };</pre></blockquote><pre><br /></pre><br />In questo modo la variabile <span style="font-style: italic;">$this</span> consente accesso ai valori di <span style="font-style: italic;">name</span> e <span style="font-style: italic;">surname</span>, ed è possibile ritornare all'esterno un singolo riferimento a <span style="font-style: italic;">$this</span>.<br />Da notare che la seguente traduzione non funziona come ci si aspetta:<br /><br /><pre><blockquote>package Person;<br /><br />$name    = undef();<br />$surname = undef();<br /><br />$this = { name    => \$name,<br />      surname => \$surname,<br />     };</blockquote></pre><br />Infatti così facendo si ha l'esistenza di uniche variabili <span style="font-style: italic;">$name</span> e <span style="font-style: italic;">$surname</span> e di conseguenza i riferimenti di ogni oggetto creato puntano alle stesse variabili globali (all'interno del package) e quindi agli stessi valori. La soluzione di cui sopra è invece appropriata per variabili statiche (ossia condivise all'interno di ogni classe).<br /><span style="font-style: italic;"><br /><span style="font-weight: bold;">Un metodo di classe o di oggetto riceve sempre in automatico un primo argomento che specifica la classe o l'istanza</span></span><span style="font-weight: bold;">. </span><br />Questa cosa non dovrebbe stupire particolarmente, poiché è già quello che avviene nei normali compilatori ad oggetti: il primo parametro di un metodo di istanza è il puntatore/riferimento all'istanza stessa. E' in questo modo che i compilatori predispongono la variabile <span style="font-style: italic;">this</span>. In altre parole, il metodo Java seguente:<br /><pre><blockquote>public class MyClass{<br />public void instanceMethod(String arg1, int arg2){<br /> this.stringVariable   = arg1;<br /> this.integerVariable = arg2;<br />}<br />}</blockquote><br /></pre>  viene mutato dal compilatore silenziosamente nel seguente:<br /><br /><pre><blockquote>public class MyClass{<br />public void instanceMethod(MyClass this, String arg1, int arg2){<br /> this.stringVariable   = arg1;<br /> this.integerVariable = arg2;<br />}<br />}</blockquote></pre><br />Da notare che il primo parametro, di nome simbolico <span style="font-style: italic;">this</span>, è un riferimento all'oggetto stesso. In altre parole i metodi di istanza ottengon come parametro la zona di memoria (o meglio il riferimento a tale zona) dove risiede l'oggetto sul quale si agisce. Perl segue lo stesso percorso: il primo argomento di un metodo di istanza contiene il riferimento all'oggetto stesso, di modo che il metodo possa essere scritto come:<br /><br /><pre><blockquote>sub instanceMethod{<br />my ($this, $arg1, $arg2) = @_;<br />...<br />}</blockquote></pre>   La differenza è che qui è compito del programmatore ricordarsi che il primo argomento è il riferimento all'istanza; il compilatore Perl infatti fa solo la prima parte del lavoro (passare al metodo il riferimento come primo argomento).<br />Quanto sopra per quello che riguarda gli oggetti, ma per le classi?<br />In un linguaggio OOP come Java/C++ i metodi di classe (es. <span style="font-style: italic;">static</span>) non necessitano di nessun argomento particolare o di modifiche da parte del compilatore. Infatti quello che avviene è che viene tenuta in memoria la tabella di dispatching dei metodi e l'invocazione di un metodo corrisponde al salto all'indirizzo fornito da questa tabella. Ma il metodo non ha bisogno di sapere se appartiene ad una classe oppure no, come non ha bisogno di sapere a che classe appartiene poiché per forza di cose, se non è di istanza, deve essere di classe.<br />In Perl questo non è vero: essendo una classe implementata tramite un <span style="font-style: italic;">package, </span>i metodi all'interno del package potrebbero essere di istanza, oppure di classe, oppure nessuno dei due (normali metodi globali). Perl allora fornisce un modo per informare un metodo che è stato invocato in un contesto di classe (ossia come se fosse un metodo di classe): questo metodo riceverà infatti come primo argomento il nome (stringa) della classe/package al quale appartiene.<br />Riassumendo quindi, tutti i metodi di classe o di oggetto in Perl ricevono come primo argomento una variabile che indica il nome della classe (metodo di classe) o il riferimento all'oggetto stesso (metodo di oggetto) e non ricevono nulla se sono chiamati in un normale contesto di package.<span style="font-style: italic;"><br /><br /><span style="font-weight: bold;">In Perl non esiste il concetto di costruttore (e di distruttore)</span></span><span style="font-weight: bold;">. </span><br />Siccome Perl non fornisce nessuna parole chiave per definire una classe, i metodi costruttori (e distruttori) non esistono. Questo non significa che non si possano creare dei metodi appositi per l'inizializzazione delle variabili di un oggetto. Tali metodi dovranno ovviamente restituire al chiamante il riferimento alla struttura dati dell'oggetto.<span style="font-style: italic;"><br /><br /><span style="font-weight: bold;">Un metodo usato come costruttore non deve avere lo stesso nome della classe</span></span><span style="font-weight: bold;">. </span><br />Siccome questi metodi non sono dei veri e propri costruttori, non devono seguire le regole standard dei costruttori Java e C++: essi possono (o meglio devono) avere un tipo di ritorno (solitamente il riferimento alla struttura dati dell'oggetto) e possono avere un nome non vincolante (solitamente <span style="font-style: italic;">new</span>).<span style="font-style: italic;"><br /><br /><span style="font-weight: bold;">In Perl non esiste l'operatore new</span></span><span style="font-weight: bold;">. </span><br />Quando si incontra qualcosa che assomiglia all'operatore <span style="font-style: italic;">new</span> per l'allocazione di un oggetto, si sta in effetti osservando la chiamata di un metodo di nome <span style="font-style: italic;">new</span> (si veda il punto precedente).<br /><span style="font-weight: bold;">Il compilatore passa automaticamente ad un metodo il primo argomento (nome della classe o riferimento ai dati) quando si usa l'operatore freccia.</span><br />Quando la chiamata ad un metodo avviene attraverso l'operatore freccia, il compilatore passa come primo argomento del metodo l'oggetto <span style="font-style: italic;">lvalue</span> su cui viene applicato l'operatore freccia. In altre parole:<br /><pre><blockquote>LVALUE->method(arg1, arg2, arg3);</blockquote></pre><br />corrisponde a:<br /><pre><blockquote>method(LVALUE, arg1, arg2, arg3);</blockquote></pre>Questo significa quindi che usando l'operatore freccia su i metodi di un package si ha automaticamente una chiamata a metodo di classe, mentre usando l'operatore freccia su dei riferimenti ad oggetti si ha una chiamata ad un metodo di istanza. Quindi ad esempio, per creare un nuovo oggetto, si può invocare il metodo <span style="font-style: italic;">new</span> nei due modi equivalenti:<br /><pre><blockquote>$objectReference = Person->new('Luca', 'Ferrari');  # sintassi di classe<br />$objectReference = new( Person, 'Luca', 'Ferrari'); # sintassi di package</blockquote><br /></pre><br />e analogamente, una invocazione di metodo di oggetto può essere scritta come:<br /><br /><pre><blockquote>$objectReference->setName('Giovanni');            # sintassi di oggetto<br />Person::setName( $objectReference, 'Giovanni');   # sintassi di package</blockquote><br /></pre>  <span style="font-weight: bold;">Perl deve sapere quali riferimenti puntano ad un oggetto e quali no.</span><br />Il costruttore di un oggetto non deve solo inizializzare l'oggetto e il suo stato, ma deve anche informare Perl che il riferimento non è un normale riferimento ma un collegamento ad un oggetto. Questo avviene tramite l'operatore <span style="font-style: italic;">bless</span>, che accetta il riferimento ad una struttura dati e la classe/package a cui la struttura dati appartiene. L'operatore memorizza in una tabella il collegamento fra il riferimento e il nome del package/classe a cui è associato, in modo da poter individuare a quale classe il riferimento appartiene. In particolare, in seguito al <span style="font-style: italic;">blessing</span>, l'operatore <span style="font-style: italic;">ref</span> applicato ad un riferimento di oggetto restituisce il nome della classe per la quale è stato fatto il blessing.<br />Sulla base di questa considerazione, il template generale per un costruttore di oggetto è il seguente:<br /><br /><pre>sub new<br />{<br />my ($class, @args) = @_;<br /># inizializza i valori dell'oggetto<br />$this = { arg1 => $args[0],<br />          arg2 => $args[1],<br />          ...<br />        };<br /><br />bless( $this, $class );<br />return $this;<br />}<br /></pre><br /><br /><br /><br /><br />Sulla base di tutti i punti di cui sopra, è possibile paragonare la creazione di una classe/oggetto fra un linguaggio OOP (es. Java) e Perl. Supponiamo di avere la seguente classe Java:<br /><br /><pre>public class Person{<br />public static int personCounter = 0;<br /><br />private String nome = null;<br />private String cognome = null;<br /><br />public Person(String nome, String cognome){<br />   this.nome = nome;<br />   this.cognome = cognome;<br />   Person.personCounter++;<br />}<br /><br /><br />public String getNome(){<br />  return this.nome;<br />}<br /><br />public String getCognome(){<br />  return this.cognome;<br />}<br />}<br /></pre><br />e di volerla tradurre in Perl. La sua definizione diviene la seguente:<br /><br /><pre><blockquote>#!/usr/bin/perl<br /><br />package Person;<br /><br /># variabile statica (la stessa<br /># condivisa fra tutte le istanze)<br />$personCounter = 0;<br /><br /><br />sub new<br />{<br /> my ($class, $name, $surname) = @_;<br /><br /> # creazione nuovo riferimento ad hash<br /> # con i dati (stato) dell'oggetto<br /> $this = {  name    => $name,<br />            surname => $surname,<br />         };<br /><br /><br /><br /> # associo il riferimento alla classe<br /> bless( $this, $class );<br /><br /> # incremento il contatore di istanze create<br /> $personCounter++;<br /><br /> print "\nCreazione di un nuovo oggetto di tipo $class (numero $personCounter)\n";<br /><br /> # restituisco il riferimento appena creato<br /> return $this;<br />}<br /><br /><br /><br /><br />sub getNome<br />{<br /> my ($this) = @_;<br /><br /> # restituisco il dato richiesto<br /> return  $this->{name};<br />}<br /><br /><br />sub getCognome<br />{<br /> my ($this) = @_;<br /><br /> # restituisco il dato richiesto<br /> return $this->{surname};<br />}</blockquote><br /><br /><br /><br /></pre>che può essere testato con il seguente main:<br /><br /><pre><blockquote>package main;<br /><br />$person1 = Person->new('Luca','Ferrari');<br />$person2 = Person->new('Paperon','De Paperoni');<br /><br />print "\nPersona con nome ", $person1->getNome();<br />print "\nAltra persona con nome ", $person2->getNome(), " ", $person2->getCognome();<br />print "\n\n";<br /></blockquote><br /></pre><br />che produce il seguente output:<br /><br /><pre><blockquote>Creazione di un nuovo oggetto di tipo Person (numero 1)<br /><br />Creazione di un nuovo oggetto di tipo Person (numero 2)<br /><br />Persona con nome Luca</blockquote>      Altra persona con nome Paperon De Paperoni<blockquote></blockquote><br /></pre><br /><span style="font-weight: bold;">Ereditarietà e Polimorfismo</span><br />L'ereditarietà in Perl viene implementata in modo molto semplice: è disponibile un array globale all'interno dello spazio dei nomi di un package, denominato <span style="font-style: italic;">ISA</span>, che contiene le classi/package dalle quali si vuole ereditare. L'idea quindi è semplice: ogni package definisce una lista di ulteriori package in cui cercare dati e/o metodi. Quando Perl non trova un attributo nel package specificato inizia ad esplorare (sequenzialmente) l'array ISA al fine di trovare in ogni classe specificata il simbolo, e quindi lo utilizza.<br />Per meglio comprendere questo concetto, si consideri di estendere la classe <span style="font-style: italic;">Person</span> con una classe <span style="font-style: italic;">Male</span> che implementa una persona di sesso maschile:<br /><br /><blockquote><br /><pre>package Male;<br /><br />@ISA=(Person);<br /><br />sub new<br />{<br />     my ($class, $name, $surname) = @_;<br /><br /> # creazione nuovo riferimento ad hash<br /> # con i dati (stato) dell'oggetto<br /> $this = {  name    => $name,<br />            surname => $surname,<br />         };<br /><br /><br /><br /> # associo il riferimento alla classe<br /> bless( $this, $class );<br /><br /> # incremento il contatore di istanze create<br /> $personCounter++;<br /><br /> print "\nCreazione di un nuovo oggetto di tipo $class (numero $personCounter)\n";<br /><br /> # restituisco il riferimento appena creato<br /> return $this;<br />}</pre></blockquote><pre><br /></pre><br />Come si può notare la definizione del costruttore è praticamente la stessa della classe <span style="font-style: italic;">Person</span>, addirittura si referenzia un simbolo (<span style="font-style: italic;">$personCounter</span>) che qui non è stato ancora definito. Ora se un programma crea un nuovo oggetto di tipo <span style="font-style: italic;">Male</span>:<br /><blockquote><br /><pre>$maschio = Male->new( $person1->getNome(), $person1->getCognome() );<br />print "\nPersona maschio con nome ", $maschio->getNome(), " ", $maschio->getCognome();</pre></blockquote><pre><br /></pre><br />l'output di esecuzione è del tutto simile a quello del programma precedente, e addirittura la variabile <span style="font-style: italic;">$personCounter</span> inizia il suo conteggio come fosse separata dalla classe <span style="font-style: italic;">Person</span> (ovvero come fosse stata definita singolarmente di classe). Tutta la magia viene fatta nella ricerca dei simboli, che anziché passare per una <span style="font-style: italic;">vtable</span> passa per l'array ISA del package corrente (ogni package può ridefinire il proprio @ISA).<br /><br />La ridefinizione dei metodi è automatica, quindi se si ridefinisce il seguente metodo nella classe <span style="font-style: italic;">Male</span> si ha che la chiamata a <span style="font-style: italic;">getNome()</span> verrà risolta da tale metodo:<br /><br /><pre><blockquote>package Male;<br /><br />@ISA=(Person);<br /><br />sub new<br />{<br />     my ($class, $name, $surname) = @_;<br /><br /> # creazione nuovo riferimento ad hash<br /> # con i dati (stato) dell'oggetto<br /> $this = {  name    => $name,<br />            surname => $surname,<br />         };<br /><br /><br /><br /> # associo il riferimento alla classe<br /> bless( $this, $class );<br /><br /> # incremento il contatore di istanze create<br /> $personCounter++;<br /><br /> print "\nCreazione di un nuovo oggetto di tipo $class (numero $personCounter)\n";<br /><br /> # restituisco il riferimento appena creato<br /> return $this;<br />}<br /><br /><br /><br />sub getNome<br />{<br /> my ($this) = @_;<br /><br /> return $this->{name} ." (maschio) ";<br />}</blockquote><br /><br /></pre>E' inoltre possibile riferirsi alle proprietà della classe base mediante l'uso di <span style="font-style: italic;">SUPER</span>. Si presti attenzione poiché qui super è un operatore che si preoccupa di salire di un livello nella scala dei riferimenti, ma il nome della classe deve essere sempre specificato come primo argomento: SUPER deve quindi essere usato in combinazione con l'operatore freccia.<br /><br /><pre><blockquote>package Male;<br /><br />@ISA=(Person);<br /><br />sub new<br />{<br />     my ($class, $name, $surname) = @_;<br /><br /> $this->SUPER::new( $name, $surname );<br /><br /><br /> # associo il riferimento alla classe<br /> bless( $this, $class );<br /><br /> # incremento il contatore di istanze create<br /> $personCounter++;<br /><br /> print "\nCreazione di un nuovo oggetto di tipo $class (numero $personCounter)\n";<br /><br /> # restituisco il riferimento appena creato<br /> return $this;<br />}<br /><br /><br /><br />sub getNome<br />{<br /> my ($this) = @_;<br /><br /> return $this->SUPER::getNome() ." (maschio) ";<br />}</blockquote></pre><br /><br />Si noti che quando si usa SUPER la parte a destra viene sempre invocata con la sintassi di package (::) mentre quella di sinistra con la sintassi ad oggetto (->).<br /><br /><br /><span style="font-weight: bold;">Per concludere</span><br />Riassumendo quindi si ha che in Perl la programmazione ad oggetti viene attualmente implementata tenendo separati i metodi e i dati, in modo piuttosto esplicito. Il riferimento ai dati rappresenta il riferimento all'oggetto (e quindi al suo stato), mentre l'invocazione dei metodi avviene grazie all'operatore freccia, che impone al compilatore di passare l'entità di sinistra (il riferimento o il nome della classe) come primo argomento. Grazie poi ad una tabella dei simboli gestita tramite l'operatore <span style="font-style: italic;">bless</span> si ha l'associazione fra riferimento ai dati e classe, e questo consente, in combinazione all'array <span style="font-style: italic;">@ISA</span> di sfruttare anche l'ereditarietà e il polimorfismo.