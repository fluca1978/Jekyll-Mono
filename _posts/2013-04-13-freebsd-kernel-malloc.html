---
layout: post
title: FreeBSD kernel malloc
date: '2013-04-13T17:53:00.000+02:00'
author: Luca Ferrari
tags:
- c
- kernel
- programmazione
- freebsd
modified_time: '2013-04-13T17:53:00.590+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-5869706215736803608
blogger_orig_url: http://fluca1978.blogspot.com/2013/04/freebsd-kernel-malloc.html
---

<div style="text-align: justify;">The FreeBSD kernel provides a set of malloc/free functions that are similar to the C-library ones for managing the memory inside the kernel space.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">All the memory management is done using the <i>malloc_type</i> structure, that is defined as follows:</div><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">struct malloc_type {</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp; struct malloc_type *ks_next;    /* Next in global chain. */</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp; u_long           ks_magic;      /* Detect programmer error. */</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp; const char      *ks_shortdesc;  /* Printable type name. */</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp; void            *ks_handle;     /* Priv. data, was lo_class. */</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">};</span></span><br /><br /><div style="text-align: justify;">The first field is a pointer to another <i>malloc_type</i> structure used to chain the allocated memory descriptor in a list, in particular the kern_malloc.c contains a kmemstatistics struct that always points to the last allocated malloc_type structure (and hence to the head of the chain). The ks_magic field is used to check for wrong malloc'ed areas: if it does not contains the special value <i>M_MAGIC</i> the kernel will panic assuming the memory is corrupted. The ks_shortdesc contains a description of the memory area, as reported in the output of the command "<i>vmstat -m</i>". Finally, the <i>ks_handle</i> field contains another structure, <i>malloc_type_internal</i> that in turns contains private kernel data, such as DTrace probes, the zone from which the memory has been allocated and statistics about the memory area itself.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Therefore in order to handle a memory chunk in the kernel space a malloc_type struct must be hold. There are two main macros to deal with malloc_type, defined in the sys/malloc.h header file:</div><div style="text-align: justify;">- <i>MALLOC_DEFINE</i></div><div style="text-align: justify;">- <i>MALLOC_DECLARE</i></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">The former, <i>MALLOC_DEFINE</i>, is used to define an area of memory that will be allocated later using the <i>malloc(9)</i> call. The latter, <i>MALLOC_DECLARE</i>, is a shortcut for "importing" a memory definition into another source file.</div><div style="text-align: justify;">The <i>MALLOC_DEFINE</i> macro is shown in the following:</div><br /><br /><i>#define MALLOC_DEFINE(type, shortdesc, longdesc)                        \</i><br /><i>&nbsp;&nbsp; struct malloc_type type[1] = {                                  \</i><br /><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { NULL, M_MAGIC, shortdesc, NULL }                      \</i><br /><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };                                                              \</i><br /><i>&nbsp;&nbsp; SYSINIT(type##_init, SI_SUB_KMEM,&nbsp;</i><br /><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SI_ORDER_SECOND, malloc_init, \</i><br /><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type);                                                      \</i><br /><i>&nbsp;&nbsp; SYSUNINIT(type##_uninit, SI_SUB_KMEM,&nbsp;</i><br /><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SI_ORDER_ANY,             \</i><br /><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; malloc_uninit, type)</i><br /><br /><br /><div style="text-align: justify;">The macro contains three instructions. The first is the declaration and initialization of a <i>malloc_type</i> structure as a single element array (this trick is done to have a pointer to the malloc type within the macro itself - the array name is the pointer to the malloc type). The other two instructions attach the <i>malloc_init</i> and <i>malloc_uninit</i> functions to the specified malloc type. In this way, the system will initialize (and uninitialize) the memory area with the above functions (from <i>kern_malloc.c</i>). The <i>SI_SUB_KMEM</i> subsystem is scanned and executed during the boot, and if the <i>MALLOC_DEFINE</i> happens to be in a module, the initialization and desctruction happens as soon as the module is loaded/unloaded. The "<i>##</i>" used in the macro is for macro token concatenation.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">To better understand the above <i>MALLOC_DEFINE</i> macro, suppose the following is called in a module:</div><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">MALLOC_DEFINE( M_LUKE, "Luke Memory",&nbsp;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Memory for the Luke subsystem" );</span></span><br /><br />this will expand to:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">struct malloc_type M_LUKE[1] =&nbsp;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { { NULL, M_MAGIC, "Luke Memory", NULL } };</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SYSINIT(M_LUKE_init,&nbsp;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SI_SUB_KMEM, SI_ORDER_SECOND,&nbsp;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; malloc_init, M_LUKE );</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SYSUNINIT(M_LUKE_uninit,&nbsp;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SI_SUB_KMEM, SI_ORDER_ANY,&nbsp;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; malloc_uninit, type); </span></span><br /><br /><br /><div style="text-align: justify;">The second macro for memory usage is <i>MALLOC_DECLARE</i>, that is defined in sys/malloc.h as follows:</div><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">#define MALLOC_DECLARE(type) \</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">extern struct malloc_type type[1]</span></span><br /><div style="text-align: justify;"><br /></div><div style="text-align: justify;">and that is useful simply to inform that a piece of malloc-based memory metadata has been defined somewhere else in the source tree.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">In order to conclude this brief bird's eye view on kernel memory allocation, the <i>malloc_init</i> and <i>malloc_uninit</i> functions defined in <i>sys/kern_malloc.c</i> perform calls to the <i>uma_zalloc</i> and <i>uma_zfree_arg</i> to respectively allocate and free a memory chunk. The zone used for the allocation is always the same, called <i>mt_zone</i> and created in the <i>kmeminit</i> function (executed of course early in the boot sequence):</div><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span></span><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">static void</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">kmeminit(void *dummy)</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">{</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">...</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">mt_zone = uma_zcreate("mt_zone",&nbsp;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(struct malloc_type_internal),</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, NULL, NULL, NULL </span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UMA_ALIGN_PTR, UMA_ZONE_MALLOC);</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">...</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">}</span></span><br /><br />The UMA related functions are defined in the <i>vm/uma_core.c </i>source file.