---
layout: post
title: Why OO does not suck!
date: '2009-03-24T13:49:00.005+01:00'
author: Luca Ferrari
tags:
- riflessioni
- programmazione
- java
modified_time: '2009-03-24T14:11:02.268+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-2163867651814079697
blogger_orig_url: http://fluca1978.blogspot.com/2009/03/why-oo-does-not-suck.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


Well, I've just finished reading the article <a href="http://www.sics.se/%7Ejoe/bluetail/vol1/v1_oo.html">Why OO Sucks by Joe Armstrong</a>, the inventor of <a href="http://www.erlang.org/">Erlang</a>, and I must admit I'm almost disappointed.<br />I believe the article faces the problem of OOP in a very shallow way, there are no concrete side-effects of OO as described in the paper and, by the way, I was expecting something better and stronger than that from a person like Armstrong.<br />While it is true that functions and data structures does not belong to the same space, that is the former are active entities, while the latter are passive entities, it is true that they are bound together. The reason is that, as stated in the paper, functions manipulates data structures, and thus data structures are inputs (and outputs) of funtions. This is a very strong bind, and since it is well known that the wrong data structure passed to the right function can lead to a crash, binding the function to the data structure it expects to get as input is a very clever idea.<br />Moreover, understanding classes and objects is the same difficult as understanding functions, since after all a class is a prototype of a behaviour connected to an internal implementation.<br />I believe that modelling the OO way really simplifies software development. After all, in the OOP way you can have someone building a class <span style="font-style: italic;">engine  </span>and providing you with functions to <span style="font-style: italic;">accelerate, decelerate</span> and so on. This is what happens in the real world, when you buy car. Nobody must understand what engine functions do, how they do or how the engine data structure has been assembled. All you have to do is to understand how to use operations (functions) defined for the engine. <span style="font-weight: bold;">It is a matter of abstraction</span>.<br />Now it is clear that, in an OO language, everything is supposed to be an object, or at least it is desiderable to be. Of course there are exceptions, like static classes, static methods, and so on. But with a good hierarchy, every function can be able to manipulate every object and variable in the system (just think at the java.lang.Object). So there's an escape way even for OO to be as much general as possible and, at the same time, as less typed as possible!<br />Remember that OOP is an evolution of modular programming (like C).<br />It is true that, in OO, data type definition are spead along the system, but this is natural because in this paradigm data definition <span style="font-style: italic;">are  </span>the system! And it is false that to use some functions of an object you have to inherit from it! In fact, as a best practice, you should not inherit at all, al least use composition!<br />Finally, it is surely true that OOP has opened a new problems/solutions range on which industry has made different business, but saying that this is the only reason why OOP has been pushed to developers sounds odd to me.<br /><br />I believe that Mr. Armstrong has understood what OOP is, but he could elaborate more his article because it appears a little much simple and shallow in all his statements.