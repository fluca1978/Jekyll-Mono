---
layout: post
title: Ridirezione dei comandi shell
date: '2008-02-10T14:51:00.001+01:00'
author: Luca Ferrari
tags:
- linux
- università
modified_time: '2008-02-10T16:29:33.227+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-7209000986139453382
blogger_orig_url: http://fluca1978.blogspot.com/2008/02/ridirezione-dei-comandi-shell.html
---

Una cosa molto utile nelle shell Unix è la ridirezione dei comandi, ovvero la capacità di inviare l'output o reperire l'input di un comando da un file. La ridirezione viene effettuata mediante i caratteri speciali > e <. Ho notato che molto spesso gli studenti universitari tendono a confondere i tipi di riderezione, generando errori goffi nei loro programmi. In questo articolo vengono mostrate alcune semplici regole da tenere presente nell'utilizzo della ridirezione.  <span style="font-weight: bold;"><br /><br /><br />Ridirezione dello standard output<br /><br /></span>La ridirezione dello standard output avviene <span style="font-style: italic;">sempre  </span>con il carattere >, che deve essere seguito <span style="font-style: italic;">sempre</span> da un file, e mai da un comando. E' possibile ridirezionare anche lo standard error, utilizzando la forma 2>. In generale, > supporta la ridirezione di ogni file descripto aperto dal processo. Ricordando che il file descriptor 1 è associato allo standard output, e il 2 allo standard error, si capisce come 2> ridirezioni appunto lo standard error. Per la stessa ragione, > e 1> svolgono la stessa funzione.<br /><br />E' poi possibile ridirezionare i flussi di output specificando direttamente il file descriptor al quale fare riferimento. Ad esempio, se si ridireziona lo standard output, è possibile dire al sistema di ridirezionare lo standard error nello stesso modo. Questo si ottiene con 2>&amp;1, che specifica che il file descriptor 2 (stderr) deve essere ridirezionato (>) come (&amp;) il file descriptor 1. Una prassi comune è quella di avere:<br /><br /><span style="font-size:85%;"><span style="font-family:arial;">comando > output.txt 2>&amp;1</span></span><br /><br />che cattura stdout e stderr e li salva assieme nel file output.txt.<br />Per concludere, ecco alcuni esempi:<br /><br />Ecco alcuni esempi:<br /><span style="font-size:85%;"> <span style="font-family:courier new;"> ls > elenco_file.txt<br /></span><span style="font-family:courier new;"> (memorizza la lista dei file in elenco_file.txt)<br /></span> <span style="font-family:courier new;"> ls 1> elenco_file.txt<br /></span><span style="font-family:courier new;"> (come sopra)<br /></span> <span style="font-family:courier new;"> ls > elenco_file.txt 2>errori.txt<br /></span><span style="font-family:courier new;"> (memorizza la lista dei file in elenco_file.txt, e gli errori, come ad esempio mancati permessi, in errori.txt)<br /></span> <span style="font-family:courier new;"> ls > elenco_file.txt 2>&amp;1<br /></span><span style="font-family:courier new;"> (memorizza la lista dei file in elenco_file.txt, assieme agli errori)<br /></span> <span style="font-family:courier new;"> ls > elenco_file.txt 2>/dev/tty<br /></span><span style="font-family:courier new;"> (memorizza la lista dei file in elenco_file.txt e mostra a terminale gli errori)<br /><br /></span> <span style="font-family:courier new;"> ls > elenco_file.txt 2>/dev/null<br /></span><span style="font-family:courier new;">  (memorizza la lista dei file in elenco_file.txt e butta via gli errori)<br /><br /></span></span><br />La ridirezione in append segue le stesse regole, eccetto che utilizza la forma >> e che non prevede una forma complementare per lo stderr (non esiste 2>>&amp;1). Si tenga comunque presente che un comando del tipo:<br /><br /><span style="font-size:85%;"><span style="font-family:arial;">ls >> elenco_file.txt 2>&amp;1</span></span><br /><br />inserisce in append sia stdout che stderr.<br /><br /><span style="font-weight: bold;">Ridirezione dello standard input</span><br />La ridirezione dello standard input avviene sempre con il carattere <, che deve essere sempre preceduto da un comando e mai da un file. Non ha in questo caso senso specificare un numero di file descriptor, essendo lo stdin associato al file descriptor 0.    Si tenga presente che, <span style="font-style: italic;">indipendentemente dal carattere di ridirezione usato, a destra di tale carattere si deve avere sempre un file, mentre a sinistra un comando.</span> Ovvero:<br /><br /><div style="text-align: center;">comando > file<br />comando < file<br /><br /><div style="text-align: left;"><span style="font-weight: bold;">Ridirezione fra processi</span><br />Qualora sia necessario passare lo stdout di un programma ad un altro programma, occorre utilizzare la pipe (|), <span style="font-style: italic;">che deve sempre avere alla sua sinistra e alla sua destra due comandi, mai dei file</span>. E' quindi sbagliato scrivere qualche cosa come:<br /><br /><span style="font-size:85%;"><span style="font-family:arial;">ls  > wc -l</span> </span><br /><span style="font-size:85%;"><span style="font-family:arial;">wc -l <></span><br /><br /><span style="font-size:85%;"><span style="font-size:85%;">mentre la forma corretta è:</span></span><br /><br /><span style="font-size:85%;"><span style="font-size:85%;"><span style="font-size:85%;"><span style="font-family:arial;">ls | wc -l</span></span></span></span><br /><br /><br /><span style="font-size:85%;"><span style="font-size:85%;"><span style="font-weight: bold;">Clobbing</span></span></span><br /></div><div style="text-align: left;"><span style="font-size:85%;"><span style="font-size:85%;">La normale ridirezione dello stdout (>) ha un comportamento di default abbastanza pericoloso: se il file non esiste viene creato, ma se il file esiste il suo contenuto viene totalmente sovrascritto. In molti casi questo è un comportamento utile, ma rischia di far perdere il contenuto di un file per errori di battitura o di fretta. E' possibile disabiltare questo comportamento impostando il <span style="font-style: italic;">clobbing</span> della shell. In sostanza, attivando l'opzione <span style="font-style: italic;">noclobber</span>, la shell non consente la sovrascrittura di un file esistente (è invece consentita la ridirezione in append >>). Per settare l'opzione è sufficiente dare il comando seguente:</span></span><br /></div><div style="text-align: left;"><br /><span style="font-size:85%;"><span style="font-size:85%;"><pre>set -o noclobber </pre></span></span><br /><br /><span style="font-size:85%;"><span style="font-size:85%;">e se si tenta di sovrascrivere un file esistente, la shell avverte l'utente con un errore:</span></span><br /><br /><span style="font-size:85%;"><span style="font-size:85%;"><pre>echo "ciao" > elenco_file.txt</pre></span></span><br /><span style="font-size:85%;"><span style="font-size:85%;"><pre>bash: elenco_file.txt: cannot overwrite existing file</pre></span></span><br /><span style="font-size:85%;"><span style="font-size:85%;">E' comunque possibile evitare l'opzione di clobbing utilizzando lo speciale operatore >!, che consente di sovrascrivere il contenuto di un file <span style="font-style: italic;">sempre</span>:</span></span><br /><br /><span style="font-size:85%;"><span style="font-size:85%;"><pre>echo "ciao" >! elenco_file.txt</pre>Si presti attenzione al fatto che il clobbing disabilita anche le funzioni di interpretazioni dei caratteri speciali della shell, ad esempio l'uso di * non funzionerà più.</span></span><br /><br /><span style="font-size:85%;"><span style="font-size:85%;">Riassumendo quindi, qualora si effettui una ridirezione dello stdout, è opportuno procedere come segue:</span></span><br /><span style="font-size:85%;"><span style="font-size:85%;"><ul><li>se il file destinazione deve sempre essere azzerato, è bene usare l'operatore >!, così da evitare errori dovuti ad una errata impostazione del clobbing;</li><li>se il file destinazione potrebbe non essere sovrascritto (a seconda della volontà dell'utente), si utilizzi l'operatore di ridirezione normale (>).</li></ul></span></span></div></div>