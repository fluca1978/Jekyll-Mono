---
layout: post
title: Gestione dei tipi nel driver JDBC
date: '2009-05-13T12:40:00.005+02:00'
author: Luca Ferrari
tags:
- programmazione
- postgresql
- java
modified_time: '2009-05-13T13:01:24.880+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-1386428096146912596
blogger_orig_url: http://fluca1978.blogspot.com/2009/05/gestione-dei-tipi-nel-driver-jdbc.html
---

Immagiamo di avere una tabella con un campo data, uno intero e uno stringa, e di scrivere e usare il seguente semplice programma JDBC:<br /><br /><pre>public class PGTest {<br />   public static void main(String[] args) throws Exception{<br /> Class driverClass = Class.forName("org.postgresql.Driver");<br /> driverClass.newInstance();<br /> <br /> Connection connection = DriverManager.getConnection("jdbc:postgresql://localhost/pgdaydb","luca", "fluca");<br /> <br /> Statement st = connection.createStatement();<br /> String sql = "SELECT date_field, int_field, string_field FROM mytable";<br /> ResultSet rs = st.executeQuery(sql);<br /> <br /> while(rs.next()){<br />     String stringForDate = rs.getString("date_field");<br />     String stringForInt  = rs.getString("int_field");<br />     int    intForString  = rs.getInt("string_field");<br />    <br />     System.out.println("Obtained: " + stringForDate + " - " + stringForInt + " - " + intForString);<br /> }<br /><br />   }<br />}<br /></pre><br />Quello che succede è che i campi sono ottenuti dal database, ma i loro valori sono scambiati: il tipo data e intero sono inseriti in stringhe e quello stringa in un intero.<br />Se siete fortunati, questo programma girerà senza nessun problema!<br />Come mai avviene cio?<br />La ragione è che il driver JDBC di PostgreSQL gestisce la comunicazione con il backend attraverso stringhe di caratteri, e quindi ogni valore di tupla inviato indietro dal database è restituito come "stringa". A questo punto, quando su una colonna invocate un getInt() il driver effettua (si veda AbstractJdbc2ResultSet):<br /><br /><pre> public int getInt(int columnIndex) throws SQLException<br />   {<br />       checkResultSet(columnIndex);<br />       if (wasNullFlag)<br />           return 0; // SQL NULL<br /><br />       Encoding encoding = connection.getEncoding();<br />       if (encoding.hasAsciiNumbers()) {<br />           try {<br />               return getFastInt(columnIndex);<br />           } catch (NumberFormatException ex) {<br />           }<br />       }<br />       return toInt( getFixedString(columnIndex) );<br />   }<br /><br /><br /><br />   public static int toInt(String s) throws SQLException<br />   {<br />       if (s != null)<br />       {<br />           try<br />           {<br />               s = s.trim();<br />               return Integer.parseInt(s);<br />           }<br />           catch (NumberFormatException e)<br />           {<br />               try<br />               {<br />                   BigDecimal n = new BigDecimal(s);<br />                   BigInteger i = n.toBigInteger();<br /><br />                   int gt = i.compareTo(INTMAX);<br />                   int lt = i.compareTo(INTMIN);<br /><br />                   if (gt > 0 || lt < 0)<br />                   {<br />                       throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"int",s}),<br />                                               PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);<br />                   }<br />                   return i.intValue();<br /><br />               }<br />               catch ( NumberFormatException ne )<br />               {<br />                   throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"int",s}),<br />                                           PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);<br />               }<br />           }<br />       }<br />       return 0;  // SQL NULL<br />   }<br /></pre><br /><br />Quindi il driver effettua una semplice conversione a Integer della stringa con il valore della colonna. In sostanza il driver non effettua nessun controllo sul tipo del dato che si sta chiedendo al ResultSet, e tenta di convertirlo da stringa al valore desiderato.<br />Si noti che comunque il driver e' ingrado di stabilire il tipo di una determinata colonna, e in effetti la generica <span style="font-style: italic;">getObject()</span> viene implementata per mezzo di <span style="font-style: italic;">getInternalObject()</span>:<br /><br /><pre> protected Object internalGetObject(int columnIndex, Field field) throws SQLException<br />   {<br />       switch (getSQLType(columnIndex))<br />       {<br />       case Types.BIT:<br />           // Also Types.BOOLEAN in JDBC3<br />           return getBoolean(columnIndex) ? Boolean.TRUE : Boolean.FALSE;<br />       case Types.TINYINT:<br />       case Types.SMALLINT:<br />       case Types.INTEGER:<br />           return new Integer(getInt(columnIndex));<br />       case Types.BIGINT:<br />           return new Long(getLong(columnIndex));<br />       case Types.NUMERIC:<br />       case Types.DECIMAL:<br />           return getBigDecimal<br />                  (columnIndex, (field.getMod() == -1) ? -1 : ((field.getMod() - 4) &amp; 0xffff));<br />       case Types.REAL:<br />           return new Float(getFloat(columnIndex));<br />       case Types.FLOAT:<br />       case Types.DOUBLE:<br />           return new Double(getDouble(columnIndex));<br />       case Types.CHAR:<br />       case Types.VARCHAR:<br />       case Types.LONGVARCHAR:<br />           return getString(columnIndex);<br />       case Types.DATE:<br />           return getDate(columnIndex);<br />       case Types.TIME:<br />           return getTime(columnIndex);<br />       case Types.TIMESTAMP:<br />           return getTimestamp(columnIndex, null);<br />       case Types.BINARY:<br />       case Types.VARBINARY:<br />       case Types.LONGVARBINARY:<br />           return getBytes(columnIndex);<br />       case Types.ARRAY:<br />           return getArray(columnIndex);<br />       case Types.CLOB:<br />           return getClob(columnIndex);<br />       case Types.BLOB:<br />           return getBlob(columnIndex);<br />      ...<br />     }<br /></pre>e quindi viene cercato il tipo della colonna per poter fare un cast automatico opportuno.<br />Nelle specifiche JDBC esiste una tabella che illustra le conversioni che un driver deve supportare fra i vari tipi. Ad esempio la tabella illustra come una data possa anche essere ottenuta come byte[]. Si presti attenzione al fatto che tali conversioni sono le <span style="font-style: italic;">minime indispensabili</span> che un driver deve fornire, quindi il fatto che il driver JDBC di PostgreSQL consenta anche la conversione di esempio da data a stringa non rappresenta affatto una limitazione del driver stesso.