---
layout: post
title: L'importanza delle convenzioni dei nomi
date: '2010-11-26T22:52:00.003+01:00'
author: Luca Ferrari
tags:
- programmazione
- postgresql
modified_time: '2010-11-26T22:52:00.256+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-4510898346191929364
blogger_orig_url: http://fluca1978.blogspot.com/2010/11/limportanza-delle-convenzioni-dei-nomi.html
---

<div style="text-align: justify;">E' innegabile il valore delle convenzioni applicate ad un progetto software di qualsiasi natura. Le convensioni aumentano la leggibilità delle risorse (tipicamente del codice), semplificano il refactoring, la manutenzione e in generale pongono le basi per l'automazione.</div><div style="text-align: justify;">In un progetto database le convenzioni sul nome delle tabelle, procedure, trigger e delle colonne è ancora piu' importante: il database può facilmente crescere a dismisura, arrivando ad avere relazioni intricate fra oggetti diversi. Tuttavia occorre ricordarsi che un DBMS è differente da un sistema OOP, e quindi le convenzioni da usare su uno possono essere differenti e portare a differenti risultati rispetto a quelle usate nell'altro. Si prendano ad esempio i nomi delle colonne: in un sistema OOP i nomi degli attributi degli oggetti potrebbero assumere la stessa convenzione al fine di automatizzare l'accesso alle proprietà stesse, complice anche l'ereditarietà. In altre parole, avendo due oggetti come <i>Person</i> e <i>Department</i> ciascuno dotato di un codice identificativo (<i>ID</i>) e di una descrizione (<i>description</i>) si potrebbe pensare di dotare i due oggetti delle stesse proprietà <i>getID/setID</i> e <i>getDescription/setDescription</i>. Facile, comprensibile, omogeno.&nbsp;</div><div style="text-align: justify;">Nel caso di un database con due tabelle che implementino gli stessi concetti si potrebbe pensare a creare due tabelle con le stesse convenzioni sui nomi: <i>person(ID integer, description text)</i> e <i>department(ID integer, description text). </i>La cosa può a prima vista sembrare naturale, e per molte applicazioni lo è. Tuttavia quando si tenta di mappare i due schemi uno sopra all'altro, si scopre che la convenzione sul nome delle colonne appena scelto produce uno spreco di codice. Si immagini infatti di voler esprimere la relazione fra un reparto e la lista delle persone che vi afferiscono: l'oggetto <i>Department </i>dovrà avere una collection di tipo <i>Person</i>, e nel database ci sarà una tabella di join fra le due di cui sopra. Il problema è che nel join i dati di una tabella devono essere riscritti per non andare in conflitto (ambiguità) con quelli dell'altra tabella, e quindi si potrà avere un solo <i>ID</i> e un solo <i>description</i> nell'output della query, mentre l'altro diventerà ad esempio <i>person_ID</i> e <i>person_description</i>. E perché questo semplice aliasing porterebbe alla scrittura di maggiore codice? Perché i DAO usati per caricare un reparto e una persona fanno affidamento a colonne che si chiamano <i>ID</i> e <i>description</i>, che sono venute a mancare nel join. Come si può risolvere questa problematica? Ci sono tre metodi principali:</div><ol style="text-align: justify;"><li>si scrive un DAO per il caricamento diretto di un <i>Person</i>, di un <i>Department</i> e di un join fra i due. Ovviamente questa soluzione non è molto pratica;</li><li>si creano delle viste su tutte le tabelle in modo che i dati ritornati siano sempre <i>person_ID, person_description, department_ID, department_description</i> sia per le query "semplici" che per i join. Ma questo richiede la scrittura di codice aggiuntivo e non molto utile;</li><li>si usa una convenzione differente nei nomi delle colonne: ogni colonna viene nominata con un prefisso che corrisponde al nome della tabella: <i>person( personID integer, personDescription text )</i> e <i>department( departmentID integer, departmentDescription text </i>). Così facendo i DAO vengono scritti sempre per colonne che sono univoche nel sistema, anche quando le tabelle vengono messe in join.</li></ol><div style="text-align: justify;">L'ultima soluzione, seppur appaia la piu' farraginosa, è quella che porta alla scrittura del minor codice possibile e soprattuto garantisce che se un DAO funziona per la tabella singola funzionerà senza variazione alcuna anche per tabelle in join. </div>