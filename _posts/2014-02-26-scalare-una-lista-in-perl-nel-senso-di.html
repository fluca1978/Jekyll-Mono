---
layout: post
title: Scalare una lista in Perl (nel senso di applicare scalar!)
date: '2014-02-26T16:56:00.000+01:00'
author: Luca Ferrari
tags:
- perl
modified_time: '2014-02-26T16:56:01.731+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-4849608141296180261
blogger_orig_url: http://fluca1978.blogspot.com/2014/02/scalare-una-lista-in-perl-nel-senso-di.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<div style="text-align: justify;">I contesti di invocazione di funzioni e operatori di Perl sono qualcosa di magico, e come ogni cosa magica non sempre funziona come ci si aspetterebbe. Qualche giorno fa una nota ha colpito la mia attenzione: l'uso dell'operatore scalar applicato ad una lista di liste.</div><div style="text-align: justify;">Cerco quindi con questo articolo di chiarire un po' il concetto di "da lista a scalare" e "da scalare a lista".</div><div style="text-align: justify;">Il passaggio da scalare a lista e' abbastanza facile: l'operatore ',' unito alle parentesi tonde permette di convertire una serie di scalari in una lista; e' inoltre possibile creare al volo liste di liste come ad esempio in:</div><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my (($minute, $hour), ($day, $month, $year)) = (localtime())[1..5];</span></span><br /><br /><div style="text-align: justify;">che, seppure privo di molto significato (poiche' si referenziano cinque scalari indipendenti) estrae due liste e assegna i singoli valori. La cosa e' equivalente a quanto segue:</div><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my @time = (localtime())[1,2];</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my @date = (localtime())[3,4,5];</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my $minute = $time[ 0 ];</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my $hour   = $time[ 1 ];</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my day     = $date[ 0 ];</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my month   = $date[ 1 ];</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my year    = $date[ 2 ];</span></span><br /><br />ma non equivalente a questa:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my ($minute, $hour, $day, $month, $year) = (localtime())[1..5];</span></span><br /><br />che invece estrapola una lista sola assegnando i singoli valori come segue:<br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my @time_and_date = (localtime())[1..5];</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my $minute = $time_and_date[ 0 ];</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my $hour   = $time_and_date[ 1 ];</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my day     = $time_and_date[ 2 ];</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my month   = $time_and_date[ 3 ];</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my year    = $time_and_date[ 4 ];</span></span><br /><br /><div style="text-align: justify;">In un certo senso l'operatore ',' e' sovraccaricato: se valutato in contesto scalare rappresenta una continuazione del flusso di esecuzione (come in C), se in contesto di lista concatena gli elementi (scalari o no) in una lista.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">L'operatore 'scalar' forza un contesto scalare dove c'e' un contesto di lista (ossia parentesi e virgola) annullando di fatto l'effetto delle parentesi e mutando il comportamento della virgola:</div><div style="text-align: justify;"><br /></div><ul><li>(,) viene valutato come virgola in contesto di lista</li><li>scalar (,) viene valutato come virgola in contesto scalare</li><li>scalar ,   viene valutato come virgola in contesto scalare</li></ul><br />Ecco allora che il seguente semplice esempio:<br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span></span><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">#!/usr/bin/env perl -w</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span></span><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my (($minute, $hour), ($day, $month, $year)) = (localtime())[1..5];</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$month++, $year += 1900;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span></span><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">print STDOUT "\nToday is $month / $day / $year at $hour:$minute\n";</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span></span><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">print STDOUT "\n all variables as list: ", (($minute, $hour), ($day, $month, $year));</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">print STDOUT "\n all variables via scalar: ", scalar (($minute, $hour), ($day, $month, $year));</span></span><br /><br /><br />produce come output:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">Today is 1 / 28 / 2014 at 13:48</span></span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;"><br /></span></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">all variables as list: 48132812014</span></span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">all variables via scalar: 2014</span></span><br /><br /><div style="text-align: justify;">Ossia la stampa della lista di liste produce, come ovvio, i valori concatenati, mentre la stampa 'scalar' della lista di lista produce la stampa del solo ultimo valore. In questo caso ogni operatore virgola viene trattato come continuazione del flusso di esecuzione. Da notare anche che la "lista di liste" Ã¨ solo un fatto mentale: di fatto ogni espressione fra parentesi viene resa una lista piatta, e quindi non importa quante coppie di parentesi ci siano.</div><div style="text-align: justify;">Da questo punto di vista l'operatore 'scalar' puo' essere pensato come un "anti-parentesi-di-lista". Da notare infatti che non conta quanto annidate siano le liste (ossia quante parentesi ci siano), l'espressione e' sempre valutata in contesto scalare come se fosse stata scritta senza parentesi.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">La documentazione riporta in modo ben chiaro questo fatto:</div><div style="text-align: justify;"><br /></div><blockquote class="tr_bq"><div style="text-align: justify;">Because "scalar" is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context.  <b>This is seldom what you want.</b></div></blockquote>