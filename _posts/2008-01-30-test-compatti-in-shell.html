---
layout: post
title: Test compatti in shell
date: '2008-01-30T12:49:00.001+01:00'
author: Luca Ferrari
tags:
- linux
modified_time: '2008-03-14T09:49:35.796+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-7559625736134399183
blogger_orig_url: http://fluca1978.blogspot.com/2008/01/test-compatti-in-shell.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<span style="font-family: arial;font-size:100%;" ><span style="font-size:130%;">Il comando expr(1)<br /></span></span><span style="font-size:100%;"><span style="font-family:arial;">Il comando expr(1) consente di valutare espressioni aritmetiche, e il suo uso in generale è il seguente:<br /></span><span style="font-family:arial;"><br />var=`expr val1 op val2`</span><br /><span style="font-family:arial;"><br />dove var è la variabile alla quale sarà assegnato il valore calcolato, val1 e val2 sono i due operandi e op e l'operatore. Ad esempio:</span><br /> <span style="font-family:arial;">var=`expr 10 + 20`</span> <span style="font-family:arial;">var=`expr $var + 1`</span><br /><span style="font-family:arial;">che assegna prima a var il valore 30, e successivamente incrementa di 1 il valore calcolato, riassegnandolo nuovamente a var.</span>  <span style="font-family:arial;">Indubbimante expr è un comando molto potente, ma la shell ci mette a disposizione un modo molto più conveniente per eseguire operazioni matematiche: (( )). Ogni espressione racchiusa fra (( )) viene valutata nel suo contesto aritmetico direttamente. L'esempio precedente viene quindi riscritto come:</span><br /><span style="font-family:arial;">(( var = 10 + 20   ))</span> <span style="font-family:arial;">(( var = $var + 1 ))</span><br /><span style="font-family:arial;">o ancora meglio</span><br /><span style="font-family:arial;">(( var = 10 + 20 ))</span> <span style="font-family:arial;">(( var++ ))</span> <br /><span style="font-family:arial;">A parte la maggiore compattezza del codice, bisogna considerare come (( )) non tenga conto degli spazi extra nell'assegnamento a variabile, cosa invece non tollerata dalla shell. Inoltre, expr restituisce il proprio risultato su stdout, e quindi deve essere catturato con i backtick per essere assegnato ad una variabile, mentre (( )) non restituisce nulla su stdout e assegna direttamente il valore calcolato alla variabile contenuta nell'espressione di assegnamento. Per entrambi il codice di ritorno ha la stessa semantica: 0 se il valore calcolato non è uguale a zero, 1 se il valore calcolato è uguale a zero.</span><br /></span><span style="font-family: arial;font-size:130%;" ><br />Il comando test(1)</span><span style="font-size:100%;"><br /><span style="font-family:arial;">Il comando test(1) viene utilizzato per verificare determinate condizioni, ad esempio l'esistenza di un file, i permessi o il confronto fra valori stringhe e numerici. Il coamndo test(1) è un eseguibile presente su disco, ad esempio sulla mia macchina ho:</span> <br /></span><pre style="font-family: arial;"><span style="font-size:100%;">ls -l `which test`<br />-rwxr-xr-x 1 root root 23036 2007-09-29 14:51 /usr/bin/test<br /><br />ls -l `which [`<br />-rwxr-xr-x 1 root root 25024 2007-09-29 14:51 /usr/bin/[</span></pre><span style="font-size:100%;"><br /><span style="font-family:arial;">Il secondo programma, la parentesi quadra [, rappresenta una sorta di sinonimo per il comando test(1). In realtà non è un vero sinonimo, visto che i due programmi sono indipendenti (e non linkati). Tuttavia il comando test(1) può essere sostituito con la coppia di parentesi quadre, ad esempio:</span><br /></span><pre style="font-family: arial;"><span style="font-size:100%;">if test -f $file<br />then<br />....<br />fi<br /></span></pre><span style="font-size:100%;"><br /><span style="font-family:arial;">diventa:</span><br /></span><pre style="font-family: arial;"><span style="font-size:100%;">if [ -f $file ]<br />then<br />....<br />fi<br /></span></pre><span style="font-size:100%;"><br /><span style="font-family:arial;">L'equivalenza fra i due programmi si ha perfino dalla pagina man di test(1), dove i due sono presentati come equivalenti. Attenzione però che il comando [ da solo non funziona: la shell necessita che le parentesi siano bilanciate, e quindi [ deve essere sempre seguito da un ].</span>  </span><span style="font-family: arial;font-size:100%;" ><span style="font-size:130%;"><br /><br />Test con operatori logici</span><br />Qualora si vogliano effettuare dei test usando [ al posto di test(1), si può ricorrere alla forma [[ e usare anche operatori logici e parentesi tonde per separare meglio i test. Ad esempio:<br /><br /><br />[[ (-f $file) &amp;&amp; ( (-d data) || (-d tmp) ) ]]<br /><br /><br />questo test controlla l'esistenza di un file e l'esistenza di una directory fra data e tmp. Si noti la compattezza di una simile espressione, che sarebbe risultata invece molto più complessa con il solo uso dell'operatore test(1).<br /></span><span style="font-family: arial;font-size:100%;" ><br /><br />Un buon tutorial sugli operatori [ ] , [[ ]] e (( )) si può trovare presso la <a href="http://www.ibm.com/developerworks/library/l-bash-test.html">libreria IBM</a>.</span>