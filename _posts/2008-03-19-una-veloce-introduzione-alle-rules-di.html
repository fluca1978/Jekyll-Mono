---
layout: post
title: Una veloce introduzione alle rules di PostgreSQL
date: '2008-03-19T14:20:00.000+01:00'
author: Luca Ferrari
tags:
- postgresql
modified_time: '2008-03-19T15:15:28.315+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-505718458443849604
blogger_orig_url: http://fluca1978.blogspot.com/2008/03/una-veloce-introduzione-alle-rules-di.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


PostgreSQL fornisce un potentissimo strumento per il <span style="font-style: italic;">query rewriting</span>: le <span style="font-style: italic;">rules</span>. Una rule è una regola che specifica come una particolare query DML debba essere riscritta al volo. L'utilizzo più comune delle rules si ha nelle viste: di fatto le viste sono delle informazioni su come riscrivere una query SELECT per ottenere le informazioni ricercate.<br />Ma altri utilizzi delle rules sono possibili: ad esempio è possibile intercettare un INSERT ed eseguire, contestualmente, un altro INSERT (es. log dei dati in inserimento) o addirittura ridirezionare l'inserimento su altre tabelle, o inibirlo totalmente. La stessa cosa si può fare per una query di UPDATE o DELETE. Va tenuto presente che le rules, seppur possano avere utilizzi molto simili a quelli di un trigger, hanno un notevole valore aggiunto rispetto a questi ultimi: esse sono infatti analizzate prima della effettiva esecuzione della query, e quindi intervengono prima che i dati siano effettivamenti letti/scritti sul database.<br /><br />Come semplice esempio didattico, si consideri di avere una tabella con articoli e relativi prezzi:<br /><br /><span style=";font-family:courier new;font-size:85%;"  >CREATE TABLE articoli_con_prezzo<br />(<br /> pk serial NOT NULL,<br /> descrizione character varying,<br /> prezzo double precision,<br /> CONSTRAINT articolo_con_prezzo_pk PRIMARY KEY (pk)<br />)</span><br /><br />sulle quali si andrà ad agire con query di inserimento simili alla seguente:<br /><br /><span style=";font-family:courier new;font-size:85%;"  >insert into articoli_con_prezzo(descrizione,prezzo) values('articolo001', 10.16);</span><span style="font-style: italic;font-size:85%;" ><br /><br /></span><br /><br />Si supponga ora di voler rendere più modulare il design della struttura dati relativa agli articoli, separando i dati anagrafici da quelli relativi al prezzo:<br /><br /><span style="font-size:85%;"><span style="font-style: italic;">CREATE TABLE articoli<br /></span><span style="font-style: italic;">(<br /></span><span style="font-style: italic;">  articolipk serial NOT NULL,<br /></span><span style="font-style: italic;">descrizione text,<br /></span><span style="font-style: italic;">CONSTRAINT articoli_pkey PRIMARY KEY (articolipk)<br /></span><span style="font-style: italic;">)<br /><br /></span><br /><span style="font-style: italic;">CREATE TABLE prezzo<br /></span><span style="font-style: italic;">(<br /></span><span style="font-style: italic;">pk serial NOT NULL,<br /></span><span style="font-style: italic;">articoli_pk integer,<br /></span><span style="font-style: italic;">prezzo double precision,<br /></span><span style="font-style: italic;"> CONSTRAINT prezzo_pk PRIMARY KEY (pk),<br /></span><span style="font-style: italic;"> CONSTRAINT articoli_prezzi_fk FOREIGN KEY (articoli_pk)<br /></span><span style="font-style: italic;">   REFERENCES articoli (articolipk) MATCH SIMPLE<br /></span><span style="font-style: italic;">   ON UPDATE NO ACTION ON DELETE NO ACTION<br /></span><span style="font-style: italic;">)<br /><br /></span></span><br /><br />A questo punto la tabella <span style="font-style: italic;">articoli_con_prezzo</span> non ha più validità, e quindi ogni query eseguita su di essa deve essere riscritta per considerare il nuovo schema a due tabelle. Ovviamente cambiare tutte le query in tutti i possibili client applicativi potrebbe essere non fattibile (anche se consigliato per correttezza), quindi si può ovviare utilizzando delle <span style="font-style: italic;">rules</span> che riscrivano al volo le query per tenere conto delle due tabelle.<br /><br />Si consideri il caso della query di inserimento: la regola deve separare i dati anagrafici da quelli di prezzo e inserire i primi nella tabella <span style="font-style: italic;">articoli</span>, e i secondi nella tabella<span style="font-style: italic;"> prezzo</span>:<br /><br /><span style="font-size:85%;">CREATE OR REPLACE RULE articoli_con_prezzo_insert_rule AS<br />   ON INSERT TO articoli_con_prezzo DO INSTEAD<br />   (<br />   INSERT INTO articoli (descrizione) VALUES( NEW.descrizione );<br />   INSERT INTO prezzo( articoli_pk, prezzo ) SELECT articolipk,NEW.prezzo FROM articoli WHERE descrizione=NEW.descrizione;<br />   )<br /></span><br /><br />Come si può notare, la regola si applica ad un evento di tipo <span style="font-style: italic;">INSERT</span> e inserisce la descrizione (<span style="font-style: italic;">NEW.descrizione</span>) nella tabella <span style="font-style: italic;">articoli</span> e il prezzo (<span style="font-style: italic;">NEW.prezzo</span>) nella tabella <span style="font-style: italic;">prezzo</span>. Come è facile intuire, la pseudo-relazione <span style="font-style: italic;">NEW</span> referenzia i dati passati alla query effettiva, e quindi con una query:<br /><br /><br /><span style=";font-family:courier new;font-size:85%;"  >insert into articoli_con_prezzo(descrizione,prezzo) values('articolo001', 10.16);</span><br /><br />si avrà che:<br /><br /><span style="font-size:85%;"><span style="font-style: italic;">NEW.descrizione = 'articolo001'<br /></span><span style="font-style: italic;">NEW.prezzo=10.16<br /><br /></span></span><br />Si noti che la descrizione di un articolo potrebbe non essere univoca, e quindi la tecnica usata per reperire la primary key del record inserito nella tabella <span style="font-style: italic;">articoli</span> non è particolarmente elegante e precisa, ma è sufficiente per i fini didattici di questo post.<br /><br />Avendo cambiato la query di inserimento, è possibile modificare anche la query di selezione. Purtroppo è necessario creare una tabella con la stessa struttura di quella originale ed effettuare le query su di essa, avendo cura di creare una regola apposita:<br /><br /><span style=";font-family:courier new;font-size:85%;"  >CREATE TABLE articoli_con_prezzo_tmp(pk integer, descrizione varchar, prezzo float);<br /><br />CREATE RULE "_RETURN" AS ON SELECT TO articoli_con_prezzo_tmp<br />DO INSTEAD<br />SELECT a.articolipk as pk, a.descrizione::varchar, p.prezzo<br />FROM articoli a, prezzo p<br />WHERE a.articolipk = p.articoli_pk<br /></span><br />La tabella <span style="font-style: italic;">articoli_con_prezzo_tmp</span> non deve essere riempita con i dati, serve solo come entry nel catalogo di sistema per associare ad essa la rule. Si noti che il nome della rule per il caso SELECT deve essere obbligatoriamente _RETURN (solo una rule per SELECT è possibile su ogni tabella) e che i campi in uscita devono avere lo stesso layout, nome e tipo di quelli della tabella alla quale la rule è applicata.