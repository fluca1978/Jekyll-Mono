---
layout: post
title: Inviare e-mail da PostgreSQL
date: '2009-04-30T15:20:00.003+02:00'
author: Luca Ferrari
tags:
- perl
- postgresql
modified_time: '2009-04-30T15:55:11.698+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-5858219335725505134
blogger_orig_url: http://fluca1978.blogspot.com/2009/04/inviare-e-mail-da-postgresql.html
---

Una delle caratteristiche che contraddistinguono maggiormente PostgreSQL da altre soluzioni database è la capacità di poter eseguire diversi linguaggi di programmazione per la scrittura di funzioni e trigger.<br />In sostanza PostgreSQL <span style="font-style: italic;">ospita</span> un linguaggio ed esegue il codice espresso in quel linguaggio integrandolo con i dati e i valori passati da un ambiente SQL. Vagamente questo approccia ricorda la programmazione CGI, ove il motore server invoca un programma esterno e lo esegue. La differenza è che nel caso di PostgreSQL il linguaggio viene eseguito in modo perfettamente integrato nel database.<br /><br />PostgreSQL riconosce due tipi di linguaggi ospite: <span style="font-style: italic;">trusted</span> e <span style="font-style: italic;">untrusted</span>. I primi vengono eseguiti in un ambiente fortemente controllato, e di conseguenza possono eseguire poche operazioni. I linguaggi untrusted invece possono fare tutto quello che è concesso al loro linguaggio (caricare moduli, librerie, ecc.), ma come conseguenza devono essere gestiti da un superutente del database. PostgreSQL quindi permette ad un utente di usare un linguaggio untrusted, a patto che sia proprio l'amministratore del cluster a "confermare" che si è a conoscenza dei rischi che si stanno correndo.<br /><br />Grazie all'uso dei linguaggi untrusted è possibile usare linguaggi che carichino moduli che ci semplificano diversi compiti, e nel mio caso l'invio di e-mail da una stored procedure.<br />Per questo ho scelto di usare Perl untrusted (<span style="font-style: italic;">plperlu</span>), che si installa nel database con:<br /><br /><span style="font-style: italic;">createlang plperlu <dbname></dbname></span><br /><br />Successivamente si puo' creare una stored procedure per l'invio delle e-mail. Siccome in un caso reale si vorra' inviare una e-mail in base a dei dati presenti nel database, il seguente esempio mostra come effettuare una query con le funzioni <span style="font-style: italic;">spi</span> e costruirsi il corpo della e-mail con questi valori. Da notare come la funzioni accetti tre parametri SQL che vengono usati da plperl come normali parametri Perl di una funzione.<br /><br /><pre>CREATE OR REPLACE FUNCTION notifica_email( integer, integer, text )<br />RETURNS integer AS<br />$BODY$<br /><br />  use Mail::Sendmail;<br />  use MIME::Base64;<br />  use MIME::QuotedPrint;<br /><br />  my ($id, $limit, $categoria) = @_;<br /><br /><br />  # query per estrarre informazioni dalla tabella<br />  $sql  = " SELECT codice, id_elemento, categoria, email FROM myTable ";<br />  $sql .= " WHERE id_elemento = $id AND categoria = '$categoria' ";<br />  $sql .= " LIMIT $limit ";<br /><br /><br />  # esecuzione della query per ottenere i risultati da processare<br />  $resultSet = spi_exec_query( $sql );<br /><br /><br /><br />  # numero di righe restituite<br />  $numRows = $resultSet->{processed};<br />  elog(INFO, "Trovate $numRows righe");<br /><br />  $ret=0;<br /><br />  ciclo: for( $i = 0; $i <= $numRows; $i++ ){       <br />      $rigaCorrente = $resultSet->{rows}[$i];<br /><br />      elog(INFO, "\nIterazione numero $i di $numRows\n");<br /><br />      # codice dell'elemento corrente<br />      $codice = $rigaCorrente->{"codice"};<br />      # categoria di questo elemento<br />      $categoria = $rigaCorrente->{"categoria"};<br />      # id elemento<br />      $id_elemento = $rigaCorrente->{"id_elemento"};<br />      # email a cui inviare le e-mail<br />      $email = $rigaCorrente->{"email"};<br />      # altri campi qui....<br /><br /><br />      # costruisco il messaggio del warning<br />      $messaggio = "Messaggio e-mail da PostgreSQL: $id_elemento, $categoria";<br />   <br />      # costruisco un soggetto per l'e-mail<br />      $subject = "Email da PostgreSQL";<br />      elog(INFO, "\n$subject");<br /><br />      # email di backup in copia all'amministratore<br />      $administrator_backup_address = "myself@myself.net";<br /><br /><br />      # costruzione della mail da inviare<br />      %mail = ( From    => "postgresql\@postgresql.org",<br />                To      => "$email",<br />                Cc      => "$administrator_backup_address",<br />                Subject => "$subject",<br />              );<br /><br />      # invio e-mail<br />      sendmail( %mail ) or die( $Mail::Sendmail::error) ;<br />      # incremento il numero di messaggi inviati fino ad ora<br />      $ret++;<br /><br />   <br />  }<br /><br /><br />   <br />  # restituisco il numero di messaggi inviati da questa procedura<br />  return $ret;<br /><br /><br /><br />$BODY$<br />LANGUAGE 'plperlu' VOLATILE<br />COST 100;<br />ALTER FUNCTION notifica_email() OWNER TO postgres;<br /></pre><br />E' possibile invocare la funzione con, ad esempio:<br /><br /><span style="font-style: italic;">select * from notifica_email( 1, 2, 'prodotti' );</span><br /><br />Da notare l'uso di elog() per la visualizzazione di messaggi in modo analogo all'uso di RAISE in una funzione plpgsql.