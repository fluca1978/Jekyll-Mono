---
layout: post
title: "= <> = (ossia quando un assegnamento non ha sempre lo stesso significato!)"
date: '2014-02-06T22:44:00.000+01:00'
author: Luca Ferrari
tags:
- perl
modified_time: '2014-02-06T22:44:00.448+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-2089848358999467365
blogger_orig_url: http://fluca1978.blogspot.com/2014/02/ossia-quando-un-assegnamento-non-ha.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<div style="text-align: justify;">In molti linguaggi C-like e' possibile concatenare istruzioni di assegnamento in una sola:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">a = b = foo();</span><br /><div style="text-align: justify;"><br /></div><div style="text-align: justify;">con il risultato che gli operandi a sinistra dell'ultimo simbolo '=' sono trattati tutti come lvalue e assegnati al valore rvalue simultaneamente, ovvero come se si fosse diviso l'assegnamento:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">b = foo();</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">a = b;</span><br /><br /><div style="text-align: justify;">In Perl la concatenazione degli assegnamenti potrebbe non seguire le stesse regole. O meglio, siccome in Perl e' lecito assegnare valori di tipo diverso fra loro, ogni operatore di assegnamento segue le regole del rispettivo lvalue. Per dimostrare questo fatto, tutto sommato semplice da capire ma che puo' rivelarsi molto subdolo, e' possibile considerare il seguente semplice programma:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">#!/usr/bin/env perl -w</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">use v5.10;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">sub foo{</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">return qw(Hello LIST World) if wantarray;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">return "Hello World";</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">}</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$scalar = foo();</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">@array  = foo();</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">say "The scalar value is &lt; $scalar &gt;";</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">say "The array values are &lt; @array &gt;";</span><br /><br />che produce l'atteso output che segue:<br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">The scalar value is &lt; Hello World &gt;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">The array values are &lt; Hello LIST World &gt;</span><br /><br /><div style="text-align: justify;">Il trucco e' semplice e ben noto: in Perl ogni cosa avviene in un contesto specifico e wantarray e' capace di fornire il contesto di chiamata della funzione consentendo una sorta di sovraccarico del valore di ritorno.</div><div style="text-align: justify;">Ma analizziamo un'assegnamento piu' complesso:</div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$scalar = @array = foo();</span><br /><br />L'output prodotto e' il seguente:<br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">The scalar value is &lt; 3 &gt;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">The array values are &lt; Hello LIST World &gt;</span><br /><br /><div style="text-align: justify;">Cosa e' successo?</div><div style="text-align: justify;">Per prima cosa viene valutato il rvalue dell'espressione, ossia foo(): tale funzione viene chiamata in un contesto di lista poiche' il primo assegnamento del rvalue e' ad un array, e quindi @array diviene, correttamente, il contenitore della lista.</div><div style="text-align: justify;">Successivamente @array viene assegnato a $scalar, ossia c'e' un assegnamento di lista in contesto scalare, e quindi si calcola la dimensione dell'array (3 appunto) e la si assegna a $scalar.</div><div style="text-align: justify;">Una volta compreso questo, il seguente assegnamento produce lo stesso effetto finale su $scalar per ovvi motivi:</div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$scalar = () = foo();</span><br /><br /><div style="text-align: justify;">E questo evidenzia come sia possibile mutare il comportamento delle funzioni forzando un contesto senza necessariamente passare per variabili temporanee.</div><div style="text-align: justify;">Ma per cortesia, non scriviamo codice del genere (si pensi alla sanita' mentale degli altri programmatori che si troveranno davanti questa espressione)!</div>