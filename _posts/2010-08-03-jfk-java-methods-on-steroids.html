---
layout: post
title: 'JFK: Java Methods on Steroids'
date: '2010-08-03T13:45:00.003+02:00'
author: Luca Ferrari
tags:
- jfk
- research
- java
modified_time: '2010-08-08T23:04:21.754+02:00'
thumbnail: http://1.bp.blogspot.com/_yhEX77VFKnM/TFfuz2qYWsI/AAAAAAAAAZo/G-tWcQmNdcA/s72-c/logo1.jpg
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-7245222221424589442
blogger_orig_url: http://fluca1978.blogspot.com/2010/08/jfk-java-methods-on-steroids.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<div style="text-align: right;"><span style="font-size: x-small;"><i>Warning: if you got here searching for some information about the <a href="http://en.wikipedia.org/wiki/Jfk">35th president of the United States of America</a>, you are in the wrong place! This post (and related ones) have nothing to do with politics or the above president, this is only Java!</i></span></div><div style="text-align: right;"><br /></div><div style="text-align: right;"><span style="font-size: x-small;"><i>Another warning: I have some strong opinions. You can disagree with me</i></span></div><div style="text-align: right;"><span style="font-size: x-small;"><i>as much as you want, but please keep in mind I'm open only</i></span></div><div style="text-align: right;"><span style="font-size: x-small;"><i>to constructive discussions.</i></span></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/_yhEX77VFKnM/TFfuz2qYWsI/AAAAAAAAAZo/G-tWcQmNdcA/s1600/logo1.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="261" src="http://1.bp.blogspot.com/_yhEX77VFKnM/TFfuz2qYWsI/AAAAAAAAAZo/G-tWcQmNdcA/s400/logo1.jpg" width="400" /></a></div><br /><br /><div style="text-align: justify;"><span style="font-size: large;"><b>JFK stands for Java Functional Kernel</b></span>, and it is a framework that brings <i>function</i> power to the Java World. Java does not use the term "function", preferring the term "method", but the two are, at least for what concerns JFK, the same. A function/method is a code block that you can call passing arguments on the stack and getting back a result.</div><div style="text-align: justify;">But while in Java first-class elements are <i>classes</i>, and therefore you cannot abstract a method outside a class, <b>JFK brings the power of function pointers</b> to Java, allowing you to use functions (or methods, if you prefer such term) as first-class entities too.</div><div style="text-align: justify;"><i>"Wait a minute, Java does not allow function pointers!"&nbsp;</i></div><div style="text-align: justify;">That is true, standard Java does not allow them, but JFK does.</div><div style="text-align: justify;"><i>"I don't need function pointers in Java, Java is a modern OOP language where function pointers are not useful and, besides, I think they are evil!" </i></div><div style="text-align: justify;">If this is what you are thinking, well, I will not call you <i>idiot</i> because I'm polite, but you probably should not read this; you should go back to your seat and continue typing on your keyboard some standard Java program.&nbsp;</div><div style="text-align: justify;"><i>"An OOP language cannot admit function pointers!"</i></div><div style="text-align: justify;">Ok, now I'm really thinking you are an idiot, so please move away. <b>Being OOP does not mean that function pointers are not allowed, but rather that they must be objects too.</b></div>Now if you think this can bring a new way of developing Java applications and can increase your expressiveness, keep reading.<br /><div style="text-align: justify;"><br /></div><div style="text-align: justify;">So what do you get with JFK?</div><div style="text-align: justify;">JFK enables you to exploit three main features:</div><ul><li><i>function pointers</i></li><li><i>closures</i></li><li><i>delegates (in a way similar to C#)</i></li></ul>At the time of writing JFK is at version 0.5, that is enough stable to run all the tests and the examples reported here. The project is not yet available as Open Source, but it will be very soon, probably under the GNU GPLv3 license. In the following I will detail everyone of the above features.<br />Please take into account that <b>JFK is not reflection</b>! Java already has something similar to a function pointer, that is the <i>Method</i> object of the reflection package, but JFK does not use it. In JFK everything is done directly, without reflection in order to speed up execution. <br /><br /><b><i><span style="font-size: large;">Function pointers</span></i></b><br />The first question is: why do I need function pointers? Do I really need an abstraction over methods/functions? Well, I think YES!<br />As well as <a href="http://www.osgi.org/Main/HomePage">OSGi</a> provides a mechanism to exports only some packages at run-time, function pointers provide the ability to export functions without having to export objects. To better understand, imagine the following situation: you've got an object (Service Object) that has two service methods, called M1 and M2. Now you've got two processes (whatever a process means to you) that must use only one of the methods, so imagine that the first process must use M1 and the second one M2. Being M1 and M2 defined in the same class, the only solution is to share the service object among the two processes, as shown in the following picture.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_yhEX77VFKnM/TFfMC3rhsbI/AAAAAAAAAZQ/72rKogdD9a8/s1600/FunctionPointers1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="181" src="http://2.bp.blogspot.com/_yhEX77VFKnM/TFfMC3rhsbI/AAAAAAAAAZQ/72rKogdD9a8/s400/FunctionPointers1.png" width="400" /></a></div><br /><div style="text-align: justify;">This solution is no modular at all, since both processes must keep a reference to a shared object. A better solution, without having to write a wrapper object for every method, is to create a set of <i>interfaces</i>, each one tied to a method. In this way the service object can implement every interface it must expose, and the processes can hold a reference to the interface (and therefore to the service object). The situation is shown in the following figure.</div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/_yhEX77VFKnM/TFfNLj-nU4I/AAAAAAAAAZY/gycB3vGaW7s/s1600/FunctionPointers2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="197" src="http://3.bp.blogspot.com/_yhEX77VFKnM/TFfNLj-nU4I/AAAAAAAAAZY/gycB3vGaW7s/s400/FunctionPointers2.png" width="400" /></a></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">This approach has several drawbacks:</div><ol style="text-align: justify;"><li>a new interface is needed to modularize every exposed method;</li><li>it is still possible to inspect, thru reflection, the reference and understand which object it is "hiding".</li></ol><div style="text-align: justify;">The (1) requires developers to write a lot of code, and this is what happens with normal event handlers, such as <i>ActionListener</i>: you have to declare a single-method interface for every method you want to expose. The (2) is a security hole: with reflection the reference holder can inspect the object and understand it has the method M2 and even call it.</div><div style="text-align: justify;">So, while very OOP, this approach has limitations that can be overtaken with the adoption of <i>function pointers</i>.</div><div style="text-align: justify;"><b>With function pointers it is possible to expose only pointers to a method M1 or to M2 without having to expose the object</b> (or its interfaces) to the consumer processes, as shown in the following picture.</div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_yhEX77VFKnM/TFfPLnHWdII/AAAAAAAAAZg/DErn6kngI7c/s1600/FunctionPointers3.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="197" src="http://2.bp.blogspot.com/_yhEX77VFKnM/TFfPLnHWdII/AAAAAAAAAZg/DErn6kngI7c/s400/FunctionPointers3.png" width="400" /></a></div><br /><div style="text-align: justify;">This is a very modular way of doing things: you don't have to worry about the service object, introspection against it, or even where the object is stored/held: you are passing away only the pointer to one of the functions and the receiver process will be able to exploit only the method/function behind such pointer.</div><div style="text-align: justify;"><i>"Ok, I can get this for free with java.lang.reflect.Method objects"</i></div><div style="text-align: justify;"><b>Again, this is not reflection! Reflection is slow. Reflection is limited. This is a direct method call thru a pointer object! And no, this is not a fancy use of proxies/interceptors! </b>Note that with reflection you are able to invoke only <i>local </i>methods, while with JFK you are free to call even remote functions without having to deal with RMI objects and stubs. At the moment this feature is not implemented yet, but it is possible. Please keep into account that, at the time of writing, JFK is still a proof of concept, so not all possible features have been implemented!</div><div style="text-align: justify;">Keeping an eye on security, JFK does not allow a program to get a function pointer to any method available in a class/object, <b>a method must be explicitly <i>exported</i></b>, that is when you define a class and its methods, you have to explicitly mark the methods you want to be able to be pointed. This allows you to define with a fine grain what services (as functions) each calss must export. Exporting a method is really simple, you have to mark it with the @Function annotation indicating the method name, that is an identifier that is used to refer to that specific method (it can be the same as the method name or something with a different meaning, like 'Service1'). Let's see an example:</div><br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">public class DummyClass {<br /><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; public final String resultString = "Hello JFK!";<br />&nbsp;&nbsp;&nbsp; <br /><br />&nbsp;&nbsp;&nbsp; public String aMethodThatReturnsAString(){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resultString;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; @Function( name = "double" )<br />&nbsp;&nbsp;&nbsp; public Double doubleValue( Double value ){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new Double( value.doubleValue() * 2 );<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; @Function( name = "string" )<br />&nbsp;&nbsp;&nbsp; public String composeString( Integer value ){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return resultString + value.intValue();<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; @Function( name = "string2" )<br />&nbsp;&nbsp;&nbsp; public String composeStringInteger(String s, Integer value ){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return s + value.toString();<br />&nbsp;&nbsp;&nbsp; }<br />}</span></div><br /><br /><br />The above class exports three instance methods, with different identifiers. For instance the method <i>composeStringInteger</i> is exposed with the identifier of 'string2'. This can be used from a program in the following way:<br /><br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;"><br /></span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp; // get a pointer to another function<br />&nbsp;&nbsp;&nbsp; // the "double" function returns a computation of a double&nbsp;</span></div><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; // passed on the stack (dummy is a DummyClass instance)</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; IFunction function = builder.bindFunction(dummy, "double" );</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; dummy = null;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // note that the dummy object is no more used!!!</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; Double d1 = new Double(10.5);</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; Double d2 = (Double) <b>function.executeCall</b>( new Object[]{ d1 } );</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; System.out.println("Computation of the double function returned " + d2);</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; // it prints</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; // Computation of the double function returned 21.0</span></span><br /><br /><br /><div style="text-align: justify;">As you can see, you can obtain a function pointer to an object method that is marked as 'double', and then executes the function with the <i>IFunction.executeCall(..)</i>. That's so easy!</div><div style="text-align: justify;">So to recap, you can get an <i>IFunction</i> object bound to a method identified by an exposing name, and you can execute the <i>executeCall</i> method on such <i>IFunction</i> in order to execute the function pointed. I stress it again: this is not reflection! <b>Moreover, IFunction is an interface without an implementation, that means there is nothing static here, all the code is dynamically generated at run-time.</b></div><div style="text-align: justify;">Being dynamic does not mean that there are not checks and constraints: before invoking the function, the system checks the arguments number, the argument type and so on and throws appropriate exceptions (e.g., <i>BadArityException</i>).&nbsp;</div><div style="text-align: justify;">Now, inspecting the stack trace of the <i>IFunction.executeCall(..)</i> you will never see a <i>Method.invoke(..)</i> or stuff like that (do you remember that this is not reflection?).&nbsp;</div><div style="text-align: justify;">Performances are really boosted with JFK when compared to reflection. For instance, the method call of the 'double' function requires around 12850 nanoseconds with JFK, while it requires 324133 nanoseconds using reflection (in particular 292914 ns to find the method and 31219 ns to invoke it). <b>So a simple method execution goes 25 times faster, and even more: since <i>IFunction</i> objects are cached, once they are bound to a function, the execution of the pointer is almost immediate!</b></div><div style="text-align: justify;"><br /></div><br /><br /><span style="font-size: large;"><b>Closures</b></span><br /><div style="text-align: justify;">Closures are pieces of anonymous code that can be executed as first-class entities. To say in simple words, closures are like Java methods that can be defined on the fly and that are not belonging to any special class.</div><div style="text-align: justify;">Java does not support closures, but something similar can be obtained with inner anonymous classes. Having function pointers, closures come almost for free, so that in you code you can do something like the following:</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;"><br /></span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp; <span style="font-size: x-small;">IClosureBuilder closureBuilder = JFK.getClosureBuilder();<br />&nbsp;&nbsp;&nbsp; IFunction closure = closureBuilder.buildClosure("public String&nbsp;</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; concat(String s,&nbsp; Integer i){ return s + i.intValue(); }");<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; // now use the closure, please note that there&nbsp;</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp; // is no object/class created here!<br />&nbsp;&nbsp;&nbsp; String closureResult = (String) closure.executeCall( new Object[]{&nbsp;</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Hello JFK!", new Integer(1234) } );<br />&nbsp;&nbsp;&nbsp; System.out.println("Closure result: " + closureResult);<br />&nbsp;&nbsp;&nbsp; // it prints<br />&nbsp;&nbsp;&nbsp; // Closure result: Hello JFK!1234</span></div><br /><div style="text-align: justify;">Closures are defined as <i>IClosure</i> objects, that are a special case of <i>IFunction</i> objects. While <i>IFunction</i> objects point to an exisisting method, <i>IClosure</i> objects point to a method that is still not existing and that is not exposed thru any class/object. Again, there is no reflection here, and there is no static implementation of <i>IClosure</i> available. Execution times are on the same order of IFunction ones, but closures are not cached in any way, since they are thought to be one-shot execution unit. I haven't inspected if my approach is the same as of
    <a href="https://web.archive.org/web/20110725183834/http:/groovy.codehaus.org/" target="_blank">Groovy closures</a>,
    I suspect there is something similar here.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><span style="font-size: large;"><b>Delegates</b></span></div><div style="text-align: justify;"><a href="http://msdn.microsoft.com/it-it/library/900fyy8e%28VS.80%29.aspx">Delegates</a> are something introduced by C# to allow an easy way to simulate function pointers for event handling. JFK provides a declaritive way of defining delegates and their association that is somewhat similar to the <a href="http://doc.trolltech.com/4.6/signalsandslots.html">signal-slot mechanism of Qt</a>. First of all a little of terminology:</div><ul><li>a delegate is the implementation of a behaviour (this is similar to a <i>slot</i> in the Qt terminology)</li><li>a delegatable is an object and/or a method that can be bound to a delegate, so to a concret implementation (this is similar to a <i>signal</i> in the Qt terminology)</li></ul>So for instance, with the well known example of the <i>ActionEvent</i> it is possible to say that the method <i>actionPerformed(..)</i> is a delegatable, while the implementation of the <i>actionPerformed(..)</i> is the delegate. <br /><div style="text-align: justify;">The idea that leads JFK delegates has been the following:</div><ol style="text-align: justify;"><li>delegatable methods could be abstract (the implementation does not matter when the delegate is declared)</li><li>adding and removing a delegate instance should be dynamic and should not burden the delegatable instance</li></ol><div style="text-align: justify;">Let's see each point with an event based example; consider the following event generator class:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">public abstract class EventGenerator implements IDelegatable{<br /><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; public void doEvent(){<br />&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; 10; i++ )<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this.notifyEvent( "Event " + i );<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; @Delegate( name="event", allowMultiple = true )<br />&nbsp;&nbsp;&nbsp; public abstract void notifyEvent(String event);<br />&nbsp;&nbsp;&nbsp; <br />}</span><br /><br /><br /><div style="text-align: justify;">The above <i>EventGenerator</i> class is a skeleton for an event provider, such as a button, a text field, or something else. The idea is when the <i>doEvent()</i> method is executed an event is dispatched thru the <i>notifyEvent(..)</i> method. As you can see the (1) states that the <i>notifyEvent(..)</i> method can be abstract, as it is in this example. The idea is that, since the <i>notifyEvent(..)</i> should have the implementation done by someone else (the event consumer), its implementation does not matter here. Letting the delegatable method abstract means that you cannot instantiate the object <i>EventGenerator</i> without having bound it to a method implementation. If you need to be able to instantiate it, you can provide a body method (even empty) keeping in mind that it will be replaced by a connection with the delegate that must execute the method. The delegatable method must be annotated with the <i>@Delegate</i> annotation, where you can specify a name (that is similar in aim to the function name) and a flag that states if the delegatable can be connected to multiple delegates. And here comes the (2): note how the delegatable method is called once. Even when multiple delegates are connected to the delegatable the JFK kernel takes care of the execution of all the delegates. In standard Java you have to write:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">public void doEvent(){<br />&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; 10; i++ )</span></div><div style="text-align: justify;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( MyEventListener l : this.listeners )<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l.notifyEvent( "Event " + i );<br />&nbsp;&nbsp;&nbsp; }</span></div><br /><br /><div style="text-align: justify;">having <i>listeners</i> and <i>MyEventListener</i> respectively a list of listeners and the interface associated to the listener. Can you see the extra loop to notify all the listeners? <b>It means that the producer has to keep track of all the consumer, and this is wrong! It strictly couples the consumer to all the producers, and this is an awkward implementation.</b> In fact, I think that the event mechanism as implemented by standard Java is not an uncoupling mechanism, and this is why I tend to prefer AspectJ/AOP event notifications (<a href="http://whitecat.git.sourceforge.net/git/gitweb.cgi?p=whitecat/whitecat;a=blob;f=src/whitecat/core/ProxyStorageAspect.aj;h=17c280d027ff17b8bafb402c7ec196cf446f76b6;hb=HEAD">as implemented in WhiteCat</a>). Again, there is no reflection here, and the kernel is not keeping track of all the consumers, rather it manages a set of function pointers to consumers. It's that easy!</div><div style="text-align: justify;">Now let's see how you can use the delegates; first you have to implement a behaviour for the delegate, assume we have the following two:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">public class EventConsumer implements IDelegate{</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; @Connect( name="event" )</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void consumeEvent(String event){</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; System.out.println("\n\t********** Cosuming event "&nbsp;</span></span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace; text-align: justify;"><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + event + "\n\n\n");<br />&nbsp;&nbsp;&nbsp; }<br />}</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace; text-align: justify;"><span style="font-size: x-small;"><br /></span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace; text-align: justify;"><span style="font-size: x-small;"><br /></span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace; text-align: justify;"><span style="font-size: x-small;"><br /></span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace; text-align: justify;"><span style="font-size: x-small;">public class EventConsumer2 implements IDelegate {<br /><br />&nbsp;&nbsp;&nbsp; @Connect( name="event" )<br />&nbsp;&nbsp;&nbsp; public void consumeEvent2( String e ){<br />&nbsp;&nbsp;&nbsp; System.out.println("\n\t**********&gt;&gt;&gt;&gt;&gt;&gt;&gt;&nbsp;</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace; text-align: justify;"><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cosuming event " + e + "\n\n\n");<br />&nbsp;&nbsp;&nbsp; }<br />}</span></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Both the event consumer have a method with the same signature of the delegatable one; the JFK kernel checks before binding methods that the signature are compatible. Both methods are annotated with the <i>@Connect</i> annotation that specifies the same name of the delegatable to which connect to. Now you can write a program that does the following:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace; text-align: left;"><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp; IDelegateManager manager = JFK.getDelegateManager();<br />&nbsp;&nbsp;&nbsp; IDelegatable consumer = (IDelegatable) manager.createAndBind(&nbsp;&nbsp;</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace; text-align: left;"><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EventGenerator.class, new EventConsumer() );<br />&nbsp;&nbsp;&nbsp; // now the delegate will invoke the abstract method,&nbsp;</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace; text-align: left;"><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp; // that has been defined at run-time to match the<br />&nbsp;&nbsp;&nbsp; // consumer method in the EventConsumer object<br />&nbsp;&nbsp;&nbsp; ((EventGenerator) consumer).doEvent();<br />&nbsp;&nbsp;&nbsp; // it prints<br />&nbsp;&nbsp;&nbsp; // ********** Cosuming event Event 0<br />&nbsp;&nbsp;&nbsp; // ....<br />&nbsp;&nbsp;&nbsp; // ********** Cosuming event Event 9&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; // now it is possible to add another consumer to the event generator,&nbsp;</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace; text-align: left;"><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp; // since it allows a multiple<br />&nbsp;&nbsp;&nbsp; // connection. To do this, we can add another delegate to the instance<br />&nbsp;&nbsp;&nbsp; manager.addDelegate(consumer, new EventConsumer2() );<br />&nbsp;&nbsp;&nbsp; // now the delegate will invoke the abstract method,&nbsp;</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace; text-align: left;"><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp; // that has been defined at run-time to match the<br />&nbsp;&nbsp;&nbsp; // consumer method in the EventConsumer object<br />&nbsp;&nbsp;&nbsp; ((EventGenerator) consumer).doEvent();</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace; text-align: left;"><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp; // it prints</span> </div><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; // ********** Cosuming event Event 0&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;- from EventConsumer</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; // **********&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cosuming event Event 0&nbsp;&nbsp;&nbsp;&nbsp; &lt;- from EventConsumer2</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"> &nbsp;&nbsp;&nbsp; // ....</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"> &nbsp;&nbsp;&nbsp; // ********** Cosuming event Event 9&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;- from EventConsumer</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"> &nbsp;&nbsp;&nbsp; // **********&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cosuming event Event 9&nbsp;&nbsp;&nbsp;&nbsp; &lt;- from EventConsumer2</span></span><br /><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">First of all you need a <i>delegate manager</i> to which you ask to instantiate an <i>EventGenerator</i> object (you cannot instantiate it directly in this example because it has abstract methods) binding it to an <i>EventConsumer</i> instance. This produces a new instance of <i>EventGenerator </i>that will call and execute <i>EventConsumer.consumeEvent(..)</i> each time <i>EventGenerator.notifyEvent(..)</i> is called. In the following, you can dynamically add (and remove) other delegates to the running instance of <i>EventGenerator</i> so that all the associated delegates will be executed when the <i>EventGenerator.notifyEvent(..)</i> method is called. <b>I stress it again: note that the event generator do not deal with all the possible event consumers, the JFK kernel does it! And again, there is no reflection involved here, everything happens as a direct method call!</b><br />The following picture illustrates how you can imagine the delegate works in JFK:<br /><b> </b><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_yhEX77VFKnM/TFgUar7hfRI/AAAAAAAAAZw/OsmXcGdEtl8/s1600/delegate.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="260" src="http://2.bp.blogspot.com/_yhEX77VFKnM/TFgUar7hfRI/AAAAAAAAAZw/OsmXcGdEtl8/s400/delegate.png" width="400" /></a></div><b> </b><br /><span style="font-size: large;"><b> What else can I do with JFK?</b></span><br />Well, JFK is a functional kernel, so you can do whatever you do with functions. For instance <b>you can pass a function pointer to another method/function, enabling functional programming!</b><br /><b> </b><br /><b> </b></div><div style="text-align: justify;"></div><div style="text-align: justify;"><span style="font-size: large;"><b> A final note on reflection</b></span></div><div style="text-align: justify;">In this article I wrote several times that JFK does not uses reflection. This is not true at all. As you probably noted the current implementation is based on annotations, and this means that in order to get annotations and their values, JFK needs reflection. The thing that must be clear is that method execution thru function pointers does not use reflection at all!</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><span style="font-size: large;"><b>(Some) Implementation Details</b></span></div><div style="text-align: justify;">I'm not going to show all the internals, for now it suffice to know that this project is developed in standard Java (J2SE6) and, strangely, it is still not an <a href="http://www.eclipse.org/aspectj/">AspectJ</a> project as I do for almost every project I run. All the configuration of the run-time system is done using <a href="http://www.springsource.org/">Spring</a>, and there is a suite test (<a href="http://www.junit.org/">Junit 4)</a> that stress the system and its functionality.</div><br /><span style="font-size: large;"><b>Need more info?</b></span><br /><div style="text-align: justify;">Well, at the moment this is a private research project of mines, so I cannot show you all the details because they are still changing (but the API is stable). I've created <a href="http://osum.sun.com/group/javafunctionalkerneljfk">a page on the Open Source University Meetup</a> where discussions can happen, beside my blog. If you need more info, or want to collaborate at the project, feel free to contact me.</div>


    <h2>2020-10 Update</h2>
    Thanks to <i>Rachel Cook</i> who reminded me about the <a href="https://projectmanagernews.com/general/most-important-projects-codehaus/" target="_blank" >destiny of CodeHaus</a> allowing me to fix a broken link.
