---
layout: post
title: Programmazione ad oggetti
date: '2008-02-10T12:11:00.000+01:00'
author: Luca Ferrari
tags:
- università
- programmazione
modified_time: '2008-09-08T13:51:18.639+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-5835186639625572815
blogger_orig_url: http://fluca1978.blogspot.com/2008/02/programmazione-ad-oggetti.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


La programmazione ad oggetti (<a href="http://en.wikipedia.org/wiki/Object_oriented_programming">OOP = Object Oriented Programming</a>) rappresenta un paradigma di programmazione molto potente, e uno di quelli maggiormente affermati negli ultimi anni.<br /><br />La programmazione ad oggetti si basa fondamentalmente su tre principi:<br /><ol><li><span style="font-weight: bold;">incapsulamento</span>: è la capacità di <span style="font-style: italic;">nascondere</span> all'esterno dati e servizi, inglobandoli in un <span style="font-style: italic;">modulo</span> che risulti inviolabile dall'esterno.<br /></li><li><span style="font-weight: bold;">ereditarietà</span>: è la capacità di estendere un modulo aggiungendo o modificando alcuni dei suoi servizi.</li><li><span style="font-weight: bold;">polimorfismo</span>: è la capacità di variare il comportamento di un modulo a seconda di come viene acceduto.</li></ol>L'idea attorno al quale ruota l'OOP è il concetto di <span style="font-style: italic;">classe</span>, un'astrazione di dato con annessi relativi servizi. La classe supporta i tre principi dell'OOP sopra descritti, e infatti:<br /><ol><li>può nascondere i dettagli implementativi dei propri dati all'esterno (incapsulamento).</li><li>può essere estesa da una classe figlia, che implementi ulteriori servizi (ereditarietà).</li><li>può venire acceduta con ciascuna interfaccia appartenente ad una delle sue superclassi, ma il suo comportamento dipenderà dalla sua implementazione concreta (polimorfismo).</li></ol>E' importante notare come, grazie all'ereditarietà, <span style="font-style: italic;">il codice nuovo possa usare il codice vecchio</span>. Ma grazie al polimorfismo si ha che <span style="font-style: italic;"><span style="font-style: italic;"><span style="font-style: italic;"><span style="font-style: italic;">il codice vecchio utilizza quello nuovo. </span></span></span></span>Nel primo caso (ereditarietà) si ha che da una implementazione "vecchia" se ne può ottenere una nuova definendo (o ridefinendo) solo i servizi necessari (e quindi utilizzando i rimanenti servizi vecchi). Nel secondo caso (polimorfismo) si ha che il codice "vecchio" che accede tramite un'interfaccia di una superclasse ad una implementazione nuova, sfrutta la nuova implementazione senza rendersene conto.<br /><br />Per meglio chiarire, si consideri il seguente esempio:<br /><br /><code><br /><span style=";font-family:arial;font-size:85%;"  >public class Automobile{<br />  // incapsulamento: la velocità e' nascosta all'esterno e può essere<br />  // acceduta solo tramite opportuni servizi<br />  protected int speed = 0;<br /><br />  // servizio pubblico per variare la velocita', si noti che il chiamante<br />  // non conosce nessun dettaglio implementativo circa la velocita'<br />  public void accelera(){ this.speed++; }<br />}<br /></span></code><br /><br /><code><br /><span style=";font-family:arial;font-size:85%;"  >public class AutomobileSportiva extends Automobile {<br /><br /></span><span style=";font-family:arial;font-size:85%;"  >      // l'automobile sportiva utilizza come base Automobile<br /><br /></span><span style="font-size:85%;"> </span><span style=";font-family:arial;font-size:85%;"  >     // Un'auto sportiva ha una accelerazione forte. Si noti che si ridefinisce<br /></span><span style=";font-family:arial;font-size:85%;"  >     // un servizio che si basa sulle proprieta' del codice vecchio, ossia la variabile<br /></span><span style=";font-family:arial;font-size:85%;"  >     // speed.<br /><br /></span><span style=";font-family:arial;font-size:85%;"  >     public void accelera(){<br /></span><span style=";font-family:arial;font-size:85%;"  >  for(int i=0; i<4;><span style=";font-family:arial;font-size:85%;"  >          <br /> this.accelera();<br /></span><span style=";font-family:arial;font-size:85%;"  > }<br /><br /></span><span style=";font-family:arial;font-size:85%;"  ><span style="font-family:courier new;">}</span><br /></span><br /></span></code><br /><br />Si supponga che in un programma ci sia un metodo che utilizza l'automobile:<br /><br /><code><br /><span style="font-size:85%;"><span style="font-family:arial;">public void corri(Automobile auto){  auto.accelera(); }</span></span><br /></code><br /><br />Ora, è evidente che se a questo metodo viene passata un'istanza di AutomobileSportiva, il codice in questione (vecchio) utilizza il nuovo comportamento (polimorfismo). Ecco quindi che senza alterare il codice vecchio si è inserito un comportamento nuovo, e quindi <span style="font-style: italic;">il codice vecchio usa il codice nuovo</span>. Similarmente, AutomobileSportiva rappresenta <span style="font-style: italic;">codice nuovo che utilizza quello vecchio:</span> il suo metodo accelera() richiama il codice vecchio della superclasse.<br /><br />Da notare come il comportamento ottenuto dipenda dal tipo run-time effettivo, ossia il polimorfismo mostra sempre l'ultimo comportamento definito nel tipo run-time fra quelli disponibili a partire dal tipo statico.<br /><br />Si noti che il polimorfismo da solo non basta: è indispensabile disporre anche del <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle"><span style="font-style: italic;">principio di sostituzione di Liskov</span></a>, che consente di utilizzare l'interfaccia di una superclasse per riferirsi ad una sottoclasse.