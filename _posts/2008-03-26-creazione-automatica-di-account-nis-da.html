---
layout: post
title: Creazione automatica di account NIS da un file CSV
date: '2008-03-26T13:39:00.001+01:00'
author: Luca Ferrari
tags:
- linux
- perl
modified_time: '2008-03-26T13:53:11.217+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-1916482822229653212
blogger_orig_url: http://fluca1978.blogspot.com/2008/03/creazione-automatica-di-account-nis-da.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


Quello presentato di seguito è uno script Perl utilizzato per la generazione automatica di account per gli studenti su un sistema Linux+NIS. L'idea è quella di partire da un file CSV contentente diverse informazioni (nome utente, nome account, informazioni circa l'anno di studio, ecc.).<br /><br />L'idea alla base dello script è quella di costruire una collezione di hash, uno per ogni utente letto dal file CSV, nel quale vengono memorizzate le informazioni realmente necessarie alla creazione del relativo account (come ad esempio username, password, shell, etc.). Il file viene letto una riga alla volta dalla funzione <span style="font-style: italic;">parseFile</span>, la quale passa il controllo a <span style="font-style: italic;">parseLine</span> che costruisce l'hash dai valori di una singola linea; l'hash viene poi aggiunto ad un array che contiene la lista di tutti gli hash estratti dal file sorgente. Durante la creazione di un hash utente viene anche generata una password casuale (funzione <span style="font-style: italic;">generatePassword</span>), che verrà poi salvata in chiaro in un file di log.<br /><br />Una volta ottenuti tutti gli hash per tutti gli utenti, si passa il controllo alla funzione <span style="font-style: italic;">addUser</span> che si occupa di lanciare i comandi Unix per la creazione e il setup dell'account utente sulla macchina locale. Si noti che è possibile creare più directory home per ogni utente, come specificato nell'array <span style="font-style: italic;">@homeDirs; </span>questo nel caso serva esportare (tramite NFS) diversi file system a seconda di differenti architetture client.<br /><br />Una volta terminato il ciclo di aggiunta di ogni utente, vengono lanciati i comandi per la ripopolazione del NIS e l'aggiornamento dei client collegati al server stesso.<br /><pre>#!/usr/bin/perl<br /><br /><br /><br /># esempio di una riga del file di account<br />#Luca;Ferrari;20202;599;II;luca.ferrari37094@unimo.it;37094;si;0;37094;U4L5R;;;;;;;;;Sì;C;Windows<br /><br /><br /><br /># * Copyright (C) Luca Ferrari 2003-2008<br /># *<br /># *  This program is free software: you can redistribute it and/or modify<br /># *  it under the terms of the GNU General Public License as published by<br /># *  the Free Software Foundation, either version 3 of the License, or<br /># *  (at your option) any later version.<br /># *<br /># *  This program is distributed in the hope that it will be useful,<br />#    *  but WITHOUT ANY WARRANTY; without even the implied warranty of<br /># *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br /># *  GNU General Public License for more details.<br /># *<br /># *  You should have received a copy of the GNU General Public License<br /># *  along with this program.  If not, see <http://www.gnu.org/licenses/>.<br /><br /><br /><br /><br /><br /># se definito questo flag lo script non esegue i comandi, li simula solo<br />$DEBUG_MODE="true";<br /><br /><br /># separatore di campo nel file degli account<br />$FIELD_SEPARATOR=';';          <br /># il carattere da anteporre ad ogni username ricavato dal file<br />$USERNAME_START="n";   <br /># gruppo di default<br />$DEFAULT_GROUP="users";<br /># lunghezza di default delle eventuali password generate automaticamente<br />$DEFAULT_PASSWORD_LENGTH=8;<br /><br /><br /># array con le home da creare per ogni utente<br />@homeDirs = ("/export/Linux-i686/home/",<br />      "/export/Linux-sparc64/home/",<br />      "/export/SunOS-sun4u/home/",<br />      "/export/SunOS5.8-sun4u/home/",<br />      "/export/shared/home/",<br />      );<br /><br /><br /># indicatori dei vari campi (loro posizioni) nel file di account<br />$ACCOUNT_POSITION=6;<br />$PASSWORD_POSITION=10;     # impostare ad un valore negativo per avere la generazione automatica delle password<br />$NAME_POSITION=1;<br />$SURNAME_POSITION=0;<br />$OTHER_INFO_POSITION=5;<br /><br /><br /># chiavi di ongi singolo hash di informazioni<br />$USERNAME_KEY='username';<br />$PASSWOD_KEY='password';<br />$INFO_KEY='info';<br />$CYPHERED_PASSWORD_KEY='password_cifrata';<br />$GROUP_KEY='gruppo';<br /><br /><br /><br /># file di log<br />$_REPORT = "accounts.log.txt";<br /><br /><br /><br /># Funzione per fare il log di una stringa<br />sub history($)<br />{<br />   my ($_stringa) = @_;<br /><br />   # se il log non e' inizializzato lo apro ora<br />   if( not defined($__log__) ){<br /> open(LF,">$_REPORT") || die("\nNon posso aprire il file di log $_REPORT:\n$!\n\n");<br /> $__log__="true";<br />   }<br /><br />   print LF $_stringa,"\n";<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /># Funzione per fare il parsing di tutto il file<br /># La funzione accetta il nome del file di cui fare il parsing e ritorna<br /># un vettore con dei riferimenti ad ogni hash di account.<br />sub parseFile<br />{<br />   # prelevo i parametri<br />   my ($_file) = @_;<br />   my $_success=0;<br />   my $currentHash;<br />   my @accounts;<br /><br />   if( not defined($_file) || length($_file)==0 || $_file eq "" ){<br /> return undef();<br />   }<br /><br />   # apertura del file in lettura<br />   open(FILE,"<".$_file) || die("\nNon riesco ad aprire $_file:\n$!");<br /><br />   # leggo ogni riga e la passo alla funzione di parsing<br />   while( $line = <file> ){<br /> <br /> $currentHash = parseLine($line);<br /><br /> # inserisco l'account nell'array di account<br /> if( defined($currentHash) ){<br />     $accounts[++$#accounts] = $currentHash;<br />     undef($currentHash);<br /> }<br />   }<br /><br /><br />   return @accounts;<br /><br />}<br /><br /><br /><br /><br /><br /><br /># Funzione per fare il parse di una singola linea di un file di account.<br /># Argoemnti: la linea di input.<br /># La funzione restituisce un riferimento ad un hash con i dati dell'account.<br />sub parseLine($)<br />{<br />   # prelevo i parametri<br />   my ($_line) = @_;<br /><br />   # controllo<br />   if( not defined($_line) || length($_line) == 0 || $_line eq "" ){<br /> return undef();<br />   }<br /><br />   # faccio il parsing della linea<br />   my @_parts = split(/$FIELD_SEPARATOR/,$_line);<br /><br /><br />   if( not defined(@_parts) || $#_parts<0 ){<br /> return undef();<br />   }<br /><br />   # creo l'hash<br />   my $_hash = {<br /> $USERNAME_KEY => $USERNAME_START.$_parts[$ACCOUNT_POSITION],<br /> $PASSWORD_KEY => $_parts[$PASSWORD_POSITION],<br /> $INFO_KEY     => "$_parts[$SURNAME_POSITION] $_parts[$NAME_POSITION] - $_parts[$OTHER_INFO_POSITION]",<br />   };<br /><br /><br />   # ATTENZIONE: se la password e' nulla oppure non e' definito il campo PASSWORD_POSITION genero io una<br />   # password.<br />   if( (not defined($PASSWORD_POSITION)) || $PASSWORD_POSITION<0>{$PASSWORD_KEY}) ||<br /> length($_hash->{$PASSWORD_KEY}) == 0 || $_hash->{$PASSWORD_KEY} eq "" ){<br /> my $_psw = generatePassword($DEFAULT_PASSWORD_LENGTH);<br /> $_hash->{$PASSWORD_KEY} = $_psw;<br />   }<br /><br /><br />   # Pulisco ogni campo da spazi bianchi all'inizio e alla fine.<br />   foreach $_i ( keys(%$_hash) ){<br /> $_tmp = $_hash->{$_i};<br /> $_tmp =~ s/^\s+|\s+$//g; <br /> $_tmp =~ s/\'//g;<br /> $_hash->{$_i} = $_tmp;<br />   }<br /><br /><br />   # restituisco l'hash (il suo riferimento)<br />   return $_hash;<br />}<br /><br /><br /><br /><br /><br /><br /><br /># FUnzione per generare una password.<br /># La funzione si appoggia a rand e map per generare una password totalmente casuale.<br />sub generatePassword($)<br />{<br />   my ($_size) = @_;<br />   my $_password;<br />   # lista dei caratteri validi nelle password<br />   my @chars = ('a'..'z','A'..'Z',0..9,'_','+','-','(',')' );<br />  <br />   for($_i=0;$_i<=$_size;$_i++){<br /> $_password .= join('',$chars[rand($#chars)]);<br />   }<br />  <br />   return $_password;<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /># Funzione di debug per stampare il contenuto di uno degli hash utente<br />sub dumphash($)<br />{<br />   my ($h) = @_;<br /><br />   print "Hash costuito:\n";<br />   print $h->{$USERNAME_KEY},"<",length($h->{$USERNAME_KEY}),"> - ",$h->{$PASSWORD_KEY}," - ",$h->{$INFO_KEY};<br />   print " - ",$h->{$CYPHERED_PASSWORD_KEY};<br />   print "\n----------------------------------------------\n";<br />}<br /><br /><br /><br /><br /># Funzione per aggiungere un singolo utente dato il suo hash di account.<br /># La funzione ritorna undef in caso di errore.<br />sub addUser($)<br />{<br />   my ($hash) = @_;<br /><br />   if( not defined($hash) || not defined($hash->{$USERNAME_KEY}) || not defined($hash->{$PASSWORD_KEY}) ){<br /> return undef();<br />   }<br /><br />   # devo ottenere la password cifrata<br />   my $cyphered = crypt($hash->{$PASSWORD_KEY},1);<br />   $hash->{$CYPHERED_PASSWORD_KEY} = $cyphered;<br /><br /><br />   # primo passo: invocazione di useradd<br />   # ATTENZIONE: se non e' definito un gruppo uso quello di default<br />   if( not defined($has->{$GROUP_KEY}) ){ $hash->{$GROUP_KEY} = $DEFAULT_GROUP; }<br />   $useradd  = " useradd -g ".$hash->{$GROUP_KEY}. " -s /bin/bash -p ". $hash->{$CYPHERED_PASSWORD_KEY}. " ";<br />   $useradd .= " -c \"".$hash->{$INFO_KEY}."\" ".$hash->{$USERNAME_KEY}." ";<br /><br />   # secondo passo: creazione delle home<br />   $createhome="";<br /><br />   foreach $__home (@homeDirs){<br /> if( not -d $__home ){<br />     if( mkdir($__home) ){<br />  history("Creata directory $__home");<br />     }<br /> }<br /> $currentHome = $__home;<br /> $currentHome .= $hash->{$USERNAME_KEY};<br /><br /> $createhome .= " mkdir $currentHome; ";<br /> if( defined($hash->{$GROUP_KEY}) ){<br />     $createhome .= " chown ".$hash->{$USERNAME_KEY}.".".$hash->{$GROUP_KEY}." $currentHome; ";<br /> }else{<br />     $createhome .= " chown ".$hash->{$USERNAME_KEY}." $currentHome; ";<br /> }<br /> $createhome .= " chmod 755 $currentHome; ";<br />   }<br /><br /><br />  <br /><br />  <br /><br />   # log dei comandi<br />   history("-------------- UTENTE ".$hash->{$USERNAME_KEY}."----------------------------");<br />   history("password in chiaro => ".$hash->{$PASSWORD_KEY});<br />   history($useradd);<br />   history($createhome);<br />   history("------------------------------------------------------------");<br /><br /><br />   # esecuzione dei comandi<br />   if(defined($DEBUG_MODE) ){ return "true"; }<br />   return (`$useradd` &amp;&amp; `$createhome`);<br />}<br /><br /><br /># Funzione per la ricostruzione della mappa del nis.<br />sub reNIS<br />{<br />   my $nis  = "cd /var/yp; ";<br />   $nis    .= "make";<br /><br />   history(">>>>>>>>>>>>>>>>>>>> RICOSTRUZIONE DEL NIS <<<<<<<<<<<<<<<<<<<<<<<");<br />   history($nis);<br /><br />   if(defined($DEBUG_MODE) ){ return "true"; }<br />   return `$nis`;<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />#############################################################<br />#############################################################<br />#############################################################<br />#############################################################<br />#############################################################<br /><br /># controllo parametri<br />if($#ARGV<0){<br />   print "Utilizzo:\n";<br />   print "$0 <file_account>\n";<br />   print "oppure:\n";<br />   print "$0 username password_in_chiaro gruppo info";<br />   exit(1);<br />}<br />else{<br /><br />   print "\nEsecuzione di $0....log impostato su $_REPORT\n";<br /><br /><br />   if($#ARGV==0){<br /> # un solo parametro: deve essere il file degli account<br /> $ACCOUNT_FILE=$ARGV[0];<br /> chomp($ACCOUNT_FILE);<br /> <br /> # faccio il parsing del file<br /> print "\nparsing del file di account $ACCOUNT_FILE...";<br /> if( @acc = parseFile($ACCOUNT_FILE) ){<br />     print "\nRilevati $#acc account da inserire, procedo...";<br /><br />     foreach $u (@acc){<br />  # $u => riferimento all'hash dell'account<br />  print "\nAggiunta dell'utente <",$u->{$USERNAME_KEY},">, [",$u->{$INFO_KEY} ,"]....";<br />  if( addUser($u) ){<br />      print "fatto!";<br />  }<br />  else{<br />      print "NON riuscito!\n";<br />  }<br />     }<br /> <br /> }<br />   }<br />   elsif($#ARGV==3){<br /> # inserimento di un solo account<br /> $_usr = $ARGV[0];<br /> chomp($_usr);<br /> $_pwd = $ARGV[1];<br /> chomp($_pwd);<br /> $_grp = $ARGV[2];<br /> chomp($_grp);<br /> $_info = $ARGV[3];<br /> chomp($_info);<br /> <br /> $_crypt = crypt($_pwd,1);<br /> <br /> $singleAccount = {<br />     $USERNAME_KEY => $_usr,<br />     $PASSWORD_KEY => $_pwd,<br />     $GROUP_KEY    => $_grp,<br />     $INFO_KEY     => $_info,<br />     $CYPHERED_KEY => $_crypt,<br /> };<br /><br /> # aggiungo l'utente<br /> print "\nAggiunta dell'utente <",$singleAccount->{$USERNAME_KEY},">...\n";<br /> if( addUser($singleAccount) ){<br />     print "fatto!";<br /> }<br /> else{<br />     print "NON riuscito";<br /> }<br />   }<br /><br /><br />   # ora che ho aggiunto gli utenti ripopolo il nis<br />   print "\n\nRipopolazione del NIS...";<br />   reNIS();<br />   print "fatto\n\n";<br />  <br />}<br /></pre>