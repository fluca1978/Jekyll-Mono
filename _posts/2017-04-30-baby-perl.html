---
layout: post
title: Baby-Perl
date: '2017-04-30T11:35:00.000+02:00'
author: Luca Ferrari
tags:
- perl
modified_time: '2017-04-30T11:35:10.580+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-6403962805096373634
blogger_orig_url: http://fluca1978.blogspot.com/2017/04/baby-perl.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<div style="text-align: justify;">Ecco un altro esempio, questa volta in italiano, di uso <i>infantile</i> di Perl e in generale scorretto della formattazione di stringhe.<br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">L'idea è semplice: occorre stampare in un file a formato fisso delle linee di valori. Si noti bene che il <i>formato fisso</i> si presta bene all'uso della <code>printf</code>, e sicuramente all'uso dei <i>formati Perl</i>, anche se con campi molto lunghi questi diventano scomodi e francamente poco leggibili.<br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ma l'ignoranza e l'inesperienza facevano da padroni nei primi anni della programmazione, così seguendo il fantastico principio del <i>reinventare la ruota</i> ecco che si implementava una sorta di sprintf del poveraccio:<br /></div><br /><div class="org-src-container"><br /><pre class="src src-perl">my $INIZIO_CAMPO = "|";<br />my $FINE_CAMPO   = "|";<br /><br />sub formatta($$$){<br />    my ($stringa, $lunghezza, $fineRiga) = @_;<br /><br />    $stringa =~ s/,/./g;<br /><br />    if( length($stringa) &gt; $lunghezza ){<br /> $stringa = substr($stringa, 0, $lunghezza);<br />    }<br /><br /><br />    if( $fineRiga != 1 ){<br /> return $INIZIO_CAMPO . $stringa . $FINE_CAMPO . $SEPARATORE_CAMPO;<br />    } else {<br /> return $INIZIO_CAMPO . $stringa . $FINE_CAMPO . $FINE_LINEA;<br />    }<br /><br /><br />}<br /></pre></div><br /><div style="text-align: justify;">Piuttosto elementare:<br /></div><ol class="org-ol" style="text-align: justify;"><li>si sostituisce il carattere , con il <code>.</code>, e questo ha poco a che fare con la stampa stessa;<br /></li><li>se la stringa di partenza <code>$stringa</code> supera la lunghezza del campo (specificata in <code>$lunghezza</code>)<br />si tronca la stringa (mentre non c'è un padding qualora la stringa sia piu' corta);<br /></li><li>si concatena la stringa con i delimitatori di campo e si aggiunge, eventualmente, un carattere di<br />fine linea.<br /></li></ol><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Come si potrebbe fare una versione compatta? O meglio, come affronterei il problema oggi?<br />Beh, come già detto, <code>printf(3p)</code> è la salvezza:<br /></div><br /><div class="org-src-container"><br /><pre class="src src-perl">sub formatta{<br />    my ( $stringa, $lunghezza, $fine_riga ) = @_;<br /><br />    my $format_string = sprintf "%%s%%%ds%%s%%s", $lunghezza;<br />    return sprintf $format_string, $INIZIO_CAMPO, $stringa, $FINE_CAMPO, ( $fine_riga ? "\n" : "" );<br />}<br /></pre></div><br /><div style="text-align: justify;">L'unica complicazione evidente è la gestione della lunghezza della stringa, che deve essere specificata nella stringa di formato.<br />Si supponga di chiamare la funzione <code>formatta</code> come segue:<br /></div><br /><code>say formatta 'foo', 5, 1;</code><br /><br /><br /><div style="text-align: justify;">Ora quello che succede è che:<br /></div><ol class="org-ol" style="text-align: justify;"><li><code>$format_string</code> viene valorizzato come <code>%s%5s%s%s</code> ovvero <code>sprintf "%%s%%%ds%%s%%s", $lunghezza;</code> converte la stringa passata<br />come argomento<br /><ul class="org-ul"><li><code>%%s</code> viene convertito come <code>%s</code>, il primo è il separatore di inizio campo, il penultimo di fine campo, l'ultimo è l'evetuale<br />fine riga;<br /></li><li><code>%%%ds</code> viene convertito in <code>%$lunghezzas</code> ovvero <code>%5s</code>;<br /></li></ul></li><li>la stringa composta in <code>$format_string</code> è ancora una stringa valida per la <code>printf</code>, che quindi viene riempita con<br />i valori appositi.<br /></li></ol><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Sicuramente questa versione è piu' compatta e piu' manutenibile, a patto di leggere correttamente il formato della <code>pritnf</code> e il "doppio formato"<br />costruito nel primo passaggio (es. <code>%%s</code>).<br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">E' anche possibile <i>compattare</i> ancora di piu' cecando di evitare i doppi passaggi, o meglio di limitarli al massimo:<br /></div><br /><div class="org-src-container"><br /><pre class="src src-perl">sub formatta{<br />    my ( $stringa, $lunghezza, $fine_riga ) = @_;<br /><br />    my $format_string = sprintf "%1s%%%ds%1s%%1s", $INIZIO_CAMPO, $lunghezza, $FINE_CAMPO;<br />    return sprintf $format_string,  $stringa, ( $fine_riga ? "\n" : "" );<br />}<br /></pre></div><br /><div style="text-align: justify;">Il concetto rimane il medesimo, ma la <code>$format_string</code> in uscita dalla prima invocazione di <code>sprintf</code> vale qualcosa come <code>|%5s|%1s</code><br />e quindi richiede solo due parametri (la stringa e il fine riga).<br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">E' poi possibile allineare la stringa a sinistra (invece che a destra) semplicemente usando un padding negativo (es <code>-5%s</code>).<br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">La lezione imparata è dunque: <i>la <code>printf</code> è molto versatile, e nella maggior parte dei casi può risolvere parecchi grattacapi di formattazione!</i><br /></div><div class="status" id="postamble"><br /></div>