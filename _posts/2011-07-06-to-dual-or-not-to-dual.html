---
layout: post
title: To Dual or not to Dual?
date: '2011-07-06T18:38:00.002+02:00'
author: Luca Ferrari
tags:
- postgresql
modified_time: '2011-07-07T09:11:46.211+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-984305347912788511
blogger_orig_url: http://fluca1978.blogspot.com/2011/07/to-dual-or-not-to-dual.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<div style="text-align: justify;">Una delle differenze fra PostgreSQL e Oracle e' nel funzionamento sintattico e semantico dell'istruzione SELECT. Agli utenti Oracle potrebbe risultare strano, ma la clausola FROM di una istruzione SELECT in PostgreSQL e' opzionale:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Command:&nbsp;&nbsp;&nbsp;&nbsp; SELECT</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Description: retrieve rows from a table or view</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Syntax:</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">[ WITH [ RECURSIVE ] with_query [, ...] ]</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; * | expression [ [ AS ] output_name ] [, ...]</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; [ FROM from_item [, ...] ]</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">...</span><br /><br /><br />Questo significa che, qualora non sia necessario recuperare le tuple con accesso ad una tabella (ad esempio perche' le tuple vengono generate al volo da una stored procedure), la clausola FROM puo' essere omessa.<br />In altre parole il comando<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT 'W PostgreSQL';</span><br /><br />fa quello che ci aspetta:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; ?column?&nbsp;&nbsp; </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">--------------</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;W PostgreSQL</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">(1 row)</span><br /><br /><br />mentre in Oracle l'istruzione<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT 'W Oracle';</span><br /><br />non funziona poiche' la SELECT in Oracle si aspetta obbligatoriamente la clausola FROM. La soluzione che spesso si trova nei manuali e nella guida ufficiale e' di usare la tabella speciale "dual" nella clausola FROM, ossia l'istruzione funzionante diventa:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT 'W Oracle' FROM dual;</span><br /><br />Che cosa e' dual? E' una tabella (come tutte le altre) creata al momento di inizializzazione dell'istanza Oracle, assieme al catalogo di sistema. La tabella contiene esattamente una tupla con una singola colonna (di nome dummy) con valore 'X'. In PostgreSQL si puo' ricreare una tabella dual Oracle-like con i seguenti comandi:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># CREATE TABLE dual( dummy char(1) );</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">CREATE TABLE</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># INSERT INTO dual(dummy) VALUES('X');</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">INSERT 0 1</span><br /><br />Se sull'istanza PostgreSQL ora si esegue la query in stile Oracle-like si ottiene il risultato voluto:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># SELECT 'W Oracle' FROM dual;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;?column? </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">----------</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;W Oracle</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">(1 row)</span><br /><br /><br />Quindi e' possibile su PostgreSQL simulare il comportamento Oracle creando una tabella dual in modo molto semplice.<br />E' bene comunque spendere qualche considerazione circa la tabella dual di Oracle. Anzitutto e' bene capire come mai la query con la clausola "FROM dual" funziona su entrambi i sistemi. Il linguaggio SQL prevede che un join senza filtro riporti in uscita il prodotto cartesiano delle tuple delle relazioni coinvolte; questo significa che per ogni record presente in dual (unica relazione coinvolta) viene riportato in uscita un record con i valori selezionati di dual (in questo caso nessuno) e eventuali altri valori (in questo caso la stringa). E' facile verificare questo aggiungendo un record a dual ed eseguendo nuovamente la query:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># INSERT INTO dual(dummy) VALUES('Y');</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">INSERT 0 1</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># SELECT 'W Oracle' FROM dual;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;?column? </span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">----------</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;W Oracle</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;W Oracle</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">(2 rows)</span><br /><br /><br />Spiegato quindi il mistero della clausola "FROM dual" si puo' analizzare in dettaglio cosa comporti questo approccio.<br />Anzitutto l'accesso alla tabella richiede un sequential scan per ogni query. La cosa non impatta sulle prestazioni, poiche' la tabella e' piccola e sicuramente non viene mai paginata, tuttavia il motore di esecuzione deve comunque effettuare l'accesso come per ogni normale tabella.<br />In secondo luogo qualora il contenuto di dual sia modificato (ad esempio aggiungendo un record) si otterra' che molte query non funzioneranno piu' nel modo voluto. Si pensi ad esempio a query del tipo<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT laMiaStoredProcedureDistruttiva() FROM dual;</span><br /><br />che vengono eseguite piu' volte a causa di una manomissione di dual. <br />Analogamente, la rimozione del record da dual produce una query funzionante ma con output nullo. Entrambe le situazioni sono pericolose, ma la seconda (nessun record in dual) e' difficilmente individuabile nel caso di test automatici, poiche' la query di fatto esegue correttamente.<br /><br />Quale comportamento e' corretto?<br />Personalmente ritengo che Oracle applichi un concetto di uniformita': tutte le query devono avere una relazione (esistente) nella clausola FROM. PostgreSQL e' piu' flessibile in questo, ammettendo che le tuple potrebbero essere generate al volo anche senza partire da un prodotto cartesiano.<br />Lato sintattico la sintassi di PostgreSQL e' sicuramente migliore: perche' scrivere sempre "FROM dual" nelle proprie query quando non serve l'output di dual? Lato semantico la metodologia di Oracle e' sicuramente piu' uniforme.<br />Infine occorre tenere presente che PostgreSQL garantisce che query SELECT senza clausola FROM funzioneranno sempre, anche in presenza di manomissioni allo schema (a patto di non rovinare gli operatori!), Oracle potrebbe mostrare comportamenti differenti fra le istanze a seconda del contenuto di dual.</div>