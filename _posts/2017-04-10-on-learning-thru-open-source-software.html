---
layout: post
title: On learning thru Open Source Software
date: '2017-04-10T21:37:00.000+02:00'
author: Luca Ferrari
tags:
- riflessioni
- universit√†
- programmazione
modified_time: '2017-04-10T21:37:04.516+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-4882072271309948716
blogger_orig_url: http://fluca1978.blogspot.com/2017/04/on-learning-thru-open-source-software.html
---

<div style="text-align: justify;">I read an interesting blog post on <a href="http://www.angrycane.com.br/en/2017/04/06/tech-universities-adopt-a-free-software-as-your-own-children/">adopting open source at university as a way of teaching computer science</a>, and I posted also a comment<br />on such article.<br />Here I would like to extend my point of view about the subject.<br />Having worked in an university for a few years, having done computer science at both sides of the desk, and having a quite good<br />experience in what became my day-to-day work, I believe I can express some opinion about.<br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Adopting open source as a teaching methodology <i>should just be</i>.<br />Period!<br />Instead of asking students to produce the same crappy software all over the time (a database layer, a GUI layer, a music store,<br />a calculator), put them on a real piece of software that someone in the world could use and adopt.<br />Why?<br /></div><ol class="org-ol" style="text-align: justify;"><li><u><span class="underline">motivation</span></u>: students will be happy to work on some real stuff with the main author(s) thanking them for their help, time,<br />and work;</li><li><u><span class="underline">learn something useful</span></u>: real programs do things in the real world, and things in the real world must work, and work fast, and work<br />in accurate way. That is:<br /><ul class="org-ul"><li><u><span class="underline">work on real data</span></u>: nobody will ever notice your crappy homework do a full table scan each time you need to display one of your<br />fake music titles out of ten, but a real program will freeze once you try to do a full table scan just to display out a detail<br />out of a million records. This is something university cannot teach you, trust me!</li><li><u><span class="underline">deal with problems</span></u>: university will teach you a lot of theory about using <i>natural keys</i>, <i>algorithms</i> to sort structures, avoid<br />data replication, and so on. Not always these approaches will drive you to a manageable software: learn to deal<br />with <i>surrogate keys</i>, <i>duplicate data when it makes sense</i> (e.g., network latency, historical reasons and so on).</li><li><u><span class="underline">learn the tools</span></u>: developers around the world need to coordinate. Learn to use bug reports, stay on mailing lists, IRC channels,<br />and alike. Don't ask stackoverflow for someone to do your homework, learn how to find documentation and search for answers. Become<br />acquainted with revision control, compilers, linkers, and different platforms.</li><li><u><span class="underline">document for someone else</span></u>: it is easy for you to explain what you have done to your teacher, in particular if you did it in the very<br />previous period of time (typically a semester). But can you document something so that another developer, even another student like<br />you, can understand one year later why and how you did a task?</li></ul></li><li><u><span class="underline">do not start a project from scratch</span></u>: typically the university cycle during semesters is something like <i>design-implement-compile-run-explain-<sub>throw</sub> away_</i><br />and then you start over and over again every time you got an assignment, homework, or project. <i>This is wrong!</i> Real life does not work as such:<br />in real life you are often assigned to maintain or refactor an existing piece of code without having to throw it away.</li><li><u><span class="underline">learn idioms</span></u>: developers around the globe are smarter than you. It is not they are more intelligent, it is just they are more expert<br />and know better the subject. Reading someone else (smarter) code is a great way to improve your knowledge and become smarter too. Learning <i>idioms</i>,<br />seeing patterns applied to real world code is a great start to become a professional coder.</li><li><u><span class="underline">fun</span></u>: developers have their habits. They meet together in so called <i>conferences</i>, and usually got beers while talking about code, travel<br />around the world, and have a lot of fun. And even if you stay closed in your room, doing your homework, having a chat, a video call<br />or an email in your in-box with a "thank you" or "good job!" is really fun.</li></ol><div style="text-align: justify;"><br /></div><div style="text-align: justify;">There are other reasons, but the above are my main choices to push students to the open source world.<br />So far, it seems that you are going to have only advantages and no drawbacks, but that's not true.<br />Becoming an open source contributor you are going to <i>become smarter than your own university teacher</i>, and this is a drawback so far as<br />the teacher signs your curriculum. It is something that is really hard for a teacher to keep in mind, but it is so true.<br />I was always saying to my student, in the very beginning of each class, that at the end they will know better than me the subject, and the reason<br />for that is that "I'm not going to spend whole nights studying before the exam!".<br />So, if you are a teacher, simply accept that.<br />Accept that a student could prove a better algorithm, or an idiom you don't know that works. Ask him for the details, learn from him.<br /><u><span class="underline">Learning is not a one-way process, with a god-like teacher and an idiot-like student; learning is a cooperation where someone expert provides the sparkle to someone else</span>.</u><br />Would not be nice to see if both can grow during the path?<br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">There is also another drawback: open source is not something you can teach without knowledge. You have to <i>know the tools</i>: revision control, IDEs,<br />bug tracking, issue tracking, wiki, testing and alike.<br />Most teachers urge teaching C pointers arhitmetic instead of basic tools, and that's not good.<br />Allow me to provide my very own example: I spent five years in a computer science degree, and nobody told me about revision control. While<br />doing my master thesis, being afraid of loosing some change or to mistakenly do a single line change (that will not blow up your project, right?),<br />I did my very own backup shell script that was running every hour to keep an historical copy of my work.<br />Shame on me, in the very same time I could have learnt <code>rc</code> or <code>cvs</code> (no, it was before <code>git</code>).<br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">So my advice for students is <i>be a part of an open source community</i>, you will surely learn something that will make the difference in<br />your real job.<br />And my advice for teachers is <i>accept smarter students and promote the adoption of an open source code base</i>. There are a lot of "mini-hackers"<br />initiatives around the world (<i>CPAN Pull Request</i>, <i>Hacktoberfest</i>, etc.), pick one and try let your student do the rest.<br />You'll be happier, your student will be happier, the open source community will be happier and, who knows, your employer could also<br />become a partner in an open source community.<br /></div>