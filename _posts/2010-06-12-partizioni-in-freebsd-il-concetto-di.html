---
layout: post
title: 'Partizioni in FreeBSD: il concetto di slice'
date: '2010-06-12T13:09:00.000+02:00'
author: Luca Ferrari
tags:
- freebsd
modified_time: '2010-06-12T13:09:16.347+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-4330305191741457390
blogger_orig_url: http://fluca1978.blogspot.com/2010/06/partizioni-in-freebsd-il-concetto-di.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<div style="text-align: justify;">FreeBSD non partiziona i dischi seguendo lo schema "classico" di Linux o MS-DOS, ma utilizza un concetto differente: le <i>slice</i>.</div><div style="text-align: justify;">Una slice è da intendersi come una normale partizione, ossia su un disco formattato ci possono essere al massimo 4 slice. All'interno delle slice ci possono essere quante partizioni si vuole, seguendo il concetto di <i>disklabel</i>. L'idea è questa: una slice rappresenta una delle quattro partizioni primarie di un disco, all'interno della slice posso avere differenti partizioni (logiche a questo punto). Le slice sono sempre numerate (ad esempio <i>s1</i>) mentre le partizioni sono sempre identificate da lettere (ad esempio <i>a</i>). Quindi la prima partizione (in senso FreeBSD) potrebbe essere la <i>s1a</i>, ovvero la prima partizione logica che si trova nella prima partizione primaria. Il disklabel è l'informazione sulle partizioni interne di FreeBSD, visto che le slice sono memorizzate nella normale tavola delle partizioni del disco. Il disklabel è un file che si trova all'inizio della partizione primaria (slice) e che contiene un array di partizioni (logiche) FreeBSD. E' facile rendersi conto di questo analizzando i <a href="http://svn.freebsd.org/viewvc/base/stable/8/sbin/bsdlabel/bsdlabel.c?revision=196384&amp;view=markup">sorgenti del comando <i>bsdlabel</i></a> (che consente di visualizzare/modificare la tabella delle partizioni estese di FreeBSD). In particolare si ha che il file che viene letto è all'inizio del disco stesso:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"></div><pre>static int<br />readlabel(int flag)<br />{<br /> uint32_t lba;<br /> int f, i;<br /> int error;<br /><br /> f = open(specname, O_RDONLY);<br /> if (f &lt; 0)<br />  err(1, specname);<br /> if (is_file)<br />  get_file_parms(f);<br /> else {<br />  mediasize = g_mediasize(f);<br />  secsize = g_sectorsize(f);<br />  if (secsize &lt; 0 || mediasize &lt; 0)<br />   err(4, "cannot get disk geometry");<br /> }<br /> if (mediasize &gt; (off_t)0xffffffff * secsize)<br />  errx(1,<br />      "disks with more than 2^32-1 sectors are not supported");<br /> <b>(void)lseek(f, (off_t)0, SEEK_SET);</b><br /> if (read(f, bootarea, BBSIZE) != BBSIZE)<br />  err(4, "%s read", specname);<br /> close (f);<br /> error = <b>bsd_disklabel_le_dec(<br />     bootarea + (labeloffset + labelsoffset * secsize),<br />     &amp;lab, MAXPARTITIONS);</b><br /> if (flag &amp;&amp; error)<br />  errx(1, "%s: no valid label found", specname);<br /><br /> if (is_file)<br />  return(0);<br /><br /> /*<br />  * Compensate for absolute block addressing by finding the<br />  * smallest partition offset and if the offset of the 'c'<br />  * partition is equal to that, subtract it from all offsets.<br />  */<br /> lba = ~0;<br /> for (i = 0; i &lt; lab.d_npartitions; i++) {<br />  if (lab.d_partitions[i].p_size)<br />   lba = MIN(lba, lab.d_partitions[i].p_offset);<br /> }<br /> if (lba != 0 &amp;&amp; lab.d_partitions[RAW_PART].p_offset == lba) {<br />  for (i = 0; i &lt; lab.d_npartitions; i++) {<br />   if (lab.d_partitions[i].p_size)<br />    lab.d_partitions[i].p_offset -= lba;<br />  }<br />  /*<br />   * Save the offset so that we can write the label<br />   * back with absolute block addresses.<br />   */<br />  lba_offset = lba;<br /> }<br /> return (error);<br />}<br /></pre><div style="text-align: justify;">Come si vede la <i>lseek</i> posiziona il prossimo punto di lettura all'inizio della partizione primaria corrente. Da qui poi si legge una certa mole di dati equivalenti ad una struct C che si trova nel file <a href="http://svn.freebsd.org/viewvc/base/stable/8/sys/sys/disklabel.h?revision=199583&amp;view=markup">header</a>:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"></div><pre>struct disklabel {<br /> u_int32_t d_magic;  /* the magic number */<br /> u_int16_t d_type;  /* drive type */<br /> u_int16_t d_subtype;  /* controller/d_type specific */<br /> char   d_typename[16]; /* type name, e.g. "eagle" */<br /><br /> char      d_packname[16]; /* pack identifier */<br /><br />   /* disk geometry: */<br /> u_int32_t d_secsize;  /* # of bytes per sector */<br /> u_int32_t d_nsectors;  /* # of data sectors per track */<br /> u_int32_t d_ntracks;  /* # of tracks per cylinder */<br /> u_int32_t d_ncylinders;  /* # of data cylinders per unit */<br /> u_int32_t d_secpercyl;  /* # of data sectors per cylinder */<br /> u_int32_t d_secperunit;  /* # of data sectors per unit */<br /><br />   /* filesystem and partition information: */<br /><b> u_int16_t d_npartitions; /* number of partitions in following */<br /> u_int32_t d_bbsize;  /* size of boot area at sn0, bytes */<br /> u_int32_t d_sbsize;  /* max size of fs superblock, bytes */<br /> struct partition {  /* the partition table */<br />  u_int32_t p_size; /* number of sectors in partition */<br />  u_int32_t p_offset; /* starting sector */<br />  u_int32_t p_fsize; /* filesystem basic fragment size */<br />  u_int8_t p_fstype; /* filesystem type, see below */<br />  u_int8_t p_frag; /* filesystem fragments per block */<br />  u_int16_t p_cpg; /* filesystem cylinders per group */<br /> } d_partitions[MAXPARTITIONS]; /* actually may be more */</b>};</pre><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Come si nota la struttura, oltre a contenere i dati di base del disco (geometria, ecc.) contiene un array di partizioni, che altro non sono che le partizioni logiche di FreeBSD. Da notare che ogni partizione contiene l'offset, la dimensione e il filesystem, che sono le stesse informazioni, presentate in modo testuale, da <i>bsdlabel</i>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div>