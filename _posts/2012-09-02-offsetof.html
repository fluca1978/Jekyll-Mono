---
layout: post
title: offsetof
date: '2012-09-02T17:30:00.000+02:00'
author: Luca Ferrari
tags:
- linux
- c
- programmazione
- freebsd
modified_time: '2012-09-03T07:58:52.211+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-3541940569924851506
blogger_orig_url: http://fluca1978.blogspot.com/2012/09/offsetof.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<div style="text-align: justify;">Il linguaggio C, attraverso l'aritmetica dei puntatori, permette agli sviluppatori di passare da un tipo di dato ad un altro in maniera incontrollata. Solitamente solo gli sviluppatori virtuosi si applicano nella "artimetica dei puntatori". L'aritmetica dei puntatori puo' poi essere usata per fare una sorta di "introspezione", consentendo ad uno sviluppatore di estrarre da un puntatore ad un dato complesso (es. struct) un riferimento ad un singolo dato e viceversa. Per venire incontro agli sviluppatori, molti compilatori supportano delle&nbsp; istruzioni speciali, come ad esempio __builtin_offsetof di GCC, e la libreria C fornisce dei wrapper per queste funzioni. Uno di questi wrapper, molto interessante, e' appunto offsetof, che consente dato un tipo di struttura e il nome di un campo, di trovare l'offset del campo all'interno della struttura. Ad esempio, considerando la struttura seguente:</div><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: xx-small;">struct three_chars {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char b;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char c;<br />}</span><br /><br />e volendo recuperare l'offset del campo "b" si puo' scrivere una cosa come segue:<br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /><span style="font-size: xx-small;">offset = offsetof( struct three_chars, b );</span></span></span><br /><br /><br /><br /><br /><div style="text-align: justify;">che ritornera' il numero di bytes da sommare ad un puntatore alla base della struttura per ottenere l'indirizzo di memoria ove risiede "b". La macro <u>offsetof</u> e' indubbiamente comoda, ma risultati analoghi possono essere ricavati anche con l'analisi delle strutture e l'aritmetica dei puntatori; tuttavia lo sforzo richiesto e' maggiore.<br />Per meglio comprendere come si possa usare l'approccio con e senza offsetof ho creato <a href="https://github.com/fluca1978/fluca1978-coding-bits/tree/master/teaching-stuff/c/offset_of">alcuni semplici programmi</a> che illustrano il funzionamento dell'aritmetica dei puntatori. L'idea alla base di questi programmi e' quella di avere l'annidamento di alcune strutture, un header e un pacchetto. Esistono due versioni di pacchetto: una con header all'inizio e una con header alla fine. Lo scopo delle due implementazione e' di mostrare come cambi l'aritmetica dei puntatori nei due casi. Le strutture dati sono molto semplici e definite come segue:</div><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: xx-small;">struct header {<br />&nbsp; <br />&nbsp; /**<br />&nbsp;&nbsp; * An header name, just to print something out.<br />&nbsp;&nbsp; */<br />&nbsp; char* h_name;<br />&nbsp; <br />&nbsp; /**<br />&nbsp;&nbsp; * A version, just to simulate some real header data.<br />&nbsp;&nbsp; */<br />&nbsp; int h_version;<br /><br />};<br /><br /><br />struct packet_with_header_at_top {<br />&nbsp; <br />&nbsp; /**<br />&nbsp;&nbsp; * The packet header.<br />&nbsp;&nbsp; */<br />&nbsp; struct header p_header;<br />&nbsp; <br />&nbsp; <br />&nbsp; /**<br />&nbsp;&nbsp; * A name for this packet, just to print out something.<br />&nbsp;&nbsp; */<br />&nbsp; char* p_name;<br />&nbsp; <br />&nbsp; /**<br />&nbsp;&nbsp; * An integer to simulate some real packet data.<br />&nbsp;&nbsp; */<br />&nbsp; int p_data;<br />&nbsp; <br /><br />};<br /><br /><br /><br />struct packet_with_header_at_bottom {<br />&nbsp; <br />&nbsp; <br />&nbsp; /**<br />&nbsp;&nbsp; * A name for this packet,&nbsp;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: xx-small;">&nbsp;&nbsp; * just to print out something.<br />&nbsp;&nbsp; */<br />&nbsp; char* p_name;<br />&nbsp; <br />&nbsp; /**<br />&nbsp;&nbsp; * An integer to simulate some real packet data.<br />&nbsp;&nbsp; */<br />&nbsp; int p_data;<br /><br />&nbsp; /**<br />&nbsp;&nbsp; * The packet header.<br />&nbsp;&nbsp; */<br />&nbsp; struct header p_header;<br />&nbsp; <br />};</span><br /><br /><div style="text-align: justify;">Si supponga di inizializzare strutture e relativi puntatori come segue:</div><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br />&nbsp; // create an header<br />&nbsp; struct header my_header = {<br />&nbsp;&nbsp;&nbsp; .h_name&nbsp;&nbsp;&nbsp; = "HEADER",<br />&nbsp;&nbsp;&nbsp; .h_version = 1<br />&nbsp; };<br />&nbsp;&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; struct packet_with_header_at_top my_packet_top = {<br />&nbsp;&nbsp;&nbsp; .p_header = my_header,<br />&nbsp;&nbsp;&nbsp; .p_name&nbsp;&nbsp; = "PACKET WITH HEADER AT TOP",<br />&nbsp;&nbsp;&nbsp; .p_data&nbsp;&nbsp; = 99<br />&nbsp; };<br /><br /><br />&nbsp; struct packet_with_header_at_bottom my_packet_bottom = {<br />&nbsp;&nbsp;&nbsp; .p_header = my_header,<br />&nbsp;&nbsp;&nbsp; .p_name&nbsp;&nbsp; = "PACKET WITH HEADER AT BOTTOM",<br />&nbsp;&nbsp;&nbsp; .p_data&nbsp;&nbsp; = 999<br />&nbsp; };<br /><br />&nbsp; struct packet_with_header_at_top*&nbsp;&nbsp;&nbsp; top_pointer&nbsp;&nbsp;&nbsp;&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &amp;my_packet_top;<br />&nbsp; struct packet_with_header_at_bottom* bottom_pointer&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &amp;my_packet_bottom;<br />&nbsp; struct header*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header_pointer&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &amp;my_header;</span></span><br /><br /><br /><br /><br /><div style="text-align: justify;">Si consideri prima il caso privo di supporto <i>offsetof</i>: avendo inizializzato le due strutture di pacchetto e avendo i relativi puntatori, per estrarre l'header dai pacchetti occorre considerare il layout delle rispettive strutture pacchetto.<br />Nel caso di <i>packet_with_header_at_top</i>, essendo l'header il primo campo utile della struttura pacchetto, un puntatore al pacchetto e' automaticamente anche un puntatore all'header, e quindi non occorre applicare nessuna matematica dei puntatori:</div><br /><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; // cast the pointer to the packet to a pointer to the header<br />&nbsp; header_pointer = top_pointer;<br />&nbsp; printf( "\nHeader name and data extracted from the packet: %s - %d",&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header_pointer-&gt;h_name,&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header_pointer-&gt;h_version );<br />&nbsp; // cast back from header to packet<br />&nbsp; top_pointer = ( struct packet_with_header_at_top* ) header_pointer;<br />&nbsp; printf( "\n Name of the packet with header at top:&nbsp;&nbsp;&nbsp; %s",&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; top_pointer-&gt;p_name );</span></span><br /><br /><br /><div style="text-align: justify;">Nel caso di <i>packet_with_header_at_bottom</i> il puntatore alla struttura punta alla "base" della struttura, mentre l'header si trova ad un certo spiazzamento da questo. Occorre quindi calcolare manualmente l'offset considerando le dimensioni dei campi che precedono p_header nella struttura (e allineare l'offset stesso al byte):</div><br /><br />&nbsp;<span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"> // compute the supposed offset depending on the fields that are before<br />&nbsp; // the p_header<br />&nbsp; offset = sizeof( int ) + sizeof( char* );<br /><br />&nbsp; // align the offset to 1 byte<br />&nbsp; offset = ( offset % sizeof( char* ) == 0 ? offset&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ceil( ( (double) offset / (double) sizeof( char* ) ) )&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * sizeof( char* ) );<br /><br />&nbsp; // move the pointer to the offset<br />&nbsp; header_pointer = ( (char*) bottom_pointer ) + offset;<br /><br />&nbsp; printf( "\nHeader name and data extracted from the packet: %s - %d",</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; header_pointer-&gt;h_name,&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header_pointer-&gt;h_version );<br /><br />&nbsp; // cast back from header to packet using again the offset<br />&nbsp; bottom_pointer = ( struct packet_with_header_at_bottom* )&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( (char*) header_pointer - offset );<br />&nbsp; printf( "\n Name of the packet with header at top:&nbsp;&nbsp;&nbsp; %s",</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bottom_pointer-&gt;p_name );</span></span><br /><br /><br /><div style="text-align: justify;">Avendo quindi conoscenza del layout della struttura e' quindi possibile ottenere puntatori ai membri interni e, da questi, alla struttura stessa.<br />Tuttavia questo approccio non e' pienamente portabile, poiche' appunto prevede il calcolo manuale basato sul layout della struttura container.<br />E' qui che entra in gioco <i>offsetof</i>, che non richiede una conoscenza puntuale della struttura container; di seguito il caso relativo a packet_with_header_at_bottom (l'altro caso e' analogo):</div><br /><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; offset = offsetof( struct packet_with_header_at_bottom, p_header );<br />&nbsp; printf( "\nOffset computed is %d", offset );<br /><br />&nbsp; // move the pointer to the offset<br />&nbsp; header_pointer = ( (char*) bottom_pointer )&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + offset;<br /><br />&nbsp; printf( "\nHeader name and data extracted from the packet: %s - %d",</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; header_pointer-&gt;h_name,&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header_pointer-&gt;h_version );<br /><br />&nbsp; // cast back from header to packet using again the offset<br />&nbsp; bottom_pointer = ( struct packet_with_header_at_bottom* )&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( (char*) header_pointer - offset );<br />&nbsp; printf( "\n Name of the packet with header at top:&nbsp;&nbsp;&nbsp; %s",</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bottom_pointer-&gt;p_name );</span></span><br /><br /><br /><div style="text-align: justify;">Il funzionamento e' identico al caso manuale, ma qui non compare da nessuna parte l'elenco dei campi che precedono p_header, e quindi lo sviluppatore non e' costretto a ragionare sul layout della struttura container.<br />E' possibile implementare una sorta di "offsetof del poveraccio" usando ancora l'aritmetica dei puntatori e definendo una macro come la seguente:</div><br /><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">#define custom_offset_of( struct_pointer, struct_member ) \<br />&nbsp; ( (size_t)&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( (char*) &amp;( (struct_pointer*) NULL )-&gt;struct_member&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - (char*) NULL ) )</span></span><br /><br /><br /><div style="text-align: justify;">L'idea della macro e' abbastanza semplice e puo' essere riassunta nei seguenti passi:<br /><br />1) si converte il valore <i>NULL</i> ad un puntatore alla struttura del tipo specificato, ossia si considera di avere una struttura che ha indirizzo di base 0: <span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">(struct_pointer*) NULL )</span></span><br /><br />2) si chiede di accedere al campo specificato mediante operatore freccia, e si prende l'indirizzo del campo mediante operatore <i>&amp;</i>. In altre parole si calcola dove risiede l'indirizzo di memoria del campo se la struct avesse indirizzo di base 0: <span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&amp;( (struct_pointer*) NULL )-&gt;struct_member</span></span><br /><br />3) si sottrae dall'indirizzo di memoria del membro il valore di un puntatore a <i>NULL</i>, e quindi si ricava di quanti byte ci si deve spostare per arrivare al campo:&nbsp;</div><div style="text-align: justify;"><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&amp;( (struct_pointer*) NULL )-&gt;struct_member - (char*) NULL ) </span></span></div><div style="text-align: justify;">4) si restituisce il valore trovato come <i>size_t.</i></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Quanto appena visto viene usato in modo pesante all'interno delle strutture dati del kernel, come ad esempio le liste (semplici e doppie).<i> </i></div><br />