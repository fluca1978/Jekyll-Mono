---
layout: post
title: Dividere uno stream in blocchi
date: '2011-02-14T22:17:00.000+01:00'
author: Luca Ferrari
tags:
- programmazione
- java
modified_time: '2011-02-14T22:17:02.653+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-643005152957192626
blogger_orig_url: http://fluca1978.blogspot.com/2011/02/dividere-uno-stream-in-blocchi.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<div style="text-align: justify;">Capita spesso di dover spezzare un array di byte (o di altro tipo) in "pezzi" da inviare a client remoti in modo continuo fino all'esaurimento dei dati stessi. Il pattern per implementare questa funzionalità&nbsp; è abbastanza semplice, e ovviamente esistono diverse implementazioni più o meno raffinate; propongo di seguito quella che sono solito usare:<br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: xx-small;"><br />int APPLICATION_BYTE_STREAM_SIZE = 1024;<br />byte[] myByteArray = ...;<br />OutputStream os = ...;</span><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: xx-small;">int chunksToSend = myByteArray.length / APPLICATION_BYTE_STREAM_SIZE;<br />for( int chunkNumber = 0; chunkNumber &lt; chunksToSend; chunkNumber++ )<br />&nbsp;&nbsp;&nbsp;&nbsp; os.write(&nbsp; myByteArray,&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; APPLICATION_BYTE_STREAM_SIZE * chunkNumber, <br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; APPLICATION_BYTE_STREAM_SIZE );<br /><br />// ho ancora dei chunk?<br />int lastChunkSize = myByteArray.length % APPLICATION_BYTE_STREAM_SIZE;<br />if( lastChunkSize &gt; 0 )<br />&nbsp;&nbsp;&nbsp; os.write( &nbsp;&nbsp;&nbsp; myByteArray,<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myByteArray.length - lastChunkSize, <br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; lastChunkSize );</span><br />&nbsp;</div><div style="text-align: justify;">L'idea è abbastanza semplice: dato l'array di byte myByteArray che deve essere inviato in blocchi (chunk) da massimo APPLICATION_BYTE_STREAM_SIZE bytes si procede come segue:<br />&nbsp;</div><div style="text-align: justify;">1) si calcolano quanti chunk si devono spedire. Se la dimensione dell'array di byte è identica a quella di un singolo chunk si avrà, chiaramente, un chunk solo da spedire; se la dimensione è inferiore non si dovranno spedire chunk in questo primo step, altrimenti si spediranno i chunk necessari per avvicinarsi alla dimensione dell'array di byte.<br />&nbsp;</div><div style="text-align: justify;">2) nel caso in cui la dimensione dell'array di byte non sia multiplo di APPLICATION_BYTE_STREAM_SIZE si avrà&nbsp; una rimanenza, che viene calcolata con una semplice divisione per resto: il risultato corrispondenrà&nbsp; alla dimensione dell'ultimo chunk da inviare. Si procede quindi alla scrittura dell'ultimo chunk considerando che lo spiazzamento è pari ai byte rimanenti dal fondo dell'array.<br /><br />Il procedimento di cui sopra puo' essere "compresso" in due modi: usando uno spiazzamento all'indietro oppure uno all'avanti (quest'ultimo risulta leggermente piu' chiaro). L'idea in entrambi i casi è quella di sapere in anticipo se ci sarÃ&nbsp; il chunk di chiusura (ossia quello dei byte rimanenti dovuto al fatto che l'array di byte non è un multiplo di APPLICATION_BYTE_STREAM_SIZE) e di usare un unico ciclo per la scrittura dei byte. Ovviamente occorre riconoscere il caso in cui si debba spedire un chunk intero o la parte di completamento.<br />Il ciclo all'indietro è il seguente:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: xx-small;">int lastChunkSize =&nbsp; myByteArray.length % APPLICATION_BYTE_STREAM_SIZE;<br />int chunksToSend = (myByteArray.length / APPLICATION_BYTE_STREAM_SIZE ) + ( lastChunkSize&nbsp; &gt; 0 ? 1 : 0 );<br /><br />for( int chunkRemaining = chunksToSend; chunkRemaining &gt; 0; chunkRemaining-- )<br />&nbsp;&nbsp;&nbsp;&nbsp; os.write(&nbsp; myByteArray,&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; myByteArray.length-(APPLICATION_BYTE_STREAM_SIZE * (chunkRemaining - 1 ) )-lastChunkSize, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ( chunkRemaining != 1 ? APPLICATION_BYTE_STREAM_SIZE : lastChunkSize )<br />&nbsp;&nbsp;&nbsp; );</span><br /><br />Come si nota, il primo passo consiste nel calcolare la dimensione dell'ultimo chunk e considerare il numero di chunk da spedire incrementato di 1 nel caso tale dimensione non sia nulla (che significa che l'array ha dimensione multipla APPLICATION_BYTE_STREAM_SIZE). Il ciclo itera sul numero calcolato di chunk all'indietro, e quindi l'offset dal quale partire a scrivere è dato dalla differenza fra la dimensione totale dell'array, la dimensione di un singolo chunk (considerato quanti ne rimangono) e la dimensione dell'ultimo chunk, in modo che inizialmente l'offset sia nullo. La dimensione dei dati da scrivere dipende dal numero di chunk che rimangono: se ne rimane solo uno (l'ultimo) allora la dimensione è quella calcolata, altrimenti tutti i chunk hanno la stessa dimensione.<br />La versione con ciclo in avanti è leggermente piu' comprensibile:<br /><br /><span style="font-size: x-small;"><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">int lastChunkSize =&nbsp; myByteArray.length % APPLICATION_BYTE_STREAM_SIZE;</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">int chunksToSend = ( myByteArray.length / APPLICATION_BYTE_STREAM_SIZE );</span></span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">for( int currentChunk = 0;&nbsp;</span></span></span></div><div style="text-align: justify;"><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp; currentChunk &lt; (chunksToSend + ( lastChunkSize&nbsp; &gt; 0 ? 1 : 0 ) ); </span></span></div><div style="text-align: justify;"><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; &nbsp;currentChunk++ )</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; os.write( myByteArray,</span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"> &nbsp;</span></span></div><div style="text-align: justify;"><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; APPLICATION_BYTE_STREAM_SIZE * currentChunk,</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (currentChunk != chunksToSend ? APPLICATION_BYTE_STREAM_SIZE : lastChunkSize)&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; );&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </span></span><br />In questo caso il numero di chunk viene considerato pari a quello dei chunk completi da inviare, anche se il ciclo itera su un eventuale chunk di completamento. Lo spiazzamento viene semplicemente calcolato in base ai chunk completi giÃ&nbsp; spediti, mentre il numero di byte da scrivere cambia nel caso si siano spediti tutti i chunk completi.</div>