---
layout: post
title: Programmazione ad oggetti in C (ereditarieta')
date: '2012-09-18T17:30:00.000+02:00'
author: Luca Ferrari
tags:
- c
- università
- programmazione
modified_time: '2012-09-18T17:30:01.176+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-4519989550264118440
blogger_orig_url: http://fluca1978.blogspot.com/2012/09/programmazione-ad-oggetti-in-c.html
---

<div style="text-align: justify;">Qualche giorno fa ho ricevuto un commento via e-mail ad uno dei primi post su questo blog, quello relativo all'utilizzo di casting fra i puntatori per simulare <a href="http://fluca1978.blogspot.it/2008/02/programmazione-ad-oggetti-in-c.html">la programmazione OOP in linguaggio C</a>.<br />Il commento in questione era relativo all'introduzione di uno o piu' metodi pubblici nella classe, che facendo riferimento a due strutture in overlapping, poteva risultare impossibile.<br />Per comprendere bene come procedere occorre anzitutto considerare la struttura stessa del sistema:</div><ul><li>il fatto che esistano due strutture, una privata e una pubblica, non significa che vi siano due "istanze" separate: si deve pensare alla parte pubblica come al file header di una classe C++ e alla struttura privata come alla sua implementazione;</li><li>l'introduzione di un metodo pubblico, come pure di un qualsiasi altro attributo, e' una operazione che non va fatta nella classe base, ma in eventuali sottoclassi. Se venisse infatti fatta sulla classe base si farebbe una "banale" ristrutturazione della classe stessa, che a meno di ovvi problemi di compatibilita' binaria, continuerebbe a funzionare come prima.</li></ul><div style="text-align: justify;"><br />Ho quindi deciso di estendere l'esempio del conto corrente creando una sottoclasse, chiamata ContoCorrenteConCarta (nei file CCX_pub.h e CCX_private.c) che estende le informazioni di base del conto corrente aggiungendo una carta di credito. Ho anche colto l'occasione per estendere il conto corrente stesso con alcune ovvie informazioni che avevo tralasciato, come ad esempio il titolare del conto.<br />Tutti i sorgenti nella loro nuova versione sono disponibili su uno dei miei <a href="https://github.com/fluca1978/fluca1978-coding-bits/tree/master/teaching-stuff/c/ContoCorrente">repository</a> su github.<br /><br />Come per la classe conto corrente di base, la classe con carta di credito deve definire due strutture sovrapposte, una privata che contiene l'implementazione e una pubblica che contiene l'interfaccia.<br />La parte pubblica e' definita come:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;"><br />typedef struct CCX_PUB {<br /><br />&nbsp; // riferimento ad un conto corrente normale<br />&nbsp; ContoCorrentePub* super;<br /><br />&nbsp; // metodo che ritorna il numero della carta di credito<br />&nbsp; char* (*m_numero_carta)( struct CCX_PUB * );<br /><br />} ContoCorrenteConCartaPub;</span></span><br /><br /><br /><div style="text-align: justify;">Si noti che la struttura contiene un puntatore alla sua superclasse, o meglio ad una istanza della superclasse. Il puntatore e' stato volutamente denominato "super" per meglio indicare il legame con una istanza della superclasse.<br />La parte implementativa risulta come segue:</div><br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">typedef struct CCX_private{<br />&nbsp; <br />&nbsp; // riferimento alla parte pubblica<br />&nbsp; ContoCorrenteConCartaPub pub;<br /><br />&nbsp; /*------ dati nascosti ------------*/<br /><br />&nbsp; <br />&nbsp; // numero della carta di credito<br />&nbsp; char* numero_carta;<br />&nbsp; <br />} ContoCorrenteConCartaPrivate;</span></span><br /><br /><br /><div style="text-align: justify;">dove, come al solito, il primo campo e' una variabile di tipo "pubblico" per fare in modo che il casting di puntatori fra <i>ContoCorrenteConCartaPub</i> e <i>ContoCorrenteConCartaPrivate</i> possa funzionare come nell'esempio del conto corrente semplice.<br />Al solito si definiscono dei metodi di conversione da parte pubblica a privata per il nuovo tipo di conto corrente. Occorre anche definire un metodo di inizializzazione, che ad esempio puo' essere come il seguente:</div><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br />ContoCorrenteConCartaPub* abilitaCarta( ContoCorrentePub* contoNormale, char* numero_carta ){<br /><br />&nbsp; // controlli di sicurezza<br />&nbsp; if( contoNormale == NULL || numero_carta == NULL )<br />&nbsp;&nbsp;&nbsp; return NULL;<br /><br /><br />&nbsp; printf("\n\t[abilitaCarta] Abilitazione carta %s su conto %s",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numero_carta,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; contoNormale-&gt;m_titolare( contoNormale ) );<br /><br />&nbsp; // costruisco un nuovo conto corrente esteso<br />&nbsp; ContoCorrenteConCartaPrivate *ccpriv = malloc( sizeof( ContoCorrenteConCartaPrivate ) );</span></span><br /><br />&nbsp; <br />&nbsp; <br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; // inserisco il conto normale nella struttura pubblica<br />&nbsp; ContoCorrentePub* superClass = aperturaContoCorrente(&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; contoNormale-&gt;m_numero_conto( contoNormale ), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; contoNormale-&gt;m_titolare( contoNormale )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br />&nbsp; ccpriv-&gt;pub.super = superClass;<br /><br />&nbsp; // Metodo getter per la carta di credito<br />&nbsp; ccpriv-&gt;pub.m_numero_carta = getNumeroCartaDiCredito;<br /><br />&nbsp; // inserisco il numero di carta nella struttura privata<br />&nbsp; ccpriv-&gt;numero_carta = numero_carta;<br /><br />&nbsp; // oggetto costruito!<br />&nbsp; return Private2Public( ccpriv );<br />&nbsp; <br /><br />}</span></span><br /><br /><br /><br /><div style="text-align: justify;">Si noti che il metodo <i>abilitaCarta</i> funge da costruttore di copia: dato un conto corrente normale (senza carta), si costruisce un oggetto con carta di credito "attorno" a un clone del conto corrente.<br />Questa operazione di copia e' una pura scelta implementativa, sarebbe stato possibile usare il conto passato come argomento invece che crearne un clone. Si noti comunque che il clone ha dei puntatori alla stessa area dati (es. il titolare), e quindi questo costruttore effettua una shallow copy. Ovviamente questa implementazione non raffinata e' per mantenere l'esempio semplice.<br />L'uso della parola "superClass" all'interno del metodo non e' a caso: il conto normale di partenza contiene infatti i dati (e i metodi) che faranno si che il conto carta di credito possa essere trattato anche come conto normale. Inoltre il conto con carta prevede una variabile di tipo conto corrente normale al suo interno, creando quindi un link fra le due implementazioni che e' appunto il legame di ereditarieta'.<br />Volendo essere piu' precisi si dovrebbe sostituire il nome "superClass" con "super", per seguire una terminologia Java, ad ogni modo e' il concetto che conta.<br /><br />Alla fine della costruzione si ha quindi un conto corrente con carta di credito che contiene un link ad un conto normale, inglobato in esso, e gli attributi aggiuntivi definiti nell'estensione della classe stessa.<br />L'utilizzo del nuovo tipo di conto e' semplice, ad esempio:</div><br /><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( "\nCostruzione di un conto con carta di credito\n");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContoCorrenteConCartaPub *ccCarta = abilitaCarta( C1, "123456789" );<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContoCorrentePub* ccpub = ccCarta-&gt;contoCorrente;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( "\nCarta di credito per il conto %s = %s\n",<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ccCarta-&gt;super-&gt;m_titolare( ccCarta-&gt;super ),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ccCarta-&gt;m_numero_carta( ccCarta ) );</span></span><br /><br /><br /><div style="text-align: justify;">Si noti che e' possibile "castare" il conto corrente con carta ad uno senza (ossia alla superclasse), accedendo al campo "super" della sua interfaccia.<br />Ne consegue che le due righe seguenti sono equivalenti:</div><br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ccCarta-&gt;super-&gt;m_titolare( ccCarta-&gt;super );<br />ccpub-&gt;m_titolare( ccpub );</span></span><br /><br /><br /><div style="text-align: justify;">E per il polimorfismo? <br />Avere un metodo polimorfico significa, lato pratico, che il puntato alla funzione contenuta nella implementazione (della superclasse) sia modificato.<br />In realtà la cosa e' leggermente piu' complessa: non deve essere infatti modificato il puntatore nella sueprclasse, ma un nuovo puntatore nella sottoclasse deve essere introdotto.<br />Infatti rimuovere/modificare il puntatore nella superclasse significa perdere ogni possibile legame con il metodo ridefinito, cosa che invece puo' tornare utile ad esempio se si deve invocare tale metodo.<br />Per semplicita' si supponga di voler sovrascrivere il metodo che fornisce il titolare di un conto corrente, in modo che nel caso ci sia una carta di credito venga stmapato il nome del titolare e il numero della carta.<br />La struttura pubblica del nuovo conto corrente con carta di credito viene quindi modificata come segue:</div><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br />typedef struct CCX_PUB {<br /><br />&nbsp; // riferimento ad un conto corrente normale<br />&nbsp; ContoCorrentePub* super;<br /><br />&nbsp; // metodo che ritorna il numero della carta di credito<br />&nbsp; char* (*m_numero_carta)( struct CCX_PUB * );<br /><br />&nbsp; // overriding del metodo titolare di ContoCorrentePub<br />&nbsp; char* (*m_titolare)( struct CCX_PUB * );<br /><br />} ContoCorrenteConCartaPub;</span></span><br /><br /><br /><br /><div style="text-align: justify;">La definizione del nuovo metodo e' la seguente, da inserire nella implementazione di ContoCorrenteConCartaPrivare:</div><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br />static <br />char*<br />getTitolare( ContoCorrenteConCartaPub *ccpub ){<br />&nbsp; if( ccpub == NULL )<br />&nbsp;&nbsp;&nbsp; return NULL;<br /><br />&nbsp; ContoCorrenteConCartaPrivate *ccpriv = Public2Private( ccpub );<br />&nbsp; ContoCorrentePub *super&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = ccpub-&gt;super;<br />&nbsp; char* titolare_super = super-&gt;m_titolare( super );<br />&nbsp; char* titolare_desc&nbsp; = malloc( sizeof( char ) * strlen( titolare_super ) * 2 );<br />&nbsp; sprintf( titolare_desc, "%s (%s)", titolare_super, ccpriv-&gt;numero_carta );<br />&nbsp; return titolare_desc;<br />}</span></span><br /><br /><br /><br /><div style="text-align: justify;">Come si puo' notare il metodo combina della logica legata solo al conto con carta di credito a della logica della superclasse, andando infatti ad invocare il metodo della superclasse.<br />Il resto del codice viene modificato di conseguenza per inserire il nuovo puntatore a funzione e utilizzare il nuovo metodo.<br /><br />Occorre fare una riflessione sul meccanismo del polimorfismo sopra descritto.<br />Anzitutto si noti come cambia l'argomento del metodo, che a seconda della posizione in cui si trova nella catena di ereditarieta' accetta un puntatore alla istanza di classe stessa. Questo e' anche il metodo con il quale molti linguaggi OOP implementano le chiamate di metodo.<br />Tuttavia questo rudimentale meccanismo non permette di effettuare una vera chiamata polimorfica: se si usa un puntatore alla superclasse (ContoCorrentePub) e si invoca il metodo si otterra' l'esecuzione del metodo della superclasse.<br />Affinche' anche la superclasse invochi il metodo definito per ultimo nella catena di ereditarieta' occorre modificare il puntatore alla funzione m_titolare di ContoCorrentePub affinche' punti alla nuova implementazione. All'interno del metodo si dovra' poi fare il cast esplicito da ContoCorrentePub a ContoCorrenteConCartaPub.<br />In questo modo pero' si rischia di perdere il legame al metodo precedente, e quindi di non poterlo piu' invocare. E' quindi compito della implementazione della sottoclasse mantenere i puntatori necessari e fare gli aggiustamenti ai pnntatori della superclasse stessa.</div><br />