---
layout: post
title: 'Dati legacy: un piccolo dumper Perl per database PostgreSQL'
date: '2011-01-30T17:06:00.000+01:00'
author: Luca Ferrari
tags:
- perl
- postgresql
modified_time: '2011-01-30T17:06:09.499+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-4820855579674476955
blogger_orig_url: http://fluca1978.blogspot.com/2011/01/dati-legacy-un-piccolo-dumper-perl-per.html
---

<div style="text-align: justify;">Capita spesso di dover far dialogare la propria base dati PostgreSQL con un qualche tipo di applicazione legacy e/o proprietaria che non accetta nessuna forma di IPC o di data source configurabile. Solitamente in questi casi si è costretti a procedere attraverso l'import/export di file di testo in un qualche formato (CSV, tabulati, line-delimited, ecc.). Ebbene ultimamente ho dovuto anche io esportare dei dati "live" da un database PostgreSQL in modo che venissero riversati in un file di testo on-demand. Invece che scrivere un semplice script legato al contesto applicativo ho deciso di creare un mini driver piu' generale che permette un minimo di configurazione delle query e dei risultati. Ovviamente lo script Perl che propongo qui non è assolutamente un programma rock-solid, ma svolge abbastanza bene il suo compito; invito comunque chi abbia bisogno di estrazioni particolarmente complesse di costruire un qualche tipo di wrapper appositamente progettato.<br /><br />Anzitutto ho deciso che ogni utente avrebbe potuto aver bisogno di query leggermente differenti (viste sui dati diverse), e quindi il componente dovrebbe poter caricare dinamicamente la query usando una qualche proprietà di ambiente, quale ad esempio la home dell'utente. Inoltre le query non possono avere i dati di selezione staticamente impostati, ma ci deve essere un qualche meccanismo di templating delle query: si deve poter specificare il tipo di query che l'utente vuole svolgere e questa deve essere effettivamente svolta con parametri passati dinamicamente. Insomma, una sorta di "prepared statement" del poveraccio!<br />Si immagini quindi di avere un file di testo, nella home utente (o in un qualche altro percorso parametrizzabile) che contenga il template di query:</div><span style="font-size: x-small;"><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT pk, description</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">FROM&nbsp;&nbsp; test</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">WHERE description like '{0}'</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ORDER BY {1}</span></span><br /><br /><br /><div style="text-align: justify;">E' abbastanza ovvio che quello che si vuole ottenere è la sostituzione dei parametri posizionali {0} e {1} con valori reali e ottenuti dinamicamente all'atto dell'invocazione dell'estrattore. Segue lo script Perl che realizza questa funzione:</div><br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">#!/usr/bin/perl</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># variabili da utilizzare</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$DATABASE = "mydb";</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$HOST =&nbsp; "localhost";</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$MYSELF = "sqldump";</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$QUERY_FILE =&nbsp; $ENV{"HOME"} . "/$MYSELF" . "-" . "$DATABASE" . ".query";</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$OUTPUT_FILE =&nbsp; "/tmp/$MYSELF" . "-" . "$DATABASE" . ".txt";</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$INTERNAL_FIELD_SEPARATOR = ";";</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$FINAL_FIELD_SEPARATOR="\n";</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$FINAL_RECORD_SEPARATOR=$FINAL_FIELD_SEPARATOR;</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># lettura della query</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># La query puo' essere parametrizzata con dei marcaposto {0} {1} ecc.</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># Per ogni marcaposto ci deve essere un corrispondente parametro da linea di comando.</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">open( QUERY_FILE, "&lt;" . "$QUERY_FILE" ) || die("\nImpossibile leggere il file di query\n$!\n");</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">while( $queryLine = <query_file> ){</query_file></span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; chomp($queryLine);</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; if( $queryLine =~ /\{(\d)\}/ ){</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; $currentParam = $1;</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; $queryLine =~ s/\{$currentParam\}/$ARGV[$currentParam]/g;</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; }</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; </span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; $query .= $queryLine . " ";</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">}</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># Opzioni per l'esecuzione della query</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$PSQL_OPTIONS = " -c \"$query\" -A -d $DATABASE&nbsp; -F \'$INTERNAL_FIELD_SEPARATOR\' -h $HOST -t ";</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># esecuzione del comando</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">open( OUTPUT, "psql $PSQL_OPTIONS |" ) || die("\nImpossibile eseguire il comando\n$!\n");</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">open( OUTPUT_FILE, "&gt;" . $OUTPUT_FILE ) || die("\nImpossibile aprire il file in scrittura\n$!\n");</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">while( $sqlLine = <output> ){</output></span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; chomp( $sqlLine );</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; $sqlLine =~ s/$INTERNAL_FIELD_SEPARATOR/$FINAL_FIELD_SEPARATOR/g;</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; $sqlLine .= $FINAL_RECORD_SEPARATOR;</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; print OUTPUT_FILE $sqlLine;</span><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">}</span></span><br /><br /><div style="text-align: justify;">Lo script è piuttosto semplice (come la maggior parte del codice Perl che scrivo!). La prima parte si preoccupa di impostare alcune variabili per puntare correttamente al database, usare un determinato tipo di delimitatore di record e campo, e cercare il file template della query nonché impostare il file dump testuale che verrà prodotto.<br />La prima parte di codice si occupa di ricostruire un'unica stringa di query SQL analizzando riga per riga l'eventuale presenza di parametri posizionali ({0},{1}, ecc.) e sostituendoli con il relativo parametro da riga di comando nella medesima posizione. Se ad esempio lo script viene invocato con:</div><span style="font-size: x-small;"><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">sqldump.pl ciao description</span></span><br /><br />la query SQL risultante sarà:<br /><span style="font-size: x-small;"><br style="font-family: &quot;Courier New&quot;,Courier,monospace;" /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT pk, description FROM&nbsp;&nbsp; test WHERE description like 'ciao' ORDER BY description</span></span><br /><br /><div style="text-align: justify;">Ancora una volta vale la pena ribadire la semplicità di questo approccio, che ben si presta a tecniche di SQL injection e ad altri problemi di sicurezza; ne consiglio ancora una volta il solo utilizzo in ambienti sicuri e comunque controllati.<br />Una volta ottenuta la query on-demand si puo' procedere all'interrogazione del database mediante le proprieta' di comunicazione con la shell del comando psql. In particolare al comando viene chiesto di eseguire la query in modalità di output non allineato, con un separatore di campo temporaneo. L'output della query viene passato mediante pipe al processo Perl (quindi si ha una fork del processo stesso) cosi' da poter gestire anche grosse moli di dati in uscita e senza avere ritardi dovuti alla produzione di file temporanei. Ogni riga di output viene poi ripulita e il separatore di campo e record corretti vengono applicati per la produzione dell'output testuale finale.<br />L'esecuzione batch di questo semplice script richiede la configurazione del file .pgpass per l'accesso ai database senza richiesta di username e password.<br />Questo script, ampiamente migliorabile, mostra come sia possibile gestire elasticamente l'input/output di un database PostgreSQL anche quando si sia forzati a usare soluzioni legacy come i file di testo. Ovviamente è possibile migliorare lo script stesso con una serie pressoché infinita di opzioni di configurazione.</div>