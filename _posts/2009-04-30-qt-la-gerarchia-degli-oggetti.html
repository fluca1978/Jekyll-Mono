---
layout: post
title: 'Qt: la gerarchia degli oggetti'
date: '2009-04-30T08:10:00.003+02:00'
author: Luca Ferrari
tags:
- qt
- programmazione
modified_time: '2009-04-30T08:57:16.687+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-4774175212477129627
blogger_orig_url: http://fluca1978.blogspot.com/2009/04/qt-la-gerarchia-degli-oggetti.html
---

La libreria Qt prevede che ogni oggetto abbia un <span style="font-style: italic;">parent</span>, ossia un genitore responsabile della sua vita. Questa scelta è molto importante se si considera che Qt lavora in C++, dove la gestione della memoria è affidata al programmatore. Per ovviare alla proliferazione di oggetti "dimenticati" (e quindi memory leak), Qt adotta la scelta di organizzare gli oggetti a run-time in un albero, in modo che ogni oggetto sia sempre raggiungibile tramite un nodo padre (il <span style="font-style: italic;">parent</span> appunto). Avendo un albero di oggetti è possibile quindi eliminare un intero sottoalbero agendo sul nodo padre, ed è proprio quello che avviene in Qt: ogni volta che viene eliminato un <span style="font-style: italic;">parent</span> tutti i suoi figli sono eliminati. Questo significa che l'operazione di <span style="font-style: italic;">delete</span> su un oggetto Qt implicherà una <span style="font-style: italic;">delete</span> ricorsiva su tutti gli oggetti che hanno il primo come <span style="font-style: italic;">parent</span>.<br />Per gli sviluppatori della TrollTech, questa scelta è così importante che ogni oggetto Qt prevede, nel costruttore, un riferimento ad un oggetto padre, che diventerà il responsabile della distruzione dell'oggetto stesso.<br />A prima vista questo puo' sembrare un po' vincolante nel codice, infatti supponendo di avere un pannello al quale si vogliono aggiungere tre pulsanti, il codice appare come:<br /><br /><span style="font-style: italic;">QWidget* container = new QWidget();</span><br /><span style="font-style: italic;">QPushButton* b1 = new QPushButton("Pulsante 1", container);</span><br /><span style="font-style: italic;">QPushButton* b2 = new QPushButton("Pulsante 2", container);</span><br /><span style="font-style: italic;">QPushButton* b3 = new QPushButton("Pulsante 3", container);</span><br /><br />Come si nota, ogni oggetto contenuto (QPushButton) deve specificare il proprio <span style="font-style: italic;">parent </span>(in questo caso <span style="font-style: italic;">container</span>). Si noti che è possibile costruire un oggetto senza specificare il nodo padre, ed è poi possibile specificarlo in un secondo momento con il metodo <span style="font-style: italic;">setParent()</span>, ad ogni modo la scelta di includere il parent nel costruttore è una sottolineatura di come sia importante, nella gestione della memoria Qt, la costruzione dell'albero degli oggetti.<br /><br />Confrontando questo approccio con quello Java, si potrebbe storcere il naso, poiché quest'ultimo risulta piu' intuitivo da leggere. Il codice corrispondente all'aggiunta dei tre pulsanti ad un pannello risulta infatti:<br /><br /><span style="font-style: italic;">JPanel container = new JPanel();</span><br /><span style="font-style: italic;">JButton b1 = new JButton("Pulsante 1");</span><br /><span style="font-style: italic;">JButton b2 = new JButton("Pulsante 2");</span><br /><span style="font-style: italic;">JButton b3 = new JButton("Pulsante 3");</span><br /><span style="font-style: italic;">container.add( b1 );</span><br /><span style="font-style: italic;">container.add( b2 );</span><br /><span style="font-style: italic;">container.add( b3 );</span><br /><br />o anche in modo equivalente:<br /><br /><span style="font-style: italic;">JButton b1 = new JButton("Pulsante 1");</span><br /><span style="font-style: italic;"> JButton b2 = new JButton("Pulsante 2");</span><br /><span style="font-style: italic;"> JButton b3 = new JButton("Pulsante 3");</span><br /><span style="font-style: italic;">JPanel container = new JPanel();</span><br /><span style="font-style: italic;">container.add( b1 );</span><br /><span style="font-style: italic;"> container.add( b2 );</span><br /><span style="font-style: italic;"> container.add( b3 );</span><br /><br />La differenza rispetto all'approccio Qt è che in Java è possibile costruire i singoli componenti e aggiungerli semplicemente al contenitore in un secondo momento, mentre in Qt è necessario definire prima il contenitore e poi specificare, per ogni componente, dove questo deve essere contenuto. Se è vero che anche in Qt si sarebbe potuto scrivere:<br /><br /><br /><br /><span style="font-style: italic;"> QPushButton* b1 = new QPushButton("Pulsante 1");</span><br /><span style="font-style: italic;"> QPushButton* b2 = new QPushButton("Pulsante 2");</span><br /><span style="font-style: italic;"> QPushButton* b3 = new QPushButton("Pulsante 3");</span><br /><span style="font-style: italic;"> QWidget* container = new QWidget();</span><br /><span style="font-style: italic;">b1->setParent( container );</span><br /><span style="font-style: italic;">b2->setParent( container );</span><br /><span style="font-style: italic;">b3->setParent( container );</span><br /><br />è pur vero che questa tecnica è scarsamente usata e incoraggiata. La ragione risiede proprio in cio' che è stato detto prima: Qt forza la definizione della relazione fra gli oggetti fin dalla loro costruzione, al fine di impostare correttamente da subito la gestione futura della memoria.<br />Per meglio comprendere l'importanza di cio', si consideri il seguente esempio Java e il corrispettivo Qt (in stile Java):<br /><br /><span style="font-style: italic;">JButton b1 = new JButton("Pulsante 1");</span><br /><span style="font-style: italic;">  JButton b2 = new JButton("Pulsante 2");</span><br /><span style="font-style: italic;">  JButton b3 = new JButton("Pulsante 3");</span><br /><span style="font-style: italic;">  JPanel container = new JPanel();</span><br /><span style="font-style: italic;"> container.add( b1 );</span><br /><span style="font-style: italic;">  container.add( b2 );</span><br /><br />e in Qt stile Java:<br /><br /><span style="font-style: italic;">QPushButton* b1 = new QPushButton("Pulsante 1");</span><br /><span style="font-style: italic;">  QPushButton* b2 = new QPushButton("Pulsante 2");</span><br /><span style="font-style: italic;">  QPushButton* b3 = new QPushButton("Pulsante 3");</span><br /><span style="font-style: italic;">  QWidget* container = new QWidget();</span><br /><span style="font-style: italic;"> b1->setParent( container );</span><br /><span style="font-style: italic;"> b2->setParent( container );</span><br /><br />rispetto agli esempi di prima, qui vengono creati tre pulsanti, ma solo due sono effettivamente aggiunti al container, mentre il terzo viene "dimenticato". Ma se in Java scatta il garbage collector a recuperare la memoria del terzo pulsante, in C++ nulla del genere avviene, e siccome il terzo pulsante non ha nessun padre, non viene eliminato automaticamente mai, nemmeno quando il container cessa la sua vita. Ne consegue che così facendo si rischia di avere dei memory leak. Ecco quindi che Qt ovvia al problema imponendo, a tempo di costruzione degli oggetti, di specificare esattamente le relazioni che intercorrono fra di essi. Solo così l'albero degli oggetti puo' essere creato e mantenuto.<br /><br />Si noti poi che ogni Widget prevede, come valore di default, un puntatore nullo ad un parent widget. Come conseguenza, un widget puo' sempre essere costruito senza parent, anche se questo richiede maggiore attanzione al programmatore per la gestione della memoria.<br /><br />Da ultimo, Qt mette a disposizione una classe particolare QPointer, che agisce come un puntatore tipizzato ad un QObject. La differenza fra un QPointer e un puntatore normale è che il primo reagisce (tramite uno slot) quando il componente al quale punta viene cancellato. Infatti il QPointer viene azzerato (impostato a null), in modo da indicare che non punta piu' a nessun oggetto. Lo scopo è quello di consentire ad un programmatore di mantenere puntatori sicuri a oggetti nella gerarchia degli oggetti Qt, in modo che se un oggetto viene cancellato (poiché lo è il suo parent), il puntatore venga immediatamente invalidato.