---
layout: post
title: 'Perl 5 e le eccezioni: come funziona Try::Tiny'
date: '2017-01-19T05:20:00.000+01:00'
author: Luca Ferrari
tags:
- perl
modified_time: '2017-01-19T05:20:06.183+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-4544337325564053491
blogger_orig_url: http://fluca1978.blogspot.com/2017/01/perl-5-e-le-eccezioni-come-funziona.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<div style="text-align: justify;">Perl 5 non prevede un meccanismo di gestione del flusso delle eccezioni, pur prevedendo queste ultime, come altri linguaggi fanno, spesso ereditando da C++ i blocchi e gli operatori try/catch e similari.</div><div style="text-align: justify;">In Perl5 le eccezioni sono riportate come variabili globali, in particolare:</div><br /><ul><li><i>$! (errno)</i> contiene la versione numerica o stringa della variabile globale C-Unix errno(3);</li><li><i>$? (child error)</i> lo stato riportato dalla exit dell'ultimo sottoprocesso creato per pipe, backtick, chiamata a system (simile in questo alla stessa variabile della bourne shell);</li><li><i>$@ (eval error)</i> lo stato di errore dell'ultimo blocco eval eseguito.</li></ul><br /><div style="text-align: justify;">Unitamente a questo, Perl 5 prevede la funzione speciale "die" che solleva un'eccezione: se questo avviene nel programma principale questo termina (muore, da qui il nome), se invece si è in un blocco eval il blocco termina e la variabile globale $@ viene impostata a quanto specificato nell'eccezione. Da notare che è possibile passare anche un riferimento a "die", quindi anche un oggetto (eccezione) che viene poi assegnato alla variabile $@.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">L'uso di variabili globali per la gestione delle eccezioni non è certo ottimale, almeno nella programmazione OOP. Si rischia infatti che il sollevamento di una eccezione, in blocco annidato, faccia sollevare una nuova eccezione e quindi che la propagazione sia a piu' livelli e con cause differenti. Essendo $@ unica, solo l'ultimo livello di propagazione viene riportato. Non solo: essendo $@ globale si rischia che il suo valore sia resettato in punti inaspettati e quindi è necessario "ricordarsi" di analizzare $@ quanto prima possibile.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Sono quindi nati molti moduli su CPAN per la gestione delle eccezioni, e uno del quale parlare è Try::Tiny.</div><div style="text-align: justify;">Questo è un modulo molto semplice, non gestisce alcuni casi particolari (es. return in eval), ma fornisce comunque una sintassi "carina" e che ogni programmatore riesce a comprendere:</div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">try{</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">die "Argh!";</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">}</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">catch { say "Eccezione: $_"; };</span><br /><br /><div style="text-align: justify;">In particolare Try::Tiny imposta la variabile topic a $@ appena si entra nel blocco catch, permettendo quindi di dimenticarsi di $@ stessa. Ma come riesce a fare la magia della sintassi e a introdurre try-catch? Beh, ancora una volta entra in gioco la magia e la flessibilità di Perl 5.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Anzitutto si noti il ';' al termine del blocco catch: questo indica che in realtà si sta eseguendo una istruzione Perl 5 valida, o per meglio dire una funzione. E infatti Try::Tiny esporta tre funzioni che si chiamano "try", "catch" e "finally".</div><div style="text-align: justify;">Si consideri un estratto di "catch" prima:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">sub catch (&amp;;@) {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; my ( $block, @rest ) = @_;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; croak 'Useless bare catch()' unless wantarray;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">...</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; return (</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp; bless(\$block, 'Try::Tiny::Catch'),</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @rest,</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; );</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">}</span><br /><br /><br /><div style="text-align: justify;">Anzitutto la funzione accetta come primo parametro un blocco di codice o una sub (il carattere &amp; del prototipo), e si aspetta di essere chiamato in contesto di lista, quindi ad esempio come</div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">my ($catch) = ( catch { say "Eccezione: $_"; } );</span><br /><br />La fine della funzione catch converte il blocco di codice in un oggetto di tipo 'Try::Tiny::Catch', e questo serve per dei controlli interni.<br /><br />Vediamo brevemente la funzione "try", sicuramente piu' interessante:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">sub try (&amp;;@) {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; my ( $try, @code_refs ) = @_;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; my $wantarray = wantarray;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; my ( $catch, @finally ) = ();</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; foreach my $code_ref (@code_refs) {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp; if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; croak 'A try() may not be followed by multiple catch() blocks'</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp; if $catch;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; $catch = ${$code_ref};</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp; push @finally, ${$code_ref};</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; } else {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; croak(</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; 'try() encountered an unexpected argument ('</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . ( defined $code_ref ? $code_ref : 'undef' )</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">. &nbsp; &nbsp;&nbsp; ') - perhaps a missing semi-colon before or'</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; );</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; }</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">}</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">...</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; my $failed = not eval {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; $@ = $prev_error;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; &nbsp; # evaluate the try block in the correct context</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; &nbsp; if ( $wantarray ) {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; &nbsp; &nbsp; @ret = $try-&gt;();</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; &nbsp; } elsif ( defined $wantarray ) {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; &nbsp; &nbsp; $ret[0] = $try-&gt;();</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp; } else {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp; &nbsp;&nbsp; $try-&gt;();</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; };</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; return 1; # properly set $failed to false</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">};</span><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; $error = $@;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; $@ = $prev_error;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; if ( $failed ) {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp; ...</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; if ( $catch ) {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp; for ($error) {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $catch-&gt;($error);</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; }</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;}</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; return;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;} else {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; return $wantarray ? @ret : $ret[0];</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;}</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">}</span><br /><br /><div style="text-align: justify;">Anche qui la funzione si aspetta come primo argomento un blocco o una sub. Gli altri argomenti vengono trattati a loro volta come argomenti o sub, e si controlla nel primo loop che siano di tipo 'Try::Tiny::Catch', o finally o vengono considerati come alieni.</div><div style="text-align: justify;">Successivamente si esegue l'eval del blocco passato come primo argomento e, qualora questo abbia impostato un errore, si esegue anche il blocco catch passanto la variabile di errore come primo argomento.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Chiarito come avviene la magia sintattica di try-catch è possibile anche scrivere il blocco esplicitando le funzioni e i loro argomenti:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">try( sub { die "Eccezione!" },&nbsp;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp; catch( sub { say "Presa: $_" } ) );</span><br /><br /><div style="text-align: justify;">Ma come vengono gestiti i blocchi finally? Il meccanismo è abbastanza elegante: all'interno della funzione "try" vengono creati degli oggetti (blessed reference) per ogni blocco finally incontrato. Tali oggetti hanno un metodo DESTROY che invoca il code ref (blocco o funzione) specificato. Quando la funzione try termina gli oggetti vanno fuori visibilità e quindi vengono distrutti, e di conseguenza viene eseguito DESTROY che a sua volta richiama il codice specificato dall'utente.</div>