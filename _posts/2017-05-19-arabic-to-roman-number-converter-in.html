---
layout: post
title: Arabic to Roman number converter in Perl 5
date: '2017-05-19T19:52:00.000+02:00'
author: Luca Ferrari
tags:
- perl
- planet-perl-ironman
modified_time: '2017-05-19T19:52:08.899+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-2234430103447454159
blogger_orig_url: http://fluca1978.blogspot.com/2017/05/arabic-to-roman-number-converter-in.html
---

Puzzled by a post on the Planet KDE about <a href="http://rudranilbasu.github.io//blog/kde/2017/05/12/GCompris-updates-on-roman-numerals/">GCompris and roman numbers</a>,  and needing an easy way to explain to my six-years old son about roman  numbers, I thought it would be an easy task to make a simple program in  Perl to convert an arabic number into its roman notation.<br /> Not so easy, pal!<br /> Well, it's not a problem about Perl, of course, rather I found it  required a quite brainpower for me to write down rules to convert  numbers, and I did not search for the web for a <em>copy-and-paste</em> alghoritm. Please note: if you need a rock-solid way to handle conversions, have a look at <a href="http://search.cpan.org/search?query=roman&amp;mode=all">CPAN</a> that is full of modules for this particular aim.<br /> Here I'm going to discuss the solution I found and how I implemented  it. It is not supposed to be the best one, or the faster one, it's just <em>my</em> solution from scratch.<br /> <h1 id="the-program">The program</h1>I split the problem of converting an arabic number into a roman one  into three steps, with one dedicated subroutine for each step, so that  the main loop reduces to something like the following:<br /> <div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">say <span class="kw">"</span><span class="dt">$_</span><span class="st"> = </span><span class="kw">"</span> . <span class="dt">$roman_string</span>-&gt;( <span class="dt">$reassemble</span>-&gt;( <span class="dt">$disassemble</span>-&gt;( <span class="dt">$_</span> ) ) )<br />              <span class="kw">for</span> ( <span class="dv">1</span>..<span class="dv">30</span> );</code></pre></div>that produces the following output:<br /> <pre><code>1 = I<br />2 = II<br />3 = III<br />4 = IV<br />5 = V<br />6 = VI<br />7 = VII<br />8 = VIII<br />9 = IX<br />10 = X<br />11 = XI<br />12 = XII<br />13 = XIII<br />14 = XIV<br />15 = XV<br />16 = XVI<br />17 = XVII<br />18 = XVIII<br />19 = XIX<br />20 = XX<br />21 = XXI<br />22 = XXII<br />23 = XXIII<br />24 = XXIV<br />25 = XXV<br />26 = XXVI<br />27 = XXVII<br />28 = XXVIII<br />29 = XXIX<br />30 = XXX<br /></code></pre>The steps must be read from the inner subroutine to the outer, of course, and therefore we have:<br /> <ul><li><code>disassemble</code> that translates an arabic number into roman  basis, that is computes how many units, tens, hundreds and thousands  are required. In this phase there is no application of roman rules, so  numbers are decomposed into a <em>linear</em> string of letters. As an example the number <code>4</code> is translated into <code>IIII</code>, which is of course a non-existent roman number.</li><li><code>reassemble</code> applies roman rules, in particular <em>promoting</em> numbers so that groups are translated, when needed, into higher order letters. For instance <code>IIII</code> is promoted into two groups: <code>I</code> and <code>V</code>.</li><li><code>roman_string</code> compose the promoted groups into the final  string. The main difficulty of this part is to understand when a letter  has to be placed on the right (addition) or on the left (subtraction)  of another letter. For instance, having the groups <code>I</code> and <code>V</code> the function must understand if the output have to be <code>VI</code> (6) or <code>IV</code> (4).</li></ul>To speed up the writing of the code, I placed main roman letters and their correspondance with arabic numbers into a <em>global</em> hash:<br /> <div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="kw">my</span> <span class="dt">$roman</span> = {<br />    <span class="dv">1</span>    =&gt; <span class="kw">'</span><span class="st">I</span><span class="kw">'</span>,<br />    <span class="dv">5</span>    =&gt; <span class="kw">'</span><span class="st">V</span><span class="kw">'</span>,<br />    <span class="dv">10</span>   =&gt; <span class="kw">'</span><span class="st">X</span><span class="kw">'</span>,<br />    <span class="dv">50</span>   =&gt; <span class="kw">'</span><span class="st">L</span><span class="kw">'</span>,<br />    <span class="dv">100</span>  =&gt; <span class="kw">'</span><span class="st">C</span><span class="kw">'</span>,<br />    <span class="dv">500</span>  =&gt; <span class="kw">'</span><span class="st">D</span><span class="kw">'</span>,<br />    <span class="dv">1000</span> =&gt; <span class="kw">'</span><span class="st">M</span><span class="kw">'</span>,<br />};</code></pre></div>Each method references <code>$roman</code> when needing to convert  from an arabic number to its roman letter. In order to allow method to  cooperate together, they accept and return an hash keyed by a roman  letter and the number of occurences such letter must appear in the final  string. The following is an example of the hash for a few numbers:<br /> <div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="co"># 4 (IV)</span><br />{ <span class="kw">'</span><span class="st">I</span><span class="kw">'</span> =&gt; <span class="dv">1</span>, <span class="kw">'</span><span class="st">V</span><span class="kw">'</span> =&gt; <span class="dv">1</span> }<br /><span class="co"># 19 (XIX)</span><br />{ <span class="kw">'</span><span class="st">I</span><span class="kw">'</span> =&gt; <span class="dv">1</span>, <span class="kw">'</span><span class="st">X</span><span class="kw">'</span> =&gt; <span class="dv">2</span> }<br /><span class="co"># 5 (V)</span><br />{ <span class="kw">'</span><span class="st">V</span><span class="kw">'</span> =&gt; <span class="dv">1</span> }<br /><span class="co"># 17 (XVII)</span><br />{ <span class="kw">'</span><span class="st">X</span><span class="kw">'</span> =&gt; <span class="dv">1</span>, <span class="kw">'</span><span class="st">V</span><span class="kw">'</span> =&gt; <span class="dv">1</span>, <span class="kw">'</span><span class="st">I</span><span class="kw">'</span> =&gt; <span class="dv">2</span> }</code></pre></div><h1 id="the-disassemble-function">The <code>disassemble</code> function</h1>The following is the code for the <code>disassemble</code> function, that accepts as only input the arabic number.<br /> <div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="co"># Accepts the arabic number and provides an hash</span><br /><span class="co"># keyed by each letter, with the value of how many times</span><br /><span class="co"># such letter should be summed in order to obtain the</span><br /><span class="co"># starting number.</span><br /><span class="kw">my</span> <span class="dt">$disassemble</span> = <span class="kw">sub</span>{<br />    <span class="kw">my</span> ( <span class="dt">$number</span> ) = <span class="dt">@_</span>;<br />    <span class="kw">my</span> <span class="dt">$items</span> = {};<br /><br />    <span class="co"># sort the keys, that are arabic thresolds, from</span><br />    <span class="co"># the greater to the smaller one</span><br />    <span class="kw">for</span> <span class="kw">my</span> <span class="dt">$current_value</span> ( <span class="fu">sort</span> { <span class="dt">$b</span> &lt;=&gt; <span class="dt">$a</span> } <span class="fu">keys</span> <span class="dt">$roman</span>-&gt;<span class="dt">%</span><span class="kw">*</span> ){<br /><br />        <span class="kw">my</span> <span class="dt">$how_many</span> = <span class="fu">int</span>( <span class="dt">$number</span> / <span class="dt">$current_value</span> );<br />        <span class="kw">next</span> <span class="kw">unless</span> ( <span class="dt">$how_many</span> );<br /><br />        <span class="kw">my</span> <span class="dt">$letter</span> = <span class="dt">$roman</span>-&gt;<span class="dt">%</span>{ <span class="dt">$current_value</span> };<br />        <span class="dt">$items</span>-&gt;{ <span class="dt">$letter</span> } = <span class="dt">$how_many</span>;<br /><br />        <span class="dt">$number</span> -= <span class="dt">$current_value</span> <span class="kw">*</span> <span class="dt">$how_many</span>;<br />    }<br /><br />    <span class="kw">return</span> <span class="dt">$items</span>;<br />};</code></pre></div>The first thing the method does it to create the hash <code>$items</code> that is what it will return to allow other methods to consume. Each key of the <code>$roman</code> hash is passed ordered by the bigger to the smaller (please note that <code>sort</code> has <code>$b</code> first!). In this way we can surely scompose the number from the thousands, hundreds, tens, and units in this exact order. The <code>$how_many</code> variable contains the integer part of each letter. For example the number <code>29</code> is processed as follows:<br /> <ol><li><code>29 / 10</code> that drives <code>$how_many</code> to be <code>2</code> and the remaining to be a <code>9</code>;</li><li><code>9 / 5</code> that makes <code>$how_many</code> to be <code>1</code> and the remaining to be a <code>4</code>;</li><li><code>4 / 1</code> that makes <code>$how_many</code> to be <code>4</code> and there's nothing more to do.</li></ol>At each step the roman letter and the <code>$how_many</code> value is inserted into the <code>$items</code> has, that in the above ecample becomes:<br /> <div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="co"># 29 (XIX)</span><br />{ <span class="kw">'</span><span class="st">X</span><span class="kw">'</span> =&gt; <span class="dv">2</span>,<br />  <span class="kw">'</span><span class="st">V</span><span class="kw">'</span> =&gt; <span class="dv">1</span>,<br />  <span class="kw">'</span><span class="st">I</span><span class="kw">'</span> =&gt; <span class="dv">4</span><br />}</code></pre></div><h1 id="the-reassemble-method">The <code>reassemble</code> method</h1>The <code>reassemble</code> method takes as input the hash produced by <code>disassemble</code> and checks if any letter requires a promotion. Here it is the code:<br /> <div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="co"># Accepts an hash with keys the letters and values the number</span><br /><span class="co"># of times each letter should appear.</span><br /><span class="co"># Traverse the hash from the smaller to the greater</span><br /><span class="co"># in order to "promote" smaller aggregates. For instance</span><br /><span class="co"># 'IIII' (4) is aggregated and therefore the hash is modified</span><br /><span class="co"># so there's only an 'I' and another 'V', in such case</span><br /><span class="co"># the quantity of the promoted letter is negative to indicate</span><br /><span class="co"># it has been promoted.</span><br /><span class="kw">my</span> <span class="dt">$reassemble</span> = <span class="kw">sub</span>{<br />    <span class="kw">my</span> ( <span class="dt">$items</span> ) = <span class="dt">@_</span>;<br />    <span class="kw">my</span> <span class="dt">@sorted_thresolds</span> = <span class="fu">sort</span> { <span class="dt">$a</span> &lt;=&gt; <span class="dt">$b</span> } <span class="fu">keys</span> <span class="dt">$roman</span>-&gt;<span class="dt">%*;</span><br /><br />    <span class="kw">for</span> ( <span class="kw">my</span> <span class="dt">$i</span> = <span class="dv">0</span>; <span class="dt">$i</span> &lt; <span class="dt">@sorted_thresolds</span>; <span class="dt">$i</span>++ ){<br />        <span class="kw">my</span> <span class="dt">$current_value</span> = <span class="dt">$sorted_thresolds</span>[ <span class="dt">$i</span> ];<br />        <span class="kw">my</span> <span class="dt">$key</span>      = <span class="dt">$roman</span>-&gt;<span class="dt">%</span>{ <span class="dt">$current_value</span> };<br />        <span class="kw">my</span> <span class="dt">$how_many</span> = <span class="dt">$items</span>-&gt;<span class="dt">%</span>{ <span class="dt">$key</span> };<br /><br />        <span class="kw">next</span> <span class="kw">unless</span> ( <span class="dt">$how_many</span> );<br /><br />        <span class="kw">my</span> <span class="dt">$greater_value</span> = ( <span class="dt">$i</span> + <span class="dv">1</span> &gt; <span class="dt">@sorted_thresolds</span> ? <span class="dv">1000</span> : <span class="dt">$sorted_thresolds</span>[ <span class="dt">$i</span> + <span class="dv">1</span> ] );<br />        <span class="kw">my</span> <span class="dt">$greater_key</span>   = <span class="dt">$roman</span>-&gt;<span class="dt">%</span>{ <span class="dt">$greater_value</span> };<br /><br /><br />        <span class="kw">my</span> <span class="dt">$need_to_promote</span> = <span class="dt">$how_many</span> == <span class="dv">4</span><br />            || ( <span class="dt">$greater_value</span> / <span class="dt">$current_value</span> == <span class="dt">$how_many</span> );<br /><br />        <span class="kw">if</span> ( <span class="dt">$need_to_promote</span> ){<br />            <span class="dt">$items</span>-&gt;{ <span class="dt">$greater_key</span> }++;<br />            <span class="dt">$how_many</span> = <span class="dt">$greater_value</span> - <span class="dt">$how_many</span> <span class="kw">*</span> <span class="dt">$current_value</span>;<br />            <span class="dt">$items</span>-&gt;{ <span class="dt">$key</span> } = <span class="dt">$how_many</span> <span class="kw">*</span> -<span class="dv">1</span>;<br /><br />        }<br /><br />    }<br /><br />    <span class="kw">return</span> <span class="dt">$items</span>;<br />};</code></pre></div>The <em>promotion</em> must be done from the smaller letter to the greater one, so this time the letters are walked in ascending order (i.e., <code>sort</code> has <code>$a</code> first!). Since to promote a letter I need to access the following one, I need a C-style <code>for</code> loop.<br /> A letter requires to be promoted if its quantity is <code>4</code> or /it is 2 and the right bigger value is exactly the double of the current one~, that is while <code>( $greater_value / $current_value == $how_many )</code>. This makes, for instance <code>IIII</code> to be promoted (the quantity is 4), and <code>VV</code> to be promoted into <code>X</code> (because the quantity is 2 and the <code>X</code> is exactly the double of <code>V</code>).  The promotion manipulates the hash increasing by one the right bigger  letter and leaving a single current letter. In order to flag the  promoted letter, I decided to use a negative quantity (where the  absolute value is the exact one).<br /> So for instance, the 29 hash of the previous paragraph is passed as follows:<br /> <div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="co"># input to the method</span><br />{ <span class="kw">'</span><span class="st">X</span><span class="kw">'</span> =&gt; <span class="dv">2</span>,<br />  <span class="kw">'</span><span class="st">V</span><span class="kw">'</span> =&gt; <span class="dv">1</span>,<br />  <span class="kw">'</span><span class="st">I</span><span class="kw">'</span> =&gt; <span class="dv">4</span><br />}<br /><br /><br /><span class="co"># first for step (I)</span><br />{ <span class="kw">'</span><span class="st">X</span><span class="kw">'</span> =&gt; <span class="dv">2</span>,<br />  <span class="kw">'</span><span class="st">V</span><span class="kw">'</span> =&gt; <span class="dv">2</span>,<br />  <span class="kw">'</span><span class="st">I</span><span class="kw">'</span> =&gt; -<span class="dv">1</span>  <span class="co"># promoted, keep 1 and increase 'V'</span><br />}<br /><br /><span class="co"># second step (V)</span><br />{ <span class="kw">'</span><span class="st">X</span><span class="kw">'</span> =&gt; <span class="dv">3</span>,<br />  <span class="kw">'</span><span class="st">V</span><span class="kw">'</span> =&gt; <span class="dv">0</span>,  <span class="co"># promoted, increase X by one</span><br />  <span class="kw">'</span><span class="st">I</span><span class="kw">'</span> =&gt; -<span class="dv">1</span><br />}</code></pre></div>At the end of method we know the final string will be made by three <code>X</code> and one <code>I</code>, the point now is to understand how to render them in the correct order. This is the aim of the <code>roman_string</code> method.<br /> <h1 id="the-roman_string-method">The <code>roman_string</code> method</h1>The method accepts the normalized hash (i.e., groups are already  formed) and compose the final string placing letter on the left or the  right of each other depending on their quantity. The following is the  code of the method:<br /> <div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="co"># Do the hard work of composing</span><br /><span class="co"># each group of letters in order to compose the roman string.</span><br /><span class="kw">my</span> <span class="dt">$roman_string</span> = <span class="kw">sub </span>{<br />    <span class="kw">my</span> ( <span class="dt">$items</span> ) = <span class="dt">@_</span>;<br />    <span class="kw">my</span> <span class="dt">@chars</span>;<br /><br />    <span class="kw">for</span> <span class="kw">my</span> <span class="dt">$current_value</span> ( <span class="fu">sort</span> { <span class="dt">$b</span> &lt;=&gt; <span class="dt">$a</span> } <span class="fu">keys</span> <span class="dt">$roman</span>-&gt;<span class="dt">%</span><span class="kw">*</span> ){<br />        <span class="kw">my</span> <span class="dt">$letter</span>   = <span class="dt">$roman</span>-&gt;<span class="dt">%</span>{ <span class="dt">$current_value</span> };<br />        <span class="kw">my</span> <span class="dt">$how_many</span> = <span class="dt">$items</span>-&gt;<span class="dt">%</span>{ <span class="dt">$letter</span> };<br /><br />        <span class="kw">next</span> <span class="kw">unless</span> ( <span class="dt">$how_many</span> );<br /><br /><br />        <span class="kw">if</span> ( <span class="dt">$how_many</span> &gt; <span class="dv">0</span> ){<br />            <span class="fu">push</span> <span class="dt">@chars</span>, <span class="dt">$letter</span> <span class="kw">for</span> ( <span class="dv">1</span> .. <span class="dt">$how_many</span> );<br />        }<br />        <span class="kw">else</span>{<br />            <span class="co"># this is promoted, so it has to be inserted as last-to-last</span><br />            <span class="co"># in the previous chain</span><br />            <span class="co"># example: @chars( X, X ) and here I've 'I' to make XIX (19)</span><br />            <span class="fu">push</span> <span class="dt">@chars</span>, ( <span class="dt">$letter</span>, <span class="fu">pop</span> <span class="dt">@chars</span> );<br />        }<br /><br />    }<br /><br />    <span class="kw">return</span> <span class="fu">join</span> <span class="kw">""</span>, <span class="dt">@chars</span>;<br />};</code></pre></div>In order to be able to manipulate easily the final string, moving  letters from left to right and vice-versa, I decided to place each  single letter into the <code>@chars</code> array, that is then <code>join</code> -ed into a single string.<br /> Let's suppose we need just to add letters: in this case we need to  write letters from the greater to the smaller from left to right, and  this is the order I traverse the letters of <code>$roman</code> (again, note that <code>sort</code> has <code>$b</code> first!). If the quantity of the letter is positive <em>the letter has not been promoted</em> and therefore it will not be placed to the left of another letter, so just insert into <code>@chars</code> the <code>$letter</code> for the <code>$how_many</code> quantity. On the other hand, if <code>$how_many</code> is negative, the letter has been promoted and therefore have to be  printed on the left of the last printed letter. This is as easy as  doing:<br /> <code>push @chars, ( $letter, pop @chars );</code><br /> that inserts into <code>@chars</code> the <code>$letter</code> and the previous last character that has been removed via <code>pop</code>.<br /> With regards to the previous example of <em>29</em> we have that:<br /> <div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="co"># method input</span><br />{ <span class="kw">'</span><span class="st">X</span><span class="kw">'</span> =&gt; <span class="dv">3</span>,<br />  <span class="kw">'</span><span class="st">I</span><span class="kw">'</span> =&gt; -<span class="dv">1</span><br />}<br /><br /><span class="co"># first step: prints X</span><br /><span class="co"># with quantity 3 (not promoted)</span><br /><span class="dt">@chars</span> = ( <span class="kw">'</span><span class="st">X</span><span class="kw">'</span>, <span class="kw">'</span><span class="st">X</span><span class="kw">'</span>, <span class="kw">'</span><span class="st">X</span><span class="kw">'</span> );<br /><br /><span class="co"># second step: prints I</span><br /><span class="co"># that has been promoted</span><br /><span class="co"># and must be inserted ascending</span><br /><span class="co"># as last-to-last</span><br /><span class="dt">@chars</span> = ( <span class="kw">'</span><span class="st">X</span><span class="kw">'</span>, <span class="kw">'</span><span class="st">X</span><span class="kw">'</span> ,<br />           ( <span class="kw">'</span><span class="st">I</span><span class="kw">'</span>, <span class="co"># $letter</span><br />             <span class="kw">'</span><span class="st">X</span><span class="kw">'</span>  <span class="co"># pop @chars</span><br />         ) );</code></pre></div><h1 id="conclusions">Conclusions</h1>Well, it has been much code that I expected to write. Using an object  notation, instead of plain hashes, could surely make the program more  robust. I'm pretty sure there's a way to shrink the code down and to  avoid that ugly C-style <code>for</code> loop, as well as the promotion  part could be simplified keeping in mind that it often reduces to -1 for  the current letter and +1 for the greater one. Anyway, it does what I  need and seems correct!