---
layout: post
title: Riflessioni su pl/java
date: '2017-06-25T14:40:00.000+02:00'
author: Luca Ferrari
tags:
- postgresql
- java
modified_time: '2017-06-25T14:40:00.170+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-2352374834108744874
blogger_orig_url: http://fluca1978.blogspot.com/2017/06/riflessioni-su-pljava.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


Bruce Momjian ha pubblicato un <a href="https://momjian.us/main/blogs/pgblog/2017.html#June_16_2017">breve articolo circa l'adozione di pl/Java</a>.<br />I linguaggi <code>pl/</code> sono una serie di <i>bindings</i> per utilizzare un linguaggio di programmazione differente dal "plain" SQL all'interno di una istanza PostgreSQL, ovvero lato server.<br />Pertanto <code>pl/java</code> altro non è che un binding per poter utilizzare il linguaggio Java direttamente all'interno del server PostgreSQL, ad esempio per la costruzione di trigger o stored procedures. Io stesso ho utilizzato in passato <code>pl/java</code> in produzione, e ho anche tenuto dei mini corsi e dei seminari sul suo utilizzo (si <a href="http://confsl.org/confsl10/pdf/slides/ws_pg_LFerrrari-PostgreSQL-Java.pdf">veda ad esempio qui</a>), nonché ho provato a <a href="http://fluca1978.blogspot.it/2010/06/pljava-patch-per-cancellare-loperazione.html">contribuire a minime porzioni di codice</a>.<br /><br /><br />Pl/Java risulta abbastanza ostico rispetto ad altri linguaggi <code>pl/</code>, e ciò è dovuto alla natura di Java (non certo ai suoi limiti), in particolare alla fase di compilazione che richiede sempre:<br /><br /><ul class="org-ul"><li>un deploy di una forza compilata del codice;<br /></li><li>un pezzo di codice <i>collante</i> SQL che possa "iniettare" le funzionalità Java dentro al server PostgreSQL.<br /></li></ul><br />Pl/Java si basa per scelta progettuale su <i>Java Native Interface (JNI)</i>, scelta abbastanza efficiente se si considera che il codice deployato risulta locale al server cluster e quindi non è necessario utilizzare chiamate remote (es. RMI). In modo coerente con le scelte architetturali di PostgreSQL, <code>pl/java</code> utilizza una virtual machine backend per ogni processo attivo, richiedendo quindi dei tempi di startup piuttosto lunghi (o diciamo piu' lunghi rispetto ad altri <code>pl/</code>).<br /><br /><br />L'implementazione di <code>pl/java</code> è elegante e interessante, permette la sincronizzazione dei thread su un mutex singolo e consente di interagire con gli oggetti di backend arrivando perfino a implementare una sorta di SQL MED del poveraccio.<br /><br /><br />Eppure <code>pl/java</code> non <i>sfonda</i>, come nota appunto Bruce nel suo articolo.<br /><br /><br />Avendolo usato in produzione posso affermare che <code>pl/java</code> è fortemente condizionato dalla competizione con altri linguaggi <code>pl</code>, in particolare quelli di scripting. Effettivamente io stesso, ad un certo punto, ho modificato porzioni di codice abbastanza sostanziose per passare da <code>pl/java</code> a <code>pl/perl</code>. Ovviamente ciò è stato possibile perché potevo scrivere codice in entrambi i linguaggi, competenza non sempre presente, e l'esigenza principale è stata quella di dover garantire una modifica <i>on-the-fly</i> al codice sorgente anche quando non fosse disponibile un ambiente di sviluppo completo. Detto in due parole: per usare <code>pl/java</code> occorre impostare un progetto (Eclipse o similare), compilare, deployare e "iniettare" il codice nel backend, in <code>pl/perl</code> basta un editor di testo per modificare il codice e la fase di deploy si riduce ad iniettare il codice nel backend.<br /><br /><br />Personalmente ritengo che <code>pl/java</code> sia uno strumento interessante e importante, e che la sua adozione in contesti fortemente Java-based (per competenze, librerie, stack) sia opportuna, ma solo da un punto di vista degli sviluppatori. Difficilmente un DBA utilizzerà <code>pl/java</code> per implementare le proprie logiche di controlle server-side.<br />