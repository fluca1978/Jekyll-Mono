---
layout: post
title: Avoid downcast!
date: '2012-01-25T17:57:00.000+01:00'
author: Luca Ferrari
tags:
- programming best practice
modified_time: '2012-01-25T17:57:00.312+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-4425745150444605775
blogger_orig_url: http://fluca1978.blogspot.com/2012/01/avoid-downcast.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


Who has never written a piece of code like the following (pseudo Java)?<br /><span style="font-size: x-small;"><br /></span><br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">if( myObject instanceof BASE )</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">&nbsp; ((BASE) myObject).doBaseBehavior();</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">else if( myObject instanceof DERIVED1 )</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">&nbsp; ((DERIVED1) myObject).doDerivedBehavior1();</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">else if( myObject instanceof DERIVED2 )</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">&nbsp; ((DERIVED2) myObject).doDerivedBehavior2();</span></div><br />It is called <i>downcast</i> and is the opposite of the <i>Liskov Substitution Principle</i>. The idea is that, at run-time, you have to invoke a specialized behavior through a generic base class. Now, read the sentence again and emphasize the words "specialized", "through" and "generic". Note the order of such words: it is not correct! While it is true that a <u>specialized</u> implementation should offer a <u>generic</u> behavior, this does not mean that you can change ordering to the words and obtain something that can work. "Hey, Java offers <i>instanceof</i> operator and C++ offers <i>dynamic_cast</i>"&nbsp; - I hear you screaming that. And so what? Do you think that just because there is such an operator in your language you should use in such a way? Not at all!<br />What happens when you are going to add a new derived subclass? You have to add another branch to your selection statement. That is a really bad looking piece of code, and trust me, sooner or later, you will forget to add such a branch and find your code is buggy.<br /><div style="text-align: justify;">I've seen this code more and more in every kind of project, and it seems to be nested also in libraries, especially commercial ones (at least this is my experience). You have to avoid this kind of programming. Let consider again your problem and create more abstractions, since what you are really expressing with the above code is that a few instances are pretty the same except for a single behavior. So they are not the same, do not manage them as they could be considered the same, or generalize such behavior so that all instances have the same common interface or prototype and are free to implement it as they need. So that instead of <i>downcasting</i> an instance you are simply casting it at one of its generic interfaces:</div><br /><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">if( myObject instanceof MyPrototype )</span></div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-size: x-small;">&nbsp; ((MyPrototype) myObject).doBehavior();</span></div><br /><div style="text-align: justify;">Interestingly my experience is that this kind of programming template (I would not call it a pattern!) arises from a bad comprehension of the <i>factory</i> pattern: you have a factory that creates different instances of the same interface, but since your interface lacks of specialization and you don't have the control on which implementation is going to be created, you try to downcast it. Again, this is not the solution, or at least, it is a solution that could work in the short term, but that you need to refactor to have robust code.</div><div style="text-align: justify;">Finally, please consider that while doing <i>casting</i> the language operators are usually smart enough to inform you about an error in the cast. For instance, the <i>dynamic_cast</i> operator returns 0 if the cast was impossible. Similarly the <i>instanceof</i> operator returns false if the object is null. Take advantage of this information to write better quality code!</div>