---
layout: post
title: 'Hangman in Perl 5: a simple example'
date: '2016-11-12T15:55:00.000+01:00'
author: Luca Ferrari
tags:
- perl
- planet-perl-ironman
modified_time: '2016-11-12T15:55:10.373+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-4779627525243229756
blogger_orig_url: http://fluca1978.blogspot.com/2016/11/hangman-in-perl-5-simple-example.html
---

<div style="text-align: justify;">Inspired by an article on <a href="http://blogs.perl.org/">blogs.perl.org</a> I decided to write down a small version of the hangman game using Perl 5.</div><div style="text-align: justify;">It was interesting and quite nice.</div><div style="text-align: justify;">Here it is my version, with an eye on italian words (wovels marked as '+' on the guessing line), find it only on <a href="https://github.com/fluca1978/fluca1978-coding-bits/blob/master/perl/hangman.pl">GitHub</a>.</div><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">#!/usr/bin/env perl</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">use v5.10;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">use Term::ReadKey;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">my $word;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"># search for a word</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">open my $word_fh, '&lt;', '/usr/share/dict/words' || die "\nCannot read words!\n$!\n";</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">srand;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">rand( $. ) &lt; 1 &amp;&amp; ( $word = lc( ( split( /[\s']/, $_ ) )[ 0 ] ) ) while( &lt;$word_fh&gt; );</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">close $word_fh;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"># wovels converted to +</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">my ( %guess_status ) = map { $_ &nbsp;, ( /[aeiouÃ¨Ã©Ã²Ã Ã¹Ã¬]/ ? '+' : '_' ) } ( split // , $word );</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">my $current_guessing = '';</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">my $max_trials &nbsp; &nbsp; &nbsp; = 10;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">my @wrong_chars &nbsp; &nbsp; &nbsp;= ();</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">ReadMode 3; # allow for signals</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"># while there are undiscovered chars or other trials to do, go for it!</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">while( grep( /[+_]/, &nbsp;values %guess_status ) &amp;&amp; &nbsp;$max_trials &gt; 0 ){</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; # build the guessing line</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; $current_guessing = join ' ' , map { $guess_status{ $_ } } ( split // , $word );</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; say "\n\n|| $current_guessing ||\t" . join( ',', @wrong_chars );</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; say "guess a char: ";</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; my $current_char = lc ReadKey( 0 );</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; if ( ! $guess_status{ $current_char } ){</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; # not guessed</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; $max_trials--;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; push @wrong_chars, $current_char;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; say "No [$current_char] in the word, you still have $max_trials trials.";</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; }</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; else{</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; say "You guessed right [$current_char]!";</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; $guess_status{ $current_char } = $current_char;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; }</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">say "You guessed [$word] !\n" if ( $max_trials &gt; 0 );</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">say "Sorry, the word you were looking for was [$word]\n" if ( ! $max_trials );</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">ReadMode 0;</span><br /><br /><br /><br /><br /><div style="text-align: justify;">First of all, I read in a random word from a words file, using a quite well know "read-radom-line" approach (at least it is well documented in the Perl community, see <http: node_id="1910" www.perlmonks.org="">). Since the dictionary could contain multiple words per line, I cut them taking only the first one of them and excluding also shortings, and of course making the whole result lower case for ease of comparison. In other words something like "Bud's" become simply "bud", something like "Smooth words" become simply "smooth" and so on.</http:></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">The selected word is split into its chars and each char is mapped either to a '+' or a '_'. The result is placed into an hash indexed by the plain char itself, so that the word 'hello' results in an hash as follows:</div><div style="text-align: justify;"><br /></div><span style="font-family: Courier New, Courier, monospace;">%guess_status = {</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; h =&gt; '_',</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; e =&gt; '+',</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; l =&gt; '_',</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; l =&gt; '_',</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; o =&gt; '+',</span><br /><span style="font-family: Courier New, Courier, monospace;">}</span><br /><br /><div style="text-align: justify;">(of course the hash is not sorted on the keys, and that does not matter).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Now the main loop: unless no more '+' or '_' are present in the hash, meaning that the user has guessed all occuriences of all chars, the user is prompted with the guessing line and asked for a char. I use Term::ReadKey for getting a single char, that is of course lowered and compared against the hash keys. If the current char is a key for the hash, the character is discovered and the guessing line re-prompted with the right character in the right place(s), otherwise the character is appended to an array of missed chars and the loop continues.</div><div style="text-align: justify;">Each time the user inputs a wrong char a counter is decreased to allow the game to stop in a fixed number of missed trials.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">There is of course a lot of room for improvements: for instance the guessing line does not need to be updated each time, but only when the user guesses a char. Therefore a little different version of the main loop becomes as follows:</div><div style="text-align: justify;"><br /></div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">$current_guessing = join ' ' , map { $guess_status{ $_ } } ( split // , $word );</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">while( $current_guessing =~ /[+_]/ &amp;&amp; &nbsp;$max_trials &gt; 0 ){</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; say "\n\n|| $current_guessing ||\t" . join( ',', @wrong_chars );</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; say "guess a char: ";</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; my $current_char = lc ReadKey( 0 );</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; if ( ! $guess_status{ $current_char } ){</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; # not guessed</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; $max_trials--;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; push @wrong_chars, $current_char;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; say "No [$current_char] in the word, you still have $max_trials trials.";</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; }</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; else{</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; say "You guessed right [$current_char]!";</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; $guess_status{ $current_char } = $current_char;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; # build the guessing line</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; $current_guessing = join ' ' , map { $guess_status{ $_ } } ( split // , $word );</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; }</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><br /><div style="text-align: justify;">where the guessing line is updated only when a good character is inserted. Having the guessing line built before the main loop allows me for searching directly for undiscovered chars in the line itself, instead of among the values of the hash (so avoiding a grep() applied to a values() ).</div><div style="text-align: justify;">And in the case you are wondering why I don't compare the guessin line against the word to guess in the while condition, well, it is because I like to print the guessing line with spaces between letters to be guessed.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Hope it can be useful as simple base Perl program for someone!</div><div style="text-align: justify;"><br /></div>