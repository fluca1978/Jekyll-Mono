---
layout: post
title: Diversi modi di correlare i dati in un contenitore
date: '2009-04-23T12:50:00.014+02:00'
author: Luca Ferrari
tags:
- università
- programmazione
- java
modified_time: '2009-04-26T14:39:42.746+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-2087187542403266072
blogger_orig_url: http://fluca1978.blogspot.com/2009/04/diversi-modi-di-correlare-i-dati-in-un.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


Con questo articolo voglio prendere in considerazione, da un punto di vista didattico, i diversi modi messi a disposizione da Java per correlare fra di loro i dati di una collezione.<br /><br />Si consideri il caso di una serie di <span style="font-style: italic;">articoli</span> da inserire in appositi <span style="font-style: italic;">scaffali</span>. La programmazione OOP ci insegna che <span style="font-style: italic;">Articolo</span> e <span style="font-style: italic;">Scaffale</span> devono essere modellati come classi poiché sono astrazioni di dato. Ma come mettiamo in relazione le istanze delle due classi? Ovvero, come implementiamo il legame secondo il quale uno scaffale contiene uno o piu' articoli? Il problema puo' essere risolto banalmente con una <span style="font-style: italic;">Collection</span>, ad esempio una lista, contenuta in <span style="font-style: italic;">Scaffale</span> e che a sua volta contiene degli elementi <span style="font-style: italic;">Articolo</span>:<br /><br /><span style="font-style: italic;">public class Scaffale{<br />      ...<br />      List<articolo>&lt;Articolo&gt; articoli = ...<br />      ...<br />}<br /><br /></articolo></span>Nessun problema fino a quando la relazione scaffale-articolo non deve essere arricchità di nuove informazioni. Consideriamo ad esempio che si debba anche memorizzare la quantità di ogni articolo memorizzato in uno scaffale. Diverse soluzioni sono possibili al problema, e nel seguito le tratto una ad una con pregi e diffetti.<span style="font-style: italic;"><br /><br /></span><span style="font-weight: bold;">Implementazione delle informazioni aggiuntive nell'oggetto contenuto (Articolo)</span><span style="font-style: italic;"><br /></span>Questa soluzione richiede, ad esempio, che la classe <span style="font-style: italic;"><span style="font-style: italic;">Articolo</span></span> contenga al suo interno un campo <span style="font-style: italic;">quantita' </span>che esprima il numero di pezzi di un articolo una volta che questo viene riposto in uno scaffale.<br />Ovviamente questa soluzione è difettosa dal punto di vista OOP: si stanno inserendo informazioni relative ad una associazione nell'elemento associato, e quest'ultimo sarà dotato di tali informazioni anche quando non associato a nessun scaffale (es. in anagrafica articoli).<span style="font-style: italic;"> </span>Inoltre, all'aumentare del numero di informazioni relative all'associazione, si ha un aumento progressivo della complessità della classe contenuta (<span style="font-style: italic;">Articolo</span>).<span style="font-style: italic;"> </span>Questo aumento di complessità non solo rende il codice piu' complesso da manutenere, ma vincola la libreria che si sta realizzando: infatti la classe contenuta dovrà essere dotata di opportuni metodi pubblici di accesso alle informazioni di associazione (es. getQuantita() ), ma un metodo pubblico vincola la libreria e rende estremamente complesso il refactoring (non si puo' ridurre quello che è pubblico poiché non si sa a priori chi usa/userà tali metodi).<span style="font-style: italic;"> <span style="font-style: italic;"></span><br /><br />Ne consegue che questa soluzione è pessima e dovrebbe essere usata solo per esempi e programmi di estrema semplicità.<br /><br /><br /></span><span style="font-weight: bold;">Creare una sottoclasse della classe contenuta (Articolo) e inserire nella sottoclasse le informazioni aggiuntive</span><span style="font-style: italic;"><br /></span>Questa soluzione è una variante di quella precedente. In sostanza si crea una sottoclasse di quella contenuta (<span style="font-style: italic;">Articolo</span>) in modo da <span style="font-style: italic;">estendere</span> tale classe con le informazioni aggiuntive relative all'associazione. Tale sottoclasse verrà poi usata e contenuta all'interno del contenitore stesso (<span style="font-style: italic;">Scaffale</span>), implementando di fatto una associazione che comprende sia le informazioni di base (<span style="font-style: italic;">Articolo</span>) che quelle di associazione. Di fatto quindi si crea la sottoclasse e si specializza la classe contenitrice affinché contenga la nuova sottoclasse:<br /><br />public class ArticoloEsteso extends Articolo{<br />      private int quantita = 0;<br />      ....<br />}<br /><br />public class Scaffale{<br />  ...<br />  List<span style="font-style: italic;">&lt;ArticoloEsteso&gt;</span><articoloesteso> articoli;<br />  ...<br />}<br /><br />Lo svantaggio di questa soluzione è quella di vincolare comunque le informazioni di associazione ad uno specifico articolo, ovvero ad uno specifico oggetto contenuto. Di fatto quindi è come se l'associazione si fosse spostata di livello, anziché dal contenitore ad un oggetto contenuto, da un contenitore ad un oggetto contenuto e potenziato. Inoltre questa soluzione, usando l'ereditarietà, vincola fortemente la classe estesa (come è naturale in una gerarchia).<br /><br /><span style="font-style: italic;">Questa soluzione è generalmente accettabile, anche se spesso l'introduzione di un vincolo di ereditarietà impone limitazioni troppo forti per una buona manutenzione del codice.</span><br /><br /><span style="font-weight: bold;">Usare una doppia Collection nella classe contenitore (</span><span style="font-style: italic; font-weight: bold;">Scaffale</span><span style="font-weight: bold;">)</span><br />L'associazione fra contenitore e contenuto viene realizzato tramite una collection, nei casi precedenti una lista di articoli contenuta in ogni istanza di scaffale. Siccome una collection può contenere un solo tipo di oggetto (tralasciamo casi in cui si memorizzano oggetti diversi poiché rappresentano casi di cattiva programmazione), può avere senso utilizzare due collection parallele: una che memorizzi l'oggetto contenuto (<span style="font-style: italic;">Articolo</span>) e una che memorizzi le informazioni aggiuntive (ad esempio incapsulandole in un oggetto <span style="font-style: italic;">InformazioniStoccaggio</span>). Finché le due collection saranno mantenute coerenti (ad es. l'articolo i-esimo è associato alle informazioni i-esime) non vi saranno problemi di sorta.<br />Chiaramente all'aumentare del numero di informazioni da memorizzare per associazione è possibile (i) modificare l'oggetto di informazioni affinché le contenga tutte oppure (ii) aggiungere una nuova lista che contenga le nuove informazioni. Ne consegue che questa soluzione è per molti versi flessibile e adattabile. Purtroppo però la gestione di due o piu' collection parallele può procurare diversi grattacapi, che possono poi sfociare in forti mal di testa quando gli indici di correlazione non corrispondano piu'.<br /><span style="font-style: italic;">Questa soluzione è pertanto implementabile quando si abbia un buon controllo sui meccanismi di correlazione delle collection e quando comunque queste non aumentino esageratamente (>3) in numero. </span> Si noti infine che è opportuno implementare la politica di correlazione in modo che non sia modificabile da estensioni future, altrimenti si rischia di ricadere in problemi di correlazione difficili da individuare.<br /><br /><span style="font-weight: bold;">Usare una Map nella classe contenitor (Scaffale)</span><br />Questa soluzione è molto allettante, e di fatto rappresenta una naturale evoluzione della precedente. L'idea è quella di usare una <span style="font-style: italic;">Map</span>, che altro non è che una <span style="font-style: italic;">Collection</span> che mette in correlazione due oggetti fra loro. E' quindi possibile inserire nella mappa gli oggetti da contenere (<span style="font-style: italic;">Articolo</span>) come chiavi, e come valori correlati oggetti di informazione:<br /><br /><span style="font-style: italic;">public class Scaffale{</span><br /> <span style="font-style: italic;">   ...<br /></span>   <span style="font-style: italic;">private Map<articolo, informazionistoccaggio=""></articolo,></span></articoloesteso><span style="font-style: italic;">&lt;Articolo, InformazioniStoccaggio&gt;</span><articoloesteso><span style="font-style: italic;"><articolo, informazionistoccaggio=""> articoli;</articolo,></span><br /><span style="font-style: italic;">     ...<br /></span> <span style="font-style: italic;">}</span><br /><br />Così facendo, è possibile dato un articolo ottenere in modo piuttosto semplice le informazioni correlate, come pure è possibile scorrere la mappa per avere l'elenco di ogni articolo. Di fatto, la <span style="font-style: italic;">Map</span> realizza una doppia <span style="font-style: italic;">Collection</span> sempre coerente.<br />Fino ad ora questa è la soluzione migliore, anche se presenta alcuni pericolosi trabocchetti:<br /></articoloesteso><ol><li>non deve mai essere ritornata, in nessuna eventualità, la mappa completa, bensì solo i suoi singoli elementi (<span style="font-style: italic;">Articolo</span> e <span style="font-style: italic;">InformazioniStoccaggio</span>). La penalità è di trovarsi nella impossibilità di fare un efficiente refactoring o di cambaire il comportamento di gestione della classe contenitrice;</li><li>l'oggetto di informazioni correlate (<span style="font-style: italic;">InformazioniStoccaggio</span>) non ha nessuna relazione autonoma con l'oggetto al quale si riferisce (<span style="font-style: italic;">Articolo</span>), e di conseguenza dato un <span style="font-style: italic;">Articolo</span> e un <span style="font-style: italic;">InformazioniStoccaggio</span> non è possibile sapere se le informazioni sono correlate o provengono da sorgenti differenti. L'unica soluzione è quella di affidarsi allo <span style="font-style: italic;">Scaffale</span> per avere le informazioni coerenti (si noti che questo problema si aveva anche nel caso di <span style="font-style: italic;">Collection</span> correlate).</li></ol><span style="font-style: italic;">Tuttavia quelli appena esposti sono problemi generalmente piccoli, e che non pregiudicano il coding di una applicazione anche complessa, e quindi questa soluzione si presenta come una delle migliori.</span><br /><br /><span style="font-weight: bold;">Utilizzo di un Wrapper del contenuto (Articolo) e di una singola Collection nella classe contenitore (Scaffale)</span> Questa soluzione è a mio avviso la piu' flessibile ed espandibile. L'idea è quella di usare una singola collezione, ad esempio una lista, nella classe contenitore (<span style="font-style: italic;">Scaffale</span>), e di inserire al suo interno non direttamente l'oggetto contenuto (<span style="font-style: italic;">Articolo</span>), bensì un <span style="font-style: italic;">wrapper</span> di quest'ultimo che contenga anche delle informazioni supplementari. Ad esempio:<br /><br />public class ArticoloInScaffale{<br />          private Articolo articolo;<br />          private InformazioniStoccaggio info;<br />           ...<br />}<br /><br />public class Scaffale{<br />          private List<articoloinscaffale>&lt;ArticoloInScaffale&gt; articoli;<br />          ....<br />}<br /><br />In questo esempio <span style="font-style: italic;">ArticoloInScaffale</span> ingloba <span style="font-style: italic;">Articolo</span><span>, assieme alle informazioni correlate alla disposizione dell'articolo nello scaffale. E' abbastanza semplice dotare la classe <span style="font-style: italic;">Scaffale</span> di opportuni metodi per estrarre gli articoli o le informazioni, e non si deve lavorare con collection a doppia dimensione, bensì con collection lineari. Inoltre questa soluzione è molto vantaggiosa per il code refactoring, poiché risulta molto semplice aggiungere informazioni complementari senza dover modificare il sistema di contenimento .<br /><br /><span style="font-weight: bold;">Conclusioni</span><br />Il metodo a mio avviso piu' portabile e manutenibile consiste nella creazione di un wrapper che colleghi ogni oggetto contenuto (<span style="font-style: italic;">Articolo</span>) con le proprie informazioni, e l'uso di una singola collection rende molto piu' semplice da gestire la classe contenitore (<span style="font-style: italic;">Scaffale</span>). Tuttavia questa soluzione richiede la scrittura di codice in piu', secondo la tradizione OOP dove le astrazioni regalo potenza, ma hanno un costo di setup iniziale.<br />Se si deve quindi realizzare una correlazione in poco tempo si utilizzi una mappa, altrimenti si usi un wrapper. Le altre soluzione sono a mio avviso da scartare per i sopracitati problemi.<br /></span><articoloesteso></articoloesteso></articoloinscaffale>