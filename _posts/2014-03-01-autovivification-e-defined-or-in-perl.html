---
layout: post
title: Autovivification e defined-or in Perl
date: '2014-03-01T13:58:00.000+01:00'
author: Luca Ferrari
tags:
- perl
modified_time: '2014-03-01T13:58:00.499+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-3065266634163668582
blogger_orig_url: http://fluca1978.blogspot.com/2014/03/autovivification-e-defined-or-in-perl.html
---

<div style="text-align: justify;">La regola che guida Perl e' quella di poter fare quello che si vuole con il minimo sforzo.</div><div style="text-align: justify;">A tal fine Perl offre il concetto di "autovivification", noto anche a molti altri linguaggi di scripting, che consente di inizializzare una variabile (scalare o non) al suo primo accesso. L'idea e' quella di non dover pre-inizializzare le strutture dati, ma lasciare che questi si popolino in automatico quando occorre.</div><div style="text-align: justify;">Come conseguenza dell'autovivificazione l'accesso ad un entry in un hash che non e' ancora stat definita produce l'inserimento dell'netry con valore undef, cosi' come l'accesso ad una cella di un array con posizione non ancora conteggiata implica la sua inizializzazione (e di tutte le celle precedenti) al valore di zero.</div><div style="text-align: justify;">Perche' questo dovrebbe semplificare le cose? Perche' invece che scrivere un blocco di codice come segue:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">%my_hash = ( FILES =&gt; 0,</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">DIRS  =&gt; 0,</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">LINKS =&gt; 0 );</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># ...</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$my_hash{ FILES }++;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># ...</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$my_hash{ DIRS }--;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># ...</span><br /><br />e' possibile scrivere direttamente:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">%my_hash;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># ...</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$my_hash{ FILES }++;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># ...</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$my_hash{ DIRS }--;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># ...</span><br /><br /><div style="text-align: justify;">Perl e' sufficientemente intelligente da capire anche i riferimenti, e quindi tutto funziona correttamente anche usando strutture dati complesse.</div><div style="text-align: justify;">Anche se esistono opportuni moduli per ridurre o eliminare l'autovivificazione (ad esempio evitando di popolare celle con chiavi mispelled), l'autovivification e' una proprieta' veramente molto utile.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Ma Perl non si ferma qui: le versioni recenti definiscono anche l'operatore "defined-or". Tale operatore, dalla sintassi a mio avviso orribile, permette di inizializzare in autovivificazione un elemento solo se questo non e' ancora stato definito.</div><div style="text-align: justify;">La sintassi e' per me orribile perche' l'operatore di assegnamento "defined-or" usa, ovviamente, il simbolo '=' (assegnamento) preceduto da una doppia slash '//' (ad indicare e ricordare il simbolo di or logico '||'); tale sintassi ricorda vagamente un commento C++/Java e la cosa e' a prima vista fuorviante nella lettura del codice.</div><div style="text-align: justify;">Ad ogni modo come funziona l'operatore? Si consideri il seguente esempio:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">#!/usr/bin/env perl -w</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">use v5.10;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">use Data::Dumper;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">sub initialize{</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; my ($hash_ref) = @_;</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; $hash_ref-&gt;{ name } //= "Luca";</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; $hash_ref-&gt;{ surname } //= "Ferrari";</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">}</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$my_hash_ref = { name =&gt; "Mr. Luca" };</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">say Dumper( $my_hash_ref );</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">initialize( $my_hash_ref );</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">say "After the defined-or operator....";</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">say Dumper( $my_hash_ref );</span><br /><br />che produce come output:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$VAR1 = {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; 'name' =&gt; 'Mr. Luca'</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">};</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">After the defined-or operator....</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">$VAR1 = {</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; 'name' =&gt; 'Mr. Luca',</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; 'surname' =&gt; 'Ferrari'</span><br />};<br /><br /><br /><div style="text-align: justify;">L'idea e' questa: viene definito un hash che deve contenere come chiavi 'name' e 'surname', ma per dimenticanza (o pigrizia) solo il primo viene valorizzato. Poi si chiede alla funzione 'initialize' di inizializzare l'hash e questa esamina le due chiavi. La prima, 'name', e' definita e quindi non viene riassegnata, mentre la seconda non e' ancora stata definita e quindi viene assegnata ad un valore di default.</div><div style="text-align: justify;">Valore di default: questo e' l'uso principale dell'operatore "defined-or".</div><div style="text-align: justify;">In altre parole e' come se si fosse scritto:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">if ( ! exists $hash_ref-&gt;{ surname } ){</span></div><div style="text-align: justify;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp; $hash_ref-&gt;{ surname } = "Ferrari";</span></div><div style="text-align: justify;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">}</span></div>