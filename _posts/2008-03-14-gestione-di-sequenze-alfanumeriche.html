---
layout: post
title: Gestione di sequenze alfanumeriche
date: '2008-03-14T10:43:00.000+01:00'
author: Luca Ferrari
tags:
- postgresql
- java
modified_time: '2008-03-14T16:55:27.674+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-9169359394522357200
blogger_orig_url: http://fluca1978.blogspot.com/2008/03/gestione-di-sequenze-alfanumeriche.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


Quando si lavora con applicativi interfacciati a database relazionali si ha spesso la necessità di far generare all'applicativo o al database stesso dei codici sequenziali. Molti RDBMS consentono di creare sequenze automatiche tramite delle <span style="font-style: italic;">sequence</span> (tabelle speciali il cui valore cambia ad ogni lettura) o campi <span style="font-style: italic;">auto-increment</span>. Il problema è che le sequenze così generate sono numeriche, mentre spesso sono necessarie sequenze alfanumeriche (ad esempio <span style="font-style: italic;">articolo001</span>, <span style="font-style: italic;">articolo002, <span style="font-style: italic;">articolo003,...</span></span>). Il problema non è sempre risolvivibile direttamente dal lato database, e quindi deve essere affrontato molto spesso dal lato applicativo.<br /><br />In questo articolo viene descritta una possibile soluzione Java, capace di adattarsi a diversi database e contesti applicativi. Successivamente, viene illustrata una possibile soluzione lato database implementata su PostgreSQL.<br />Entrambe le soluzioni si appoggiano ad una sequenza lato database per la generazione della parte numerica del codice. Il codice qui illustrato è a scopo puramente didattico.<br /><br /><span style="font-weight: bold;">Soluzione Java<br /><span style="font-weight: bold;"><br /></span></span>L'idea è quella di costruire una serie di classi che consentano di ottenere il prossimo valore alfanumerico di una sequenza. Per fare questo occorre anzitutto predisporre un tipo <span style="font-style: italic;">Sequence</span> che possa essere usato per gestire i vari tipi di sequenza che, lato applicativo, si vogliono gestire (es. alfanumerici, numerici, ecc.):<br /><br /><pre>public interface Sequence { }</pre>Come si può notare l'interfaccia Sequence non definisce nessun metodo in particolare, lasciando alle sue concrete implementazioni la definizione dei tipi di dato da gestire. In altre parole, l'interfaccia <span style="font-style: italic;">Sequence</span> è un semplice segnaposto (tag) per gestire una serie di tipi concreti. Una possibile estensione della <span style="font-style: italic;">Sequence</span> è quella che consente di gestire le sequenze alfanumeriche:<br /><br /><pre>public interface StringSequence extends Sequence {<br />  <br />   /**<br />    * Returns the next value of the sequence. This value could come from a database sequence (in such case<br />    * this method will simply query the database) or can be calculated by the program.<br />    * @return the sequence string.<br />    */<br />   public  String nextValue();<br /><br />  <br />   /**<br />    * Sets up this sequence. Setting up a sequence means initialize it to run the nextValue() method.<br />    * @param sequencePrefix a prefix to place in the beginning of the string<br />    * @param sequenceName the name of the sequence in the database (if supported) or null if no sequence must<br />    * be queried (or the database does not support it).<br />    */<br />   public void setUp(String sequencePrefix, String sequenceName);<br />}<br /></pre><br />L'interfaccia <span style="font-style: italic;">StringSequence</span> prevede due metodi fondamentali: <span style="font-style: italic;">setUp(..)</span> che serve ad inizializzare il generatore di codice, e <span style="font-style: italic;">nextValue()</span> che fornisce il prossimo valore dalla sequenza. In particolare, il metodo <span style="font-style: italic;">setUp(..)</span> accetta come parametri un prefisso da appendere alle stringhe generate ad ogni chiamata a <span style="font-style: italic;">nextValue()  </span>e il nome della sequenza numerica (lato database) da usare.<br /><br />Una possibile implementazione concreta del generatore di stringhe può essere la seguente:<br /><br /><pre>public class PostgresqlSequence implements StringSequence, SerialSequence {<br /><br />   /**<br />    * Each sequence generated by this genertor will have this prefix.<br />    */<br />   protected  String sequencePrefix = "articolo-";<br />  <br /><br />   /**<br />    * The table to query to get the next sequence value.<br />    */<br />   protected String sequenceTable = "";<br /> <br />  <br />   /**<br />    * Builds a sequence generator with the specified sequence table and the specified prefix.<br />    * @param sequenceName the name of the sequence on the database to query<br />    * @param sequencePrefix the prefix of the sequence generated<br />    */<br />   protected PostgresqlSequence(String sequenceName, String sequencePrefix){<br /> super();<br /> this.setUp(sequencePrefix, sequenceName);<br />   }<br />  <br />  <br />   /**<br />    * Sets up the sequence generator.<br />    */<br />   public void setUp(String prefix, String sequenceName){<br /> // avoid to store a null sequence name<br /> if( prefix == null )<br />     this.sequencePrefix = "";<br /> else<br />     this.sequencePrefix = this.sequencePrefix;<br /><br />      // store the sequence name<br />      this.sequenceTable = sequenceName;<br />   }<br />  <br />  <br />   /**<br />    * Returns the sequence key string as union of the string fixed in this class and the number that comes<br />    * from the database sequence.<br />    */<br />   public String nextValue() {<br /> String ret = null;<br /> Statement st = null;<br /> ResultSet rs = null;<br /> <br /> try{<br />           /* connect to the database with your own code */<br />     Connection connection = // database connection<br />     st = connection.createStatement();<br />     rs = st.executeQuery("SELECT nextval('" + this.sequenceTable + "')");<br />     if( rs!= null &amp;&amp; rs.next() ){<br />  int seqVal = rs.getInt(1);<br />  ret = this.sequencePrefix + seqVal;<br />     }<br />     else<br />  ret = null;<br />        <br />     // close database resources<br />     rs.close();<br />     st.close();<br /><br /> }catch(SQLException e){<br />     // handle errors<br />     return null;<br /> }<br /> <br /> return ret;<br /><br />   }<br />}<br /><br /><br /></pre>Come si può notare, il costruttore della classe richiama immediatamente il metodo <span style="font-style: italic;">setUp(..)</span> fornendo come dati il nome della sequenza da interrogare e quello del prefisso da usare nella restituzione dei dati. Una volta inizializzata, l'istanza del generatore di codici provvede ad interrogare il database ad ogni chiamata di <span style="font-style: italic;">nextValue()</span> e a restituire una stringa formata dalla composizione del valore restituito dalla sequenza del database e dal codice da usarsi come prefisso.<br /><br />Un esempio di utilizzo del generatore di codici è il seguente:<br /><br /><pre>StringSequence sequence = new PostgresqlSequence("test_pk_seq","articoli_");<br />String code = sequence.nextValue(); // produce qualche cosa del tipo articoli_763<br /></pre><br />Per rendere l'architettura sopra descritta maggiormente portabile, è possibile utilizzare una <span style="font-style: italic;">SequenceFactory</span> che fornisca un riferimento ad un oggetto <span style="font-style: italic;">Sequence</span> (in particolare <span style="font-style: italic;">StringSequence</span>) in modo trasparente e a seconda della configurazione del sistema.<br /><br /><span style="font-size:130%;"><span style="font-style: italic;"></span><br /></span><span style="font-size:100%;"><span style="font-weight: bold;">Soluzione PostgreSQL</span><br /><br />L'idea è quella di creare una funzione che interroghi la sequenza opportuna e restituisca la concatenazione della stringa di prefisso con il valore della sequenza stessa.<br />Un primo modo può essere quello di creare una funzione specifica per ogni sequenza che debba essere interroga. Supponendo di avere una sequenza test_pk_seq è possibile utilizzare la seguente funzione plpgsql:</span><span style="font-size:130%;"><span style="font-size:100%;"><br /><br /><br /></span></span><pre>/**<br /> * Esempio di uso:<br /> * select next_test_alphanumeric_value('articolo-test');<br /> * che ritorna un valore simile a<br /> * articolo-test27<br /> */<br />CREATE OR REPLACE FUNCTION next_test_alphanumeric_value(prefix character varying)<br />RETURNS character varying<br />AS $BODY$<br />DECLARE<br /> /* it will contain the next computed value */<br /> next_key character varying;<br />BEGIN<br /> raise debug 'Querying the test_pk_seq sequence';<br /> SELECT prefix || nextval('test_pk_seq') INTO next_key;<br /> return next_key;<br />END;</pre><br /><br />Come si può notare la funzione è molto semplice: viene accettato come parametro unico la stringa da usare come prefisso nella generazione del codice alfanumerico, e questo viene concatenato all'interrogazione della sequenza <span style="font-style: italic;">test_pk_seq</span>. Questo metodo, seppur semplice, ha il forte svantaggio di non essere adattabile a sequenze differenti: occorrerà implementare una funzione specifica per ogni sequenza da interrogare.<br /><br /><br />Una soluzione migliore consente di specificare, oltre alla stringa di prefisso, anche il nome della sequenza da interrogare. In questo modo, con una sola funzione, è possibile ottenere i valori da più sequenze. L'idea è simile a quella vista in precedenza: si concatena la stringa di prefisso al valore ottenuto dalla sequenza. Essendo però questa volta la sequenza non nota a priori, è necessario costruire la query SQL dinamicamente:<br /><br /><pre>/**<br /> * Esempio di uso:<br /> * select next_alphanumeric_value('articolo-','test_pk_seq');<br /> * che ritorna un risultato simile a<br /> * articolo-34<br /> */<br />CREATE OR REPLACE FUNCTION next_alphanumeric_value(prefix character varying, sequence_name character varying)<br /> RETURNS character varying AS<br /> $BODY$<br /><br />DECLARE<br /> /* it will contain the next computed value */<br /> next_key character varying;<br /><br /> /* the query string dynamically built */<br /> query_string character varying;<br /><br />BEGIN<br /> raise debug 'Sequence used %', sequence_name;<br /> query_string := 'SELECT ' || quote_literal(prefix) || '|| nextval(' || quote_literal(sequence_name) || ');';<br /> raise debug  'Dynamic query %', query_string;<br /> execute query_string into next_key;<br /> return next_key;<br />END;<br /><br />$BODY$<br /> LANGUAGE plpgsql VOLATILE;<br />ALTER FUNCTION next_alphanumeric_value(character varying, character varying) OWNER TO luca;</pre>Come si può notare, viene anzitutto costruita una stringa che rappresenta la query da eseguire, ossia uno statement SELECT con la concatenazione della stringa di prefisso e del nextval della sequenza. Questa query viene poi fatta eseguire tramite il comando <span style="font-style: italic;">execute</span> e il risultato viene memorizzato nella variabile ritornata dalla funzione. Si noti che, siccome la funzione <span style="font-style: italic;">nextval(..)</span> si aspetta un argomento stringa, il nome della sequenza passato come parametro deve essere racchiuso da apici, e quindi si utilizza la funzione <span style="font-style: italic;">quote_literal(..)</span> per ottenere la relativa stringa SQL.