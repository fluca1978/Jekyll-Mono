---
layout: post
title: From File::Find to File::Find::Rule
date: '2016-10-28T18:29:00.004+02:00'
author: Luca Ferrari
tags:
- perl
- programmazione
- planet-perl-ironman
modified_time: '2016-10-28T18:34:35.747+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-6284123339736996569
blogger_orig_url: http://fluca1978.blogspot.com/2016/10/from-filefind-to-findfilerule.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<div id="content">I tend to use <code>File::Find</code> the most in order to get some file searching and mangling. Usually my scripts have the same simple structure as follows:<br /><br /><div class="org-src-container"><pre class="src src-perl">$| = <span style="font-style: italic; font-weight: bold;">1</span>; <span style="background-color: white;"><span style="font-style: italic;"># autoflush</span></span><br />find( \&amp;directory_scanner, ( $starting_directory ) );<br />$| = <span style="font-style: italic; font-weight: bold;">0</span>; <span style="background-color: white;"><span style="color: white;"><span style="font-style: italic;"># non autoflush</span></span></span><br /><br /><span style="background-color: white;"><span style="font-style: italic;"># </span><span style="font-style: italic;">and the scanner is something like</span></span><br /><span style="font-weight: bold;">sub</span> directory_scanner{<br />    chomp;<br /><br />    <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">if</span> ( $_ eq $starting_directory || ! -f $_ );<br />    <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">if</span> ( $File::Find::dir !~ /$re_dir(\d{4}-\d{6})$/ );<br />    ...<br />}</pre><pre class="src src-perl">&nbsp;</pre></div><div style="text-align: justify;">As you can see the event handler invoked by <code>File::Find</code> is used to both print some report (the <code>$counter</code>) in order to tell me the script is still alive (I do pass 200+k files at once) but, most notably, applies a regexp to the directory I'm in in order to avoid some staging/backup/etc. directory that could be likely the one I'm interested into but I don't want the script to pass. </div><div style="text-align: justify;">For a few times I've tried to convert my <code>Find::File</code> based scripts to <code>File::Find::Rule</code>, just to get more used with such interface, but I didn't know how to fix the application of regular expression to the traversing path. Reading a little more deeply the documentation I found the <code>exec</code> subroutine that allows me to specify an handler (i.e., a subroutine) that can return <code>true</code> or <code>false</code> depending on what I want to do on the file I'm visiting. Therefore, converting my scripts becomes as easy as follows: </div><div class="org-src-container"><pre class="src src-perl">&nbsp;</pre><pre class="src src-perl">$| = <span style="font-style: italic; font-weight: bold;">1</span>; <br /><span style="font-weight: bold;">my</span> $engine = File::Find::Rule-&gt;new();<br /><span style="font-weight: bold;">my</span> @<span style="text-decoration: underline;">files</span>  = $engine-&gt;file()<br />    -&gt;<span style="font-weight: bold;">exec</span>( <span style="font-weight: bold;">sub</span> {<br />        <span style="font-weight: bold;">my</span> ( $shortname, $path, $fullname ) = @<span style="text-decoration: underline;">_</span>;<br />        <span style="font-weight: bold;">return</span> $path !~ /$re_dir(\d{4}-\d{6})$/;<br />            } )<br />    -&gt;<span style="font-weight: bold;">exec</span>( <span style="font-weight: bold;">sub</span>{<br />        <span style="font-weight: bold;">my</span> ( $shortname, $path, $fullname ) = @<span style="text-decoration: underline;">_</span>;<br />        $counter++;<br />        <span style="font-weight: bold;">return</span> $shortname =~ /KCL/;<br />            } )<br />    -&gt;<span style="font-weight: bold;">exec</span>( <span style="font-weight: bold;">sub</span>{<br />        <span style="font-weight: bold;">my</span> ( $shortname, $path, $fullname ) = @<span style="text-decoration: underline;">_</span>;<br />        print "." <span style="font-weight: bold;">if</span> ( $counter % <span style="font-style: italic; font-weight: bold;">100</span> == <span style="font-style: italic; font-weight: bold;">0</span> );<br />        print "$counter\n" <span style="font-weight: bold;">if</span> ( $counter % <span style="font-style: italic; font-weight: bold;">1000</span> == <span style="font-style: italic; font-weight: bold;">0</span> );<br />        <span style="font-weight: bold;">return</span> <span style="font-style: italic; font-weight: bold;">1</span>; <span style="background-color: white;"><span style="font-style: italic;"># do not forget !</span></span><br />            } )<br />    -&gt;in( $starting_directory );<br />$| = <span style="font-style: italic; font-weight: bold;">0</span>;&nbsp;</pre><pre class="src src-perl">&nbsp;</pre></div><div style="text-align: justify;">I've kept three different handlers for readibility sake, but as you can  image, it is possible to shrink them down into a single one. The funny part here is that I can check the path against a regexp again. The drawback is that an handler used for output reporting only must  return always a true value. </div><div style="text-align: justify;">In the case you are wondering, the autoflush is used simply to display the dots while the program is running. </div></div>