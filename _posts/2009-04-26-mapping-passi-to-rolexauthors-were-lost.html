---
layout: post
title: Mapping PASSI to Rolex...authors were lost!
date: '2009-04-26T16:12:00.003+02:00'
author: Luca Ferrari
tags:
- università
- research
modified_time: '2010-07-12T18:55:54.803+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-2773769512184310681
blogger_orig_url: http://fluca1978.blogspot.com/2008/02/mapping-passi-to-rolexauthors-were-lost.html
---

<div style="text-align: center;"><span style="font-style: italic;">WARNING: I believe that a scientific contribution should always be discussed.<br />This could not be the right place to discuss it, but it could be a starting point.<br />The following blog entry discusses a paper on a system I designed and developed that is, in my opinion, wrongly adapted to provide a scientific contribution I don't agree with.<br /><span style="font-weight: bold;">Please remind that all opinions expressed here are on my own. </span></span></div><br /><br />As the main designer and developer of RoleX (aka BlackCat), a Java framework for dynamic role injection thru run-time bytecode manipulation, I cannot express positively about the paper<span style="font-style: italic;"> "</span><a href="http://mars.ing.unimo.it/wiki/papers/emcsr08.pdf">Mapping PASSI and RoleX</a>". Such article in fact presents a description of RoleX that is almost wrong, and therefore I don't believe that the conclusions this paper presents are scientifically valid.<div style="text-align: justify;">Such paper, written within the  <a href="http://www.mensa-project.org/page.php?32">MENSA project</a> (a multi-university project)</div><div style="text-align: justify;">should have been written with a stricter description of RoleX and of the design/aim of the latter.</div><div style="text-align: justify;">Having read a work in progress draft in the beginning of 2008, before the final paper was published, I claimed about several errors in the RoleX description, but I see authors did not fix the paper. If authors asked me for an explaination of those concepts of RoleX that are still not clear to them, I surely provided all the required details.</div><div style="text-align: justify;">It seems to me that the paper is trying mapping apples to oranges, nevertheless it has been succesfully published to the  2nd International Symposium Agent Based Modeling and Simulation,  the 19th European Meeting on Cybernetics and Systems Research (EMCSR 2008), and this also means not all the paper is wrong. Let's say it is a nebolous paper to me.</div><div style="text-align: justify;">Interested readers should read [1] before continuing, in order to acquire needed RoleX background. <span style="font-style: italic;"><br /><br /><span style="font-weight: bold;">General Discussion</span><br /></span>The paper proposes an interesting aim: mapping the RoleX implementation to the PASSI methodology. This is surely interesting and challenging, but it must stand out on a clear RoleX background and experience, as well as a PASSI knowledge able to cover lacks in the former or the latter and how to overtake migration and integration issues.<span style="font-style: italic;"><br /><br /><span style="font-weight: bold;"><span style="font-style: italic;">The Rolex Meta-Model<br /></span></span></span>The RoleX meta model described on section 2.2 has several errors, most of them clearly visible in Figure 2. First of all, from Figure 2 it is possible to note how a <span style="font-style: italic;">RoleDescriptor</span> is composed by one or more <span style="font-style: italic;">ActionDescriptor</span> and one or more <span style="font-style: italic;">EventDescriptor</span>. This is not correct, since as it is possible to see from [1], Figure 5, where it is clearly shown how descriptor are nested. Authors seems to have reported a distorted version of [1], Figure 6, where it is shown how an <span style="font-style: italic;">EventDescriptor</span> can be embedded directly into a <span style="font-style: italic;">RoleDescriptor,</span> even if no <span style="font-style: italic;">ActionDescriptor</span> is provided for it. Nevertheless, the important thing is that the descriptor are usually nested <span style="font-style: italic;">(RoleDescriptor</span> contains <span style="font-style: italic;">ActionDescriptor</span> that contains <span style="font-style: italic;">EventDescriptor),</span> with the exception that a <span style="font-style: italic;">RoleDescription</span> can directly contain one or more <span style="font-style: italic;">EventDescriptor.</span> Instead from the Figure 2 only such exception is possible.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Another interesting mistake is about the association between a<span style="font-style: italic;"> Role</span> and its descriptors. From Figure 2, it appears that a <span style="font-style: italic;">Role</span> has a <span style="font-style: italic;">RoleDescriptor</span>, and that is true, but it is not as depicted in Figure 2. First of all, a <span style="font-style: italic;">Role</span> and a <span style="font-style: italic;">RoleDescriptor</span> are not tied in any way. The agent works always using <span style="font-style: italic;">RoleDescriptor</span>s and never using <span style="font-style: italic;">Role</span>s, and this is visible in code snippet of [1], Figure 17, where the agent searches for and assumes a role only thru its descriptor. The adoption of descriptors is better explained in [2]:</div><div style="text-align: justify;"><br /></div><blockquote>The descriptors are useful also for hiding to the agent the physical<br />location of the role implementation, allowing agent programmers<br />to disregard about the work of role programmers, and viceversa,<br />because the role behavior is described in a separate way.</blockquote><div style="text-align: justify;">Here the key is <span style="font-style: italic;">role implementation hiding</span>: in order to allow an agent to use the role only thru the injection mechanism, RoleX does not allow an agent to get (and instantiate) a role implementation directly. In other words, the <span style="font-style: italic;">Role Repository</span> keeps the role implementation hidden, exposing only the <span style="font-style: italic;">RoleDescriptor</span>s, that are not tied to the role implementation in any way. In fact, it is the <span style="font-style: italic;">Role Repository</span> that knows each descriptor to which role is tied and not, as suggested in Figure 2, a role that knows its descriptor. More details on the adoption of descriptors and role repository can be found in [3] and [4].</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A close look to Figure 2 emphasizes another embarassing detail: a <span style="font-style: italic;">role</span> class has a navigable link to a <span style="font-style: italic;">role descriptor</span>, and that is not true. Roles and descriptor are developed separately and are kept separate untill they are installed in the system. Installing a role in the system means that the role repository keeps information about a role and its descriptor. This also means that the role repository is the only component that, at run-time, contains a binding between a role and its descriptor. Thanks to that, it is possible to install the same role several time with different descriptors, or even to substitute a role behind a descriptor, and so on.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Now, having a look at older papers about RoleX, it is clear that a class diagram such as that of GFigure 2 has never been depicted. The reason is simple: RoleX is a dynamic framework, and being dynamic means that a lot of bindings are resolved only at run-time and through connection components (e.g., the role repository above). Therefore, it does not make any sense at all showing a <span style="font-style: italic;">static</span> class diagram to glance at a dynamic system.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">But section 2.2 lies on the RoleX role definition itself, and in fact it states that:</div><div style="text-align: justify;"><br /></div><blockquote>In RoleX, a role is deﬁned as a set of actions that an agent playing such role can perform to achieve its task, and a set of events that an agent is expected to manage in order to “behave” as requested by the role it plays.</blockquote><div style="text-align: justify;">That's not true, since the action-event definition is specified in the BRAIN framework and not in RoleX! In fact, in [5] section 2.1 there is the declaration of the BRAIN role model:</div><div style="text-align: justify;"><br /></div><blockquote>In BRAIN, a role is defined as a set of capabilities and an expected behavior. The former is a set of actions that an agent playing such role can perform to achieve its task. The latter is a set of events that an agent is expected to manage in order to “behave” as requested by the role it plays. </blockquote><div style="text-align: justify;"><br /></div><div style="text-align: justify;">As stated later in [5], RoleX is just one of the available implementation of BRAIN, and thus it is compliant to such role model. Not only the authors confuse BRAIN and RoleX, but they ignore the RoleX role definition, that being compatible with the BRAIN one, is expressed in [1] as:</div><blockquote><br />Deﬁning a role as a few classes and interfaces</blockquote><div style="text-align: justify;"><br /></div><div style="text-align: justify;">It's now time to see how the authors describe the <span style="font-style: italic;">invocation translator</span>:</div><div style="text-align: justify;"><br /></div><blockquote>The use of descriptors means that the programmer cannot write code that invokes methods corresponding to role actions in the usual way, because a compile-time error will occur. Therefore, there must be an invocation translator that do introspection on the extended agent to dynamically ﬁnd which method must be called in response to an invocation on an action description.</blockquote><div style="text-align: justify;"><br /></div><div style="text-align: justify;">The above seems a raw cut-and-paste of different articles and concepts. The fact is this (see [1], Figure 4 and description on page 190): when RoleX performs bytecode manipulation, it injects into an agent new members (the role members). It is clear that the agent has now new methods and properties, that before the role injection it didn't have. For this reason, the programmer cannot invoke directly the new methods because they are not present at compile time and because it does not know them directly (the role implementation is hidden). For this reason, the agent have to perform introspection to get knowledge of the new members and to use them. It is only to simplify such introspection process, and to complete the adoption of descriptors, that the <span style="font-style: italic;">invocation translator</span> exists, and in fact it allows to:</div><ol style="text-align: justify;"><li>access an added member without having to adopt introspection;</li><li>execute an action starting from its descriptor, and thus without the needing to know which action to execute.</li></ol><div style="text-align: justify;">It is thus clear that (i) the presence of an invocation translator is not a must (an agent can perform introspection by its own) and (ii) the invocation translator is not a consequence of the adoption of role descriptor, but rather a feature that helps programmer using descriptors.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><span style="font-weight: bold;">Mapping PASSI to RoleX</span></div><div style="text-align: justify;">Section 3 of the article shows the concrete mapping between PASSI and RoleX. Having provided readers with an almost totally wrong definition of RoleX, the mapping cannot not be correct, and in fact there are several mistakes. Let's start from Table 1, where PASSI concepts are mapped 1:1 to RoleX ones. First of all, it is worth noting how RoleX does not have a concrete <span style="font-style: italic;">action</span>, but only a concrete <span style="font-style: italic;">action descriptor</span>. As described before, the action concept derives from BRAIN, while RoleX implements it only by means of <span style="font-style: italic;">action descriptors</span>. It is therefore incorrect to map the PASSI <span style="font-style: italic;">agent action</span> to a RoleX action, while it is correct to map the former to a RoleX action descriptor (as the authors partially do).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Authors identify a PASSI <span style="font-style: italic;">service</span> with the event handling mechanism of BRAIN/RoleX, and this is not fully correct. In fact, even if it is true that an incoming event can represent a service request, RoleX injects into agents role members, that can be accessed (if publicly available) from other agents. In other words, a role service could be also an OOP-method injected into an agent, therefore a PASSI service should be mapped both on event handling and role methods (or better action descriptors).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Finally, it is almost wrong the mapping between a PASSI <span style="font-style: italic;">goal</span> and a RoleX <span style="font-style: italic;">role descriptor</span>. First of all, a role (and its descriptor) is not a goal in RoleX, rather an <span style="font-style: italic;">enabler</span> to achieve one or more goals. It is clear that a role cannot be a goal in RoleX also for the <span style="font-style: italic;">external visibility</span>: a role has a set of static properties, such as its exeternal visibility that allows another agent to know which role an agent is playing simply "watching" at it. How can it be expressed as a goal? A goal is something that an agent should actively achieve, and thus it can be specified by actions, as stated in [5]:</div><div style="text-align: justify;"><br /></div><blockquote>In BRAIN, a role is defined as a set of capabilities and an expected behavior. The former is a set of actions that an agent playing such role can perform to achieve its task. </blockquote><div style="text-align: justify;"><br /></div><div style="text-align: justify;">It is therefore clear that a role, in RoleX, is not a goal, rather a goal container, since it contains actions that can be used to achieve goals. Moreover, to achieve a goal, the actions could be serialized into one or more sequences, that is not imposed in any way in RoleX. This, again, specifies how a RoleX role cannot be a goal. It is interesting to note that the authors themselves recognize this, in contrast to Table 1, stating that:</div><blockquote><br />One of the major drawbacks of RoleX is that it fails in deﬁning goals (or tasks in PASSI terminology). Actually, the goal is distributed in the role descriptors, but there is not a way to directly deﬁne it. </blockquote><div style="text-align: justify;">This sentence must be analyzed very well. First of all, it is not RoleX's fault if the definition of goal is scattered within a role descriptor, since this is the definition that comes from BRAIN. It is worth noting, at this point, that while BRAIN does not include a definition of goal anywhere, RoleX does. In fact, as shown in [6] Figure 5, each kind of descriptors include an <span style="font-style: italic;">aim</span> specification, that can be used to specify the goal of the element. In particular, applying the <span style="font-style: italic;">aim</span> to action descriptors, we can express the goal of each action.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">It's now time to examine the <span style="font-style: italic;">context</span> element, that even if virtually available in RoleX, does not find any concrete implementation, and in fact is not either specified in the XRole schema definition (see [6]). So, the mapping between the PASSI <span style="font-style: italic;">scenario</span> and the RoleX <span style="font-style: italic;">context</span> cannot be possible, being the latter not present at all. This should be listed in the last paragraph of section 3, that explains which concept do not have a 1:1 mapping.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">With regard to such last paragraph, it is interesting noting that the <span style="font-style: italic;">role repository</span> should not be listed there. In fact, each role approach could have a way to list and provide roles to agents, and the role repository is, after all, doing that. So, while it is true that the adoption of the repository is an implementation issue, it is also true that PASSI is lacking modeling it and that a lot of other role approaches have their kind of role library.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><span style="font-weight: bold;">What is the key point authors missed?</span></div><div style="text-align: justify;">In my opinion, this article is wrong even in the title. Authors are trying to map a methodology (PASSI) over an implementation (RoleX), and there's nothing wrong with that. B<b>ut they discard that RoleX is compatible with another methodology, that is BRAIN</b>. <b><i>So,  before showing how PASSI could be mapped on RoleX, they should demonstrate that PASSI and BRAIN can coexist and can be mapped each other</i></b>, or at least that RoleX has so many implementation details that go out of bounds of BRAIN and that can be used in PASSI.</div><div style="text-align: justify;">Having that, it is possible to demonstrate and convince readers about the PASSI to RoleX mapping.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><span style="font-weight: bold;">REFERENCES</span></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">1 CABRI, FERRARI, AND LEONARDI, Injecting roles in Java agents through runtime bytecode manipulation, IBM SYSTEMS JOURNAL, VOL 44, NO 1, 2005</div><div style="text-align: justify;"><span style="font-style: italic;"><span style="font-style: italic;"><br />2 </span></span>Cabri,   Ferrari,   Leonardi,   Enabling Mobile Agents to Dynamically Assume Roles,   The 2003 ACM International Symposium on Applied Computing (SAC), Melbourne, Florida, USA,  March 2003</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">3 Luca Ferrari, master degree thesis (december 2002), <a href="http://agentgroup.ing.unimo.it/didattica/curriculum/letizia/tesi/ferrari/Tesi.ps"><span style="font-family: arial; font-style: italic;">"Middleware per agenti mobili con interazioni event-driven basate su ruoli e tecnologia XML"</span></a></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">4 Luca Ferrari, PhD thesis (February 2006)</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">5 Cabri, Ferrari, Leonardi, Supporting the Development of Multi-Agent Interactions via Roles,  The International Workshop on AGENT-ORIENTED SOFTWARE ENGINEERING (AOSE-2005)</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">6 Cabri,   Ferrari,   Leonardi,    Exploiting Run-Time Bytecode Manipulation to Add Roles to Java Agents, Science of Computer Programming, (Elsevier, Amsterdam-NL), Vol. 54, No. 1, pp. 73-98, January 2005 ISSN: 0167-6423</div>