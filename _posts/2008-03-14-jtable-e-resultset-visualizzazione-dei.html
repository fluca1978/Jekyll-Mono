---
layout: post
title: 'JTable e ResultSet: visualizzazione dei risultati di una query in una tabella'
date: '2008-03-14T09:51:00.000+01:00'
author: Luca Ferrari
tags:
- postgresql
- java
modified_time: '2008-03-14T10:11:40.601+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-6365856061325424788
blogger_orig_url: http://fluca1978.blogspot.com/2008/03/jtable-e-resultset-visualizzazione-dei.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


Nella scrittura di un programma Java capita molto spesso di dover visualizzare i risultati di una query in una tabella. Questo breve articolo illustra un modo semplice e rapido per visualizzare i dati estratti da un database SQL in un oggetto JTable, dando la possibilità di aggiornare tali dati qualora la query cambi nel tempo.<br /><br />L'idea fondamentale è quella di creare un <span style="font-style: italic;">modello di tabella</span>, che analizzerà i risultati della query SQL (sotto forma di <span style="font-style: italic;">ResultSet</span>) memorizzandoli internamente in una struttura di tipo <span style="font-style: italic;">Vector</span>. Terminato ciò il modello disporrà di una immagine in memoria dei dati estratti dal database, che quindi potranno essere visualizzati dalla relativa JTable.<br /><br />Di seguito il codice:<br /><br /><pre>public class GenericTableModel extends DefaultTableModel implements TableModelListener{<br />     <br />   public GenericTableModel(){<br /> super();<br /> this.addTableModelListener(this);<br />   }<br />  <br />   public GenericTableModel(ResultSet rs){<br /> this();<br /> // parse the result set if possible<br /> if( rs != null )<br />     this.parseResultSet(rs);<br />   }<br />  <br />  <br />   public  synchronized final Object[] getRow(int rowIndex){<br /> if( rowIndex < 0)  return null;<br /> else{<br />     Object ret[] = new Object[ this.getColumnCount() ];<br />     for(int i=0; i< ret.length; i++){<br />  ret[i] = ((Vector)this.dataVector.get(rowIndex)).get(i);<br />     }<br />    <br />     return ret;<br /> }<br /> <br />   }<br />  <br />  <br /><span style="font-weight: bold;">    public synchronized  void parseResultSet(ResultSet rs){</span><br /><span style="font-weight: bold;"> if( rs == null ){</span><br /><span style="font-weight: bold;">     // empty the vectors!</span><br /><span style="font-weight: bold;">     this.dataVector = new Vector();</span><br /><span style="font-weight: bold;">     this.columnIdentifiers = new Vector();</span><br /><span style="font-weight: bold;">     return;</span><br /><span style="font-weight: bold;"> }</span><br /><span style="font-weight: bold;"> </span><br /><span style="font-weight: bold;"> try{</span><br /><span style="font-weight: bold;">     </span><br /><span style="font-weight: bold;">     // table headers and other information</span><br /><span style="font-weight: bold;">     ResultSetMetaData metaData = rs.getMetaData();</span><br /><span style="font-weight: bold;">     int columns = metaData.getColumnCount();</span><br /><span style="font-weight: bold;">     </span><br /><span style="font-weight: bold;">     Vector<string> tmpHeaders = new Vector<string>(columns);   </span><br /><span style="font-weight: bold;">     //this.headers = new Vector<string>();</span><br /><span style="font-weight: bold;">     for(int i=1; i<=columns; i++)</span><br /><span style="font-weight: bold;">  tmpHeaders.add( new String(metaData.getColumnLabel(i)));</span><br /><span style="font-weight: bold;">     </span><br /><span style="font-weight: bold;">     // extract the data as String and put it into the vector</span><br /><span style="font-weight: bold;">     Vector<vector> tmpData = new Vector<vector>(20,5);</span><br /><span style="font-weight: bold;">     Vector row = null;</span><br /><span style="font-weight: bold;">     </span><br /><span style="font-weight: bold;">     while( rs.next() ){</span><br /><span style="font-weight: bold;">  row = new Vector();</span><br /><span style="font-weight: bold;">  </span><br /><span style="font-weight: bold;">  for(int i=1; i<=columns; i++)</span><br /><span style="font-weight: bold;">      row.add( rs.getObject(i)  );</span><br /><span style="font-weight: bold;">  </span><br /><span style="font-weight: bold;">  tmpData.add(row);</span><br /><span style="font-weight: bold;">            }</span><br /><span style="font-weight: bold;">                                                                                         }</span><br /><span style="font-weight: bold;">     </span><br /><span style="font-weight: bold;">     // notify changes to the table</span><br /><span style="font-weight: bold;">     this.setDataVector(tmpData, tmpHeaders);</span><br /><span style="font-weight: bold;">     </span><br /><span style="font-weight: bold;">     </span><br /><span style="font-weight: bold;"> }catch(SQLException e){</span><br /><span style="font-weight: bold;">     // .....</span><br /><span style="font-weight: bold;"> }</span><br /><span style="font-weight: bold;">                                                                                                           </span><br /><span style="font-weight: bold;">    }</span><br />   <br />  <br />  <br />   public void tableChanged(TableModelEvent e) {<br /> int row = e.getFirstRow();<br /> int column = e.getColumn();<br /> <br /> // check to have a good selection, thus to avoid exception while changing the table<br /> if( row < 0 || column < 0 )<br />     return;<br /> <br /> TableModel model = (TableModel)e.getSource();<br /> <br /> String columnName = model.getColumnName(column);<br /> <br /> Object data = model.getValueAt(row, column);<br /> <br /> // replace the value of the data at such row and column<br /> ((Vector)this.dataVector.get(row)).set(column, data); <br />   }<br />  <br />}</pre><br />Come si intuisce il metodo fondamentale è <span style="font-style: italic;">parseResultSet(..)</span>, che accetta un <span style="font-style: italic;">ResultSet</span> in ingresso e lo analizza, estrando i dati e riempendo due <span style="font-style: italic;">Vector</span>, uno per le intestazioni della tabella e uno per le righe effettive. Una volta terminato il riempimento dei <span style="font-style: italic;">Vector</span>, è necessario informare il modello (<span style="font-style: italic;">DefaultTableModel</span>) di utilizzare i dati in essi contenuti per la visualizzazione; questo è ottenuto con la chiamata al metodo <span style="font-style: italic;">setDataVector(..)</span>.<br />Si noti che il modello consente anche di gestire le modifiche apportate ai dati attraverso la tabella stessa: il metodo <span style="font-style: italic;">tableChanged(..)</span> dell'interfaccia implementata <span style="font-style: italic;">TableModelListener</span> consente di catturare la riga e la colonna (cella) modificata e il suo nuovo valore. Da tenere presente che il vettore <span style="font-style: italic;">dataVector</span> è un <span style="font-style: italic;">Vector</span> protetto nella superclasse <span style="font-style: italic;">DefaultTableModel</span>, e quindi accessibile. Attenzione: la modifica al modello, come si può notare, non implica automaticamente la scrittura dei nuovi dati nel database! E' necessario implementare una qualche logica di gestione della serializzazione dei dati verso il database (ad esempio usando dei <span style="font-style: italic;">ResultSet aggiornabili</span>).<br /><br />L'utilizzo del modello sopra illustrato nei propri programmi risulta piuttosto semplice:<br /><br /><pre>GenericTableModel model = new GenericTableModel();<br />JTable table = new JTable( model );<br />...<br />model.parseResultSet( rs );<br /></pre>