---
layout: post
title: Another baby Perl program from a backup in the attic
date: '2017-04-29T11:32:00.001+02:00'
author: Luca Ferrari
tags:
- perl
- planet-perl-ironman
modified_time: '2017-04-29T17:28:30.414+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-3580882290061796047
blogger_orig_url: http://fluca1978.blogspot.com/2017/04/another-baby-perl-program-from-backup.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


This is a simple script that takes all arguments on the command line and returns a list of directories for each argument.<br />I don't remember at all what the purpose of this was, probably something to process a set of directories via a batch starting from<br />a set of filenames.<br />By the way, let's say how baby I was at that time…<br /><br /><br /><div class="outline-3" id="outline-container-sec-1-1"><h3 id="sec-1-1"><span class="section-number-3">1.1</span> Baby Code</h3><div class="outline-text-3" id="text-1-1">Here it is, please note how long the code is…<br /><br /><br /><div class="org-src-container"><br /><pre class="src src-perl">#!/usr/bin/perl<br /><br /># This script manipulates all its arguments returning a list of string which<br /># are the directory of all files. For example if the argument is<br /># /home/luca/file.txt only /home/luca/ is returned (note the last backslash).<br /><br /><br /># return array<br />@ret;<br /><br />foreach $name (@ARGV){<br /><br /><br />    if( -f $name ){<br /><br /> # check if the name contains a /, if no the directory must be the current one (./)<br /> if(not  $name =~ /\// ){<br />     $ret[++$#ret] = "./";<br /> }<br /> else{<br /><br />     @parts;<br />     $dir;<br /><br />     # split into the section with /<br />     @parts = split("/",$name);<br /><br /><br />     if( defined(@parts) ){<br /><br />  for($i=0; $i &lt; $#parts; $i++){<br />      $dir .= $parts[ $i ]."/";<br />  }<br />     }<br /><br /><br />     # put the result inot the array<br />     $ret[++$#ret] = $dir;<br /> }<br />    }<br />    elsif( -d $name ){<br /><br /><br /> # this is a directory, simply check if ends with the slash<br /> if( not $name =~ /\/$/ ){<br />     $name .= "/";<br /> }<br /><br /> $ret[++$#ret] = $name;<br />    }<br />}<br /><br /><br /># all done, print the array<br />foreach $name (@ret){<br />    print $name."\n";<br /><br />}<br /></pre></div></div></div><br /><div class="outline-3" id="outline-container-sec-1-2"><h3 id="sec-1-2"><span class="section-number-3">1.2</span> The teen-ager code</h3><div class="outline-text-3" id="text-1-2">What if I have to write a similar service today?<br />That is the very first code that comes into my mind:<br /><br /><br /><div class="org-src-container"><br /><pre class="src src-perl">#!env perl<br /><br />use v5.20;<br />use File::Spec;<br /><br />my @dirs;<br />for ( @ARGV ){<br />    push @dirs, $_ if ( -d $_ );<br />    push @dirs, ( File::Spec-&gt;splitpath( $_ ) )[ 1 ] if ( -f $_ );<br />}<br /><br />{<br />    local $" = "/\n";<br />    say "@dirs";<br />}<br /></pre></div><br />A lot less, uh?<br />It could be simpler, but so far I don't know any module to return the directory part of a path when a file is provided as argument, and<br />this is the reason I need to distinguish between the <code>-f</code> and <code>-d</code> cases.<br /><br /><br />The adoption of the list separator <code>$"</code> is specific to add the trailing backslash and to place every single directory on its own line. Of course this means, as $" suggests, that the array has to be printed via doubled quoted print. Here the adoption of say</div></div>or <code>print</code> is totally equivalent.<br /><br /><br />Let be honest here: the adoption of <code>local</code> and the surrounding block could be avoided, since the script exits implicitly right after<br />such couple of instructions, and this means the code could even be simpler, or better, shorter, but let's keep some good habits!<br /><div class="status" id="postamble"><br /></div>