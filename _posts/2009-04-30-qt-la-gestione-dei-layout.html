---
layout: post
title: 'Qt: la gestione dei layout'
date: '2009-04-30T08:30:00.005+02:00'
author: Luca Ferrari
tags:
- c++
- qt
- programmazione
modified_time: '2011-08-19T13:40:03.469+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-1110327615544660774
blogger_orig_url: http://fluca1978.blogspot.com/2009/04/qt-la-gestione-dei-layout.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


I layout della libreria Qt, classi ereditare da QLayout, sono molto potenti e semplici da usare. I programmatori di Trolltech hanno fatto un così buon lavoro che dalla prima versione della libreria ad oggi esistono pochissimi layout (QGridLayout, QHBoxLayout, QVBoxLayout) capaci di svolgere tutte le funzioni che complessi layout manager svolgono in altri GUI-toolkit.<br />Tuttavia la gestione di un layout in Qt potrebbe portare a qualche dubbio circa dove gli oggetti sono collegati e a come funzionano. Consideriamo il seguente esempio:<br /><br /><span style="font-style: italic;">QWidget* container = new QWidget();</span><br /><span style="font-style: italic;">QHBoxLayout* layout = new QHBoxLayout( container );</span><br /><span style="font-style: italic;">QPushButton* b1 = new QPushButton("Pulsante 1", container);</span><br /><span style="font-style: italic;">QPushButton* b2 = new QPushButton("Pulsante 2", container);</span><br /><span style="font-style: italic;">layout-&gt;addWidget( b1 );</span><br /><span style="font-style: italic;">layout-&gt;addWidget( b2 );</span><br /><span style="font-style: italic;">container-&gt;setLayout( layout );</span><br /><br />Il fatto "anomalo" è che i pulsanti vengono creati avendo come parent il widget <span style="font-style: italic;">container</span>, e poi vengono anche aggiunti al layout, che a sua volta è usato dal container per disporre i widget. Ma perché è necessario "aggiungere" i componenti sia al pannello contenitore che al layout? La ragione di cio' risiede nel modo in cui i layout funzionano.<br />Ogni layout mantiene al suo interno una struttura interna con riferimenti ai widget da visualizzare (es. una lista); quando il widget che ha impostato il layout necessita di una visualizzazione, il layout scorre la lista dei suoi widget e calcola la geometria di ognuno di essi (ad esempio la dimensione di un pulsante). Per ogni componente il layout invoca <span style="font-style: italic;">setGeometry()</span> in modo da specificare come e dove visualizzare il widget. Invece la relazione di parentela fra i widget è necessaria per la gestione della memoria Qt. Ecco quindi che ogni widget deve essere aggiunto ad un genitore affinché si abbia la gestione della memoria, e ad un layout affinché quest'ultimo possa calcolarne le dimensioni.<br />Rapportando il codice di cui sopra a Java si nota come quest'ultimo risulta molto piu' compatto:<br /><br /><span style="font-style: italic;">JPanel container = new JPanel();</span><br /><span style="font-style: italic;">FlowLayout layout = new FlowLayout();</span><br /><span style="font-style: italic;">container.setLayout( layout );</span><br /><span style="font-style: italic;">JButton b1 = new JButton("Pulsante 1");</span><br /><span style="font-style: italic;">JButton b2 = new JButton("Pulsante 2");</span><br /><span style="font-style: italic;">container.add( b1 );</span><br /><span style="font-style: italic;">container.add( b2 );</span><br /><br />Quello che si nota è che i componenti vengono aggiunti solo al pannello container, che si fa carico poi di aggiungerli (o comunicare la loro presenza) al layout manager quando necessario. L'approccio Qt è invece inverso, si delega la gestione dei componenti al layout manager che li deve gestire esplicitamente. Inoltre è possibile avere casi in cui un componente non deve essere aggiunto al layout (magari perché non visibile) ma deve far parte comunque del widget (ad esempio per la gestione della memoria). Ad ogni modo l'approccio Qt è convertibile in quello Java adattando il codice di un Widget affinché passi la sua lista di Widget al layout nel momento in cui questo la debba conoscere. E' una scelta implementativa.<br /><br />Da notare poi che nelle ultime versioni della libreria è anche possibile scrivere codice piu' compatto, come il seguente:<br /><br /><span style="font-style: italic;">QWidget* container = new QWidget();</span><br /><span style="font-style: italic;">QHBoxLayout* layout = new QHBoxLayout( container );</span><br /><span style="font-style: italic;">QPushButton* b1 = new QPushButton("Pulsante 1");</span><br /><span style="font-style: italic;">QPushButton* b2 = new QPushButton("Pulsante 2");</span><br /><span style="font-style: italic;">layout-&gt;addWidget( b1 );     // internamente esegue b1-&gt;setParent( container );</span><br /><span style="font-style: italic;">layout-&gt;addWidget( b2 );     // internamente esegue b2-&gt;setParent( container );</span><br /><span style="font-style: italic;">container-&gt;setLayout( layout );</span><br /><br />In questo caso i componenti sono aggiunti direttamente e solo al layout, che viene poi usato come layout manager di un widget principale. Si presti attenzione però al fatto che il layout manager fa solo da "passacarte" fra il widget principale e quelli secondari. Infatti ogni widget aggiunto al layout manager non appartiene al layout (ovvero non ha come parent il layout manager, poiché un widget può avere come parent solo un altro widget), bensì il layout manager imposta il parent di ogni widget al container che sta usando il layout.<br /><br /><br /><span style="font-weight: bold;">Differenze con Java</span><br />L'approccio Java al layout è molto simile, ma la lista dei componenti non è nota a priori al layout, che riceve in ingresse al momento necessario il <span style="font-style: italic;">parent,</span> ossia il componente contenitore (ad esempio un JPanel). Il layout richiede quindi al componente la lista di tutti i componenti e li posiziona geometricamente usando <span style="font-style: italic;">setBounds()</span> su ogni componente.<br />La differenza fra i due approcci risulta quindi nella posizione in cui la lista dei componenti da sottoporre a layout viene gestita.