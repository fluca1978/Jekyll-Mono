---
layout: post
title: Hey students, don't buy the teachers' lies!
date: '2017-02-04T09:57:00.000+01:00'
author: Luca Ferrari
tags:
- universit√†
- programmazione
- shell
modified_time: '2017-02-04T09:57:09.411+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-150344399389986984
blogger_orig_url: http://fluca1978.blogspot.com/2017/02/hey-students-dont-buy-teachers-lies.html

permalink: /:year/:month/:day/:title.html
---


<h1>~</h1>


<div style="text-align: justify;">When I was an university student I had a teacher in the Operating Systems subject that teached me (and a lot of others) to program so bad in shell scripting! I will not name her, but I had to say that today I find the very same errors around the scripts that my colleagues write every day, and this is a kind of watermark of the damage she did.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Luckily I find my way out, studying on other books and practicing on my own (Linux) computer.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">So what were the problems?</div><div style="text-align: justify;">To understand it must be clear the exercise schema the teacher was adopting, and that was pretty much always the same: a main script (let's call "coordinator" which aim is to parse the argument list and invoke, using recursion, a "worker" script.</div><div style="text-align: justify;">Something that can be shown as the following code:</div><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">#!/bin/sh</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># coordinator</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># argument validation...</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># export the current directory</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># in the path to invoke the worker script</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">PATH=$PATH:`pwd`</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">export PATH</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"># first call of the worker</span><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">worker </span><arguments><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span><br /><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">#!/bin/sh<br /># worker<br /><br /># recursion on myself<br />for f in *<br />do<br />  if [ -d $f ]<br />     then<br />        worker f<br />     fi<br />done<br /><br /># do other work...</span><br /><br /><br /></arguments><arguments>The first problem, in my opinion, is the usage of relative paths to invoke the worker script, and therefore the need for exporting the PATH variable. First of all, launching a script with a relative path makes it a little slower to launch, since the shell itself has to search for the script against each PATH entry. Second, and much more important, it is the key to exploitation: not having the control over the full path of the script it is possible to inject a malicious script somewhere in the PATH and use it as a worker.</arguments><br /><arguments>When I objected the above to the teacher, the answer was to simply invert the PATH manipulation order:</arguments><br /><arguments></arguments><br /><arguments><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">PATH=`pwd`:$PATH</span></arguments><br /><arguments><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">export PATH</span></arguments><br /><arguments></arguments><br /><arguments>But again, this is a kick in the ass of security: what if I name my script as another system wide command? I can alter the behaviour of this and other programs...</arguments><br /><arguments>So what is the solution? Of course invoke the worker script with an absolute path and to not manipulate the PATH variable. After all, what is the point in showing (to the teacher) you can export a variable?</arguments><br /><arguments></arguments><br /><arguments>Another problem is the recursion on the worker script: usually such script was scanning a directory content, invoking itself each time a subdirectory was found. Now, while this can work in theory, you can easily imagine the worker script becoming a fork-bomb. It is quite easy to see how find(1), xargs(1) and friends can help in this situation.</arguments><br /><arguments></arguments><br /><arguments>Another oddity that comes into my mind is the way students were forced to test if an argument was an absolute path or a relative one:</arguments><br /><arguments></arguments><arguments><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">case $1 in<br />   /*) # absolute<br />      ;;<br />   *) # relative<br />      ;;<br />esac</span><br /><br />Do you believe the above is easy to read? Is it efficient and does it scale well? Why not using Unix tools and pipes, regular expressions and awk? even better, getopt anyone?<br /><br />So, dear ex-teacher, what is the whole point in teaching such shit?<br /></arguments>