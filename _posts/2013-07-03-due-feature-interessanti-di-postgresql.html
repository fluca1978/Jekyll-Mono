---
layout: post
title: Due feature interessanti di PostgreSQL 9.3
date: '2013-07-03T23:49:00.000+02:00'
author: Luca Ferrari
tags:
- postgresql
modified_time: '2013-07-03T23:49:00.373+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-2232008099053747575
blogger_orig_url: http://fluca1978.blogspot.com/2013/07/due-feature-interessanti-di-postgresql.html
---

<div style="text-align: justify;">Una delle nuove funzionalita' disponibile con l'imminente usicta di PostgreSQL 9.3 e' il <a href="http://michael.otacoo.com/postgresql-2/postgres-9-3-feature-highlight-data-checksums/">controllo contro la corruzione delle pagine dati</a>.</div><div style="text-align: justify;">Nell'era degli hard disk dalle dimensioni enormi, dei dispositivi di memorizzazione portatile e, soprattutto, dei sistemi di reivisione che includono hash crittografici, il controllo contro la corruzione dei dati persistenti e' fondamentale. Non e' un problema di <i>se si rompera' il disco</i> quanto di <i>quando si rompera</i>'.</div><div style="text-align: justify;">Simon Riggs, con l'aiuto di altri sviluppatori, ha introdotto un controllo sulle pagine dati mediante un CRC a 16 bit. Sostanzialmente ogni volta che una pagina viene flushata dal memory buffer al disco ne viene calcolato un checksum. Quando la pagina viene ricaricata in memoria il checksum viene controllato.</div><div style="text-align: justify;">Cosa succede se il checksum non corrisponde?</div><div style="text-align: justify;">Ci sono due alternative: la prima consiste nell'<i>ignorare</i> l'errore e procedere ugualmente, e questa e' ovviamente quella sconsigliata. La seconda prevede che la pagina <i>non</i> sia caricata, ovvero che le tuple non siano accessibili, con conseguente errore di I/O sulla transazione. In sostanza PostgreSQL non e' in grado di prendere alcuna decisione e quindi indica l'errore, lasciando la scelta su cosa fare (accedere i dati forzatamente) al DBA.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Il controllo di coerenza sulla pagina dati deve essere abilitato all'atto di inizializzazione del cluster (ossia initdb) e ovviamente richiedera' un certo ammontare di CPU, che si traduce in un leggero calo di performance (non si puo' avere tutto!). Inoltre sara' disponibile anche un GUC (ossia un parametro di configurazione) per impostare la decisione circa il comportamento in caso di errore.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Un'altra funzione veramente molto interessante e' la presenza di <a href="http://www.postgresql.org/docs/devel/static/pgxlogdump.html">WAL log human readable</a>. La funzione permettera' una analisi dei record contenuti nei WAL e, da una veloce analisi del codice sorgente, il cuore e' rappresentato dal seguente frammento:</div><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">static void</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">XLogDumpDisplayRecord(XLogReaderState *state, XLogRecord *record)</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">{</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">...</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;printf("xlog record: rmgr: %-11s, record_len: %6u, tot_len:&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %6u, tx: %10u, lsn: %X/%08X, prev&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %X/%08X, bkp: %u%u%u%u, desc:",</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc-&gt;rm_name,</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record-&gt;xl_len, record-&gt;xl_tot_len,</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record-&gt;xl_xid,</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (uint32) (state-&gt;ReadRecPtr &gt;&gt; 32),&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (uint32) state-&gt;ReadRecPtr,</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (uint32) (record-&gt;xl_prev &gt;&gt; 32),&nbsp;</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (uint32) record-&gt;xl_prev,</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !!(XLR_BKP_BLOCK(0) &amp; record-&gt;xl_info),</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !!(XLR_BKP_BLOCK(1) &amp; record-&gt;xl_info),</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !!(XLR_BKP_BLOCK(2) &amp; record-&gt;xl_info),</span></span><br /><span style="font-size: xx-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !!(XLR_BKP_BLOCK(3) &amp; record-&gt;xl_info));</span></span><br /><div style="text-align: justify;"><br /></div><div style="text-align: justify;">La funzione era gia' stata annunciata al precedente <a href="http://2012.pgday.it/">PGDay.IT 2012</a>, e pone le basi per la multi-master replication.</div>