---
layout: post
title: Do you like booleans?
date: '2013-07-03T19:44:00.000+02:00'
author: Luca Ferrari
tags:
- programming best practice
modified_time: '2013-07-03T19:44:00.111+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-4008846926494340148
blogger_orig_url: http://fluca1978.blogspot.com/2013/07/do-you-like-booleans.html
---

<div style="text-align: justify;">Booleans: you love them or you hate them.</div><div style="text-align: justify;">Personally, I hate them.</div><div style="text-align: justify;">What is wrong with booleans? Nothing, except that they are often used in the wrong way.</div><div style="text-align: justify;">A boolean (that is a condition that is either true or false) can be used only to test a single, autonomous condition. The key word here is "<i>autonomous</i>": the boolean can indicate only one truth at a time.</div><div style="text-align: justify;">And developers, of course, know the truth!</div><div style="text-align: justify;">So you can end up with some code like the following:</div><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">void foo( boolean conditionA, boolean conditionB ){</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span></span><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; if ( conditionA ){ doA(); }</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; else if ( conditionB ){ doB(); }</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; else doPanic();</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span></span><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">}</span></span><br /><br /><br /><div style="text-align: justify;">that is working fine until conditionA and conditionB are totally indipendent. That means not only that a value affects the other, but also that there must be no priority between conditionA and conditionB.</div><div style="text-align: justify;">To better understand, suppose that there is a new constraint that imposes that whener conditionA is false, conditionB cannot be true too. Therefore the code becomes:</div><br /><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">void foo( boolean conditionA, boolean conditionB ){</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; if ( ! conditionA )</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; conditionB = false;</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span></span><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; if ( conditionA ){ doA(); }</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; else if ( conditionB ){ doB(); }</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; else doPanic();</span></span><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span></span><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">}</span></span><br /><br />Due to the above constraint, there is now a less number of cases:<br /><ul><li>case 1: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">conditionA = true</span> and <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">conditionB = true;</span></li><li>case 2: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">conditionA = false</span> and <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">conditionB = false</span>;</li><li>case 3: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">conditionA = true</span> and <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">conditionB = false</span>.</li></ul><br /><div style="text-align: justify;">So there are now three possible cases out of four using two booleans.</div><div style="text-align: justify;">Sooner or later, you will miss some check against the possible values and your code, by the way, will result difficult to read. Consider someone who wants to use your API and that has access only to the prototype of the code:</div><br /><span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">void foo( boolean conditionA, boolean conditionB )</span></span><br /><br /><div style="text-align: justify;">You have to clearly mantain the documentation explaining that the case <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">{false, true}</span> cannot be applied.</div><div style="text-align: justify;">So what is the solution?</div><div style="text-align: justify;">Instead of having to deal with not-so-boolean booleans, consider using other way of representing a finite, well know, set of possibilities, like enumerations or "old-style" hex variables. They will make your code cleaner and easier to read, and will scale once you have to introduce new constraints.</div>