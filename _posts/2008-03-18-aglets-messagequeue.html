---
layout: post
title: The Aglets MessageQueue
date: '2008-03-18T23:20:00.001+01:00'
author: Luca Ferrari
tags:
- aglets
- universit√†
- java
modified_time: '2008-03-19T08:30:34.352+01:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-3857508154616445172
blogger_orig_url: http://fluca1978.blogspot.com/2008/03/aglets-messagequeue.html
---

Each agent stores incoming messages into a message queue (<span style="font-style: italic;">com.ibm.aglets.MessageQueue</span>); the message insertion into the message queue is transparently done by the delivering of a message.<br /><br />The idea is that a message manager creates its own message queue  and uses it to store message before it has activate a thread to process it. The use of a message queue  allows the uncoupling of agent threads. In fact when an agent sends a message to another agent, the sending thread  thru several method calls inserts the message in the message queue, and thus the sender thread returns. Thus the  sender thread is involved until the message has been inserted in the message queue. Once this is done, it is the addressee  thread in charge of processing the message itself, and this is done by the message manager that gets a thread  and pops a message from the message queue.<br /><br />The following is the implementation of the <span style="font-style: italic;">MessageQueue</span> in the current development tree. As readers can see, the queue exploits a simple <span style="font-style: italic;">List</span> to store messages that must be processed. All the methods implements the appropriate logic (e.g., priority) working around such list. Please note that the message queue is parametrizable thru Java Generics.<br /><br /><pre><span style="font-size:85%;">public class MessageQueue<msg extends="" message=""> {<br /><br />   <br />  /**<br />   * The messages will be stored into a linked list.<br />   */<br />  private List<msg> messages = new LinkedList<msg>();<br /><br /><br /><br /> /**<br />  * Appends a message, that is places the message at the end of the queue.<br />  * @param msg the message to append<br />  */<br /> public synchronized void append(MSG msg){<br />     // check params<br />     if( msg == null )<br />  return;<br />   <br />     // append the message at the tail<br />     this.messages.add(msg);<br /> }<br /><br /> /**<br />  * Inserts a new message in the queue. The alghoritm is the following:<br />  * each message is extracted from the queue and analyzed; at the first message with<br />  * a priority less than the one we want to insert, the message is inserted. If no one<br />  * message is found, than the message is placed at the tail of the queue.<br />  * @param msg the message to insert<br />  */<br /> public synchronized void insert(MSG msg){<br />     // check params<br />     if( msg == null )<br />  return;<br />   <br />   <br />     Iterator iter = this.messages.iterator();<br />   <br />     while (iter != null &amp;&amp; iter.hasNext()) {<br />  MSG currentMessage = (MSG) iter.next();<br />  if( currentMessage.getPriority() < msg.getPriority() ){      <br />                  int index = this.messages.indexOf(currentMessage);      <br />                  this.messages.add(index, msg);      <br />                  return;   <br />               }     <br />           }          <br />           // if here the message must be placed at the tail of the queue     <br />           this.messages.add(msg);  <br />        }        <br />      <br />        /**  <br />          * Inserts the message at the top of the queue. Please note that this method will  <br />          * overtake the priority mechanism, thus it is possible to insert at the top a message  <br />          * with a low priority.  <br />          * @param top the message to place at the head of the list  <br />          */  <br />          public synchronized void insertAtTop(MSG top){     <br />                if( top == null )   return;          <br />                // place the message at the head of the queue     <br />                this.messages.add(0, top);  <br />           }    <br /><br />          public synchronized void insertAtTop(MessageQueue<msg> queue) {<br />     if( queue == null || queue.isEmpty() )<br />  return;<br />     else{<br />  this.messages.addAll(0, queue.messages);<br />     }<br /> }<br /> <br /> <br /> public int size(){<br />     return this.messages.size();<br /> }<br /> <br /> public boolean isEmpty(){<br />     return this.messages.isEmpty();<br /> }<br /><br /> /**<br />  * Gets (but don't remove) the message at the top of the queue.<br />  * @return the message at the top.<br />  */<br /> public synchronized MSG peek(){<br />     if( ! this.messages.isEmpty() )<br />  return this.messages.get(0);<br />     else<br />  return null;<br /> }<br /> <br /> <br /> /**<br />  * Extract (i.e., remove) the message at the top of the queue.<br />  * @return the message at the top or null<br />  */<br /> public synchronized MSG pop(){<br />     if( this.messages.isEmpty() )<br />  return null;<br />     else<br />  return this.messages.remove(0);<br /> }<br /> <br /> <br /> <br /> /**<br />  * Removes a message from the queue.<br />  * @param msg the message to remove<br />  * @return true if the message has been removed, false otherwise<br />  */<br /> public synchronized boolean remove(MSG msg){<br />     if( this.messages.contains(msg) ){<br />  this.messages.remove(msg);<br />  return true;<br />     }<br />     else<br />  return false;<br /> }<br /> <br /> /**<br />  * Removes all the messages from the queue, that is after this the queue will be<br />  * empty.<br />  *<br />  */<br /> public synchronized void removeAll(){<br />     if( ! this.messages.isEmpty() )<br />  this.messages.clear();<br /> }<br /> <br /> <br /> public String toString() {<br />     StringBuffer buffer = new StringBuffer(50 * this.messages.size() );<br />   <br />     buffer.append("The message queue contains " + this.messages.size() + " messages");<br />     for(int i=0; i< this.messages.size(); i++){   <br />               buffer.append("\n");   <br />               for(int j=i; j>0; j--)  // make a few indentation spaces<br />      buffer.append(" ");<br />  <br />  buffer.append("message " + i +")" + this.messages.get(i));  <br />     }<br />   <br />     return buffer.toString();<br /> }<br />}</msg></msg></msg></msg></span></pre><span style="font-size:85%;"><br /></span>