---
layout: post
title: Programmazione ad oggetti in C
date: '2008-02-10T15:19:00.000+01:00'
author: Luca Ferrari
tags:
- linux
- università
- programmazione
- java
modified_time: '2008-09-08T13:51:47.659+02:00'
blogger_id: tag:blogger.com,1999:blog-1836481905487384887.post-2765525550651622533
blogger_orig_url: http://fluca1978.blogspot.com/2008/02/programmazione-ad-oggetti-in-c.html
---

La programmazione ad oggetti (OOP) è un potente paradigma utilizzato nella realizzazione di molti sistemi moderni. L'OOP è solitamente supportata a livello di linguaggio: il linguaggio mette a disposizione del programmatore una serie di astrazioni per realizzare i principi della OOP (incapsulamento, ereditarietà, polimorfismo). Ad esempio, in Java è disponibile il concetto di <span style="font-style: italic;">class</span>, gli specificatori di accesso, l'estensione delle classi in ereditarietà (<span style="font-style: italic;">extends</span>) e il polimorfismo sui metodi. In C++, similarmente, viene messo a disposizione il concetto di <span style="font-style: italic;">class</span>, gli specificatori di accesso, l'ereditarietà (operatore : ) e il polimorfismo tramite le <span style="font-style: italic;">virtual table</span>.<br /><br />Programmare OOP con un linguaggio che supporta direttamente l'OOP è sicuramente molto comodo, ma questo non significa che solo con il supporto del linguaggio sia possibile programmare OOP. In questo articolo riassumo un'esempio didattico di programmazione OOP in linguaggio C, scritto da me come esercitazione per il corso di<a href="http://polaris.ing.unimo.it/didattica/fiC/laboratorio.html#es1"> Fondamenti di Informatica C (prof. Cabri)</a>, Università di Modena e Reggio Emilia.<br /><br /><span style="font-weight: bold; font-style: italic;">Considerazioni preliminari</span><br />Per ottenere un sistema OOP si deve riuscire ad implementare un tipo di dato astratto (classe),  nascondere i dettagli implementativi di tale tipo di dato astratto (incapsulamento), rendere pubblici e accessibili determinati servizi (incapsulamento), consentire l'ereditarietà e rendere possibile il polimorfismo.<br />Il linguaggio C mette a disposizione le <span style="font-style: italic;">struct</span>, che possono essere utilizzate per la definizione di un tipo di dato astratto (se dichiarate opportunamento con <span style="font-style: italic;">typedef</span>). E' interessante notare come una <span style="font-style: italic;">struct</span> possa contenere sia dati che puntatori a funzioni, e quindi possa contenere sia informazioni che servizi. Questo rende una struct molto simile ad una classe, anche se non consente di usare nessun specificatore di accesso (incapsulamento) e ereditarietà. E' comunque possibile utilizzare le struct per realizzare delle classi, e per farlo è necessario riuscire a nascondere i dettagli implmentativi privati (incapsulamento) e fornire supporto per ereditarietà. Si noti che il supporto per il polimorfismo è naturalmente garantito: siccome le struct possono contenere puntatori a funzioni, è sufficiente variare uno di tali puntatori per farlo puntare ad una funzione (e quindi ad un comportamento) differente.<br /><br /><span style="font-weight: bold; font-style: italic;">Descrizione dell'esempio</span><br />L'esempio qui proposto è molto semplice: si vuole realizzare un tipo di dato corrispondente ad un <span style="font-style: italic;">conto corrente</span>, quindi con saldo e servizi relativi all'aggiustamento di tale saldo (versamento, prelievo, stampa, riepilogo movimenti). Si consideri una definizione Java relativa ad una classe <span style="font-style: italic;">ContoCorrente</span>:<br /><br /><pre>public class ContoCorrente{<br />   // dato incapsulato: saldo corrente<br />   private float saldo = 0;<br /><br />   // dato incapsulato: array dei movimenti<br />   private float[] movimenti;<br /><br />   // dato incapsulato: numero di conto<br />   private int numeroConto = 0;<br /><br />   // costruttore<br />   public ContoCorrente(int numeroConto);<br /><br />   // restituisce il saldo corrente<br />   public int  m_saldo();<br /><br />   // stampa i dati del contocorrente<br />   public void m_stampa();<br /><br />   // versamento<br />   public int  m_versamento(int ammontare);<br /><br />   // prelievo<br />   public int  m_prelievo(int ammontare);<br /><br />   // stampa dei movimenti<br />   public void m_stampa_movimenti();<br />}<br /></pre><br />Come si può notare, dall'esterno della classe non è visibile nessuna informazione circa l'implementazione del conto corrente (ossia come e dove sono memorizzate le informazioni dei movimenti, del saldo e del numero di conto). Gli unici servizi pubblici sono i metodi che consentono di agire sul conto corrente stesso.<br />Nel seguito si implementerà la classe Java di cui sopra in linguaggio C.<br /><br /><span style="font-weight: bold; font-style: italic;">Implementazione tramite struct</span><br />E' necessario implementare due struct differenti, una pubblica e una privata. La struct pubblica deve contenere ogni membro pubblico della classe, nell'esempio di cui sopra solo funzioni (puntatori a funzioni). La struct privata conterra' invece i dettagli implementativi, ossia ogni membro non pubblico della classe di cui sopra. Ma come sono legate le due struct? Qui entra in gioco la potenza dei puntatori C: se le due strutture condividono lo stesso layout, allora è possibile effettuare un cast da una struttura all'altra. Ovviamente, essendo differenti, le due strutture non possono avere lo stesso layout, ma possono avere lo stesso layout delle parti sovrapposte.<br /><br />Si consideri per prima la struttura pubblica, che risulta essere la seguente:<br /><br /><pre>typedef struct CCPUB{<br />// puntatore alla funzione getSaldo<br />int (*m_saldo)(struct CCPUB* );<br /><br />// puntatore alla funzione StampaContoCorrente<br />void (*m_stampa)(struct CCPUB*);<br /><br />// puntatore alla funzione versamento<br />int (*m_versamento)(struct CCPUB*, int);<br /><br />// puntatore alla funzione prelievo<br />int (*m_prelievo)(struct CCPUB*, int);<br /><br />// puntatore alla funzione stampaMovimenti<br />void (*m_stampa_movimenti)(struct CCPUB*);<br />} ContoCorrentePub;</pre><br />Come già detto sopra, la struttura pubblica contiene solo puntatori a funzione, essendo quelli gli unici membri pubblici specificati. La struttura privata deve includere anche i dati relativi a saldo, array dei movimenti, e numero di conto. Se queste informazioni vengono memorizzate in una struttura privata che abbia la stessa parte iniziale di quella pubblica, allora le due possono diventare compatibili. In altre parole, le strutture devono avere la stessa parte pubblica disposta nello stesso modo:<br /><br /><pre>         - +--------------+ -<br />       | |   m_saldo    | |<br />       | +--------------+ |<br />       | |   m_stampa   | |<br />Conto    | +--------------+ | Conto<br />Corrente | | m_versamento | | Corrente<br />Pub      | +--------------+ | Private<br />       | | m_prelievo   | |<br />       | +--------------+ |<br />       | |m_stampa_movim| |<br />       - +--------------+ |<br />         | NumeroConto  | |<br />         +--------------+ |<br />         |    Saldo     | |<br />         +--------------+ |<br />         |   Movimenti  | |<br />         +--------------+ |<br />         |   cur_mov    | |<br />         +--------------+ -</pre><br />Avendo definito il layout delle strutture in questo modo, è possibile allocare la memoria necessaria a contenere tutte le informazioni (quindi la struttura privata) e rendere accessibile all'esterno solo un puntatore alla struttura pubblica. Così facendo, la struttura pubblica, o meglio il suo puntatore, impedisce l'accesso ai membri privati, mentre la memoria condivisa garantisce che le strutture siano sempre allineate. Ovviamente la conversione da struttura pubblica a privata non deve essere effettuata all'esterno, ma all'interno dei metodi pubblici del tipo di dato astratto. Infatti, sono solo questi che devono avere accesso alla struttura privata, e quindi come prima operazione di ogni metodo pubblico, occorre convertire il puntatore affinché punti alla propria struttura privata.<br />Si ipotizzi di aver memorizzato la dichiarazione (si tratta solo di una dichiarazione) della struttura ContoCorrentePub in un file CC_pub.h, che è l'unico header richiesto per poter usare il conto corrente. All'interno di un alto file CC_private.c si inserirà la dichiarazione della struttura completa dei membri privati:<br /><br /><pre>typedef struct{<br />// puntatore alla funzione getSaldo<br />int (*m_saldo)(ContoCorrentePub*);<br /><br />// puntatore alla funzione StampaContoCorrente<br />void (*m_stampa)(ContoCorrentePub*);<br /><br />// puntatore alla funzione versamento<br />int (*m_versamento)(ContoCorrentePub*, int);<br /><br />// puntatore alla funzione di prelievo<br />int (*m_prelievo)(ContoCorrentePub*, int);<br /><br />// puntatore alla funzione di stampa dei movimenti<br />void (*m_stampa_movimenti)(ContoCorrentePub*);<br /><br />//------------------------------------------<br /><br />// dati nascosti<br />int NumeroConto;   // numero del conto corrente<br />int Saldo;    // saldo attuale<br />int Movimenti[MAX_MOVIMENTI];  // lista degli ultimi movimenti<br />int cur_mov;    // indice del movimento corrente<br />} ContoCorrentePrivate;<br /></pre><br />All'interno dello stesso file si definiranno due metodi <span style="font-style: italic;">privati</span> che consentono la conversione da un conto corrente pubblico ad uno privato:<br /><br /><pre>/*<br />* Servizio privato di conversione dalla struttura pubblica a quella privata.<br />* Questa funzione accetta il puntatore alla struttura pubblica e lo converte in quello a<br />* struttura privata.<br />*/<br />static ContoCorrentePrivate* Public2Private(ContoCorrentePub* ccpub){<br /><br /><br />ContoCorrentePrivate* ccpriv = NULL; // puntatore da ritornare<br /><br />// controllo se il puntatore è valido, e in caso punti realmente<br />// alla struttura pubblica lo converto (operazione di casting)<br />// nella struttura privata<br />if( ccpub != NULL ){<br />printf("\n\t[Public2Private] conversione della struttura da pub a private");<br />ccpriv = (ContoCorrentePrivate*) ccpub;<br />}<br /><br />return ccpriv;<br />}<br /><br /><br /><br />/*<br />* Servizio privato di conversione della struttura privata in quella pubblica.<br />* La funzione accetta il puntatore alla struttura privata e, se quest'ultimo è<br />* valido, lo converte in un puntatore alla struttura pubblica.<br />*/<br />static ContoCorrentePub* Private2Public(ContoCorrentePrivate* ccpriv){<br /><br />ContoCorrentePub* ccpub = NULL;  // puntatore da restituire<br /><br />// controllo se il puntatore è valido, e in caso affermativo<br />// lo converto in un puntatore alla struttura pubblica<br />if( ccpriv != NULL ){<br />printf("\n\t[Private2Pub] conversione della struttura da private a pub");<br />ccpub = (ContoCorrentePub*) ccpriv;<br />}<br /><br />return ccpub;<br />}<br /></pre><br />Come si può notare queste due funzioni sono piuttosto semplici: dichiarano il tipo di puntatore necessario e effettuano un semplice cast. Si noti che le funzioni sono dichiarate <span style="font-style: italic;">static</span>, cosa che garantisce il fatto che esse siano private e confinate a CC_private.c.<br /><br />A questo punto si consideri l'implementazione di uno dei metodi pubblici del conto corrente, per esempio quello relativo ad un versamento:<br /><br /><pre>/*<br />* Servizio pubblico di versamento.<br />* Questo servizio accetta come parametro il puntatore alla struttura pubblica, provvede<br />* alla sua conversione a privata ed esegue il versamento.<br />* La funzione ritorna l'effettivo ammontare versato.<br />*/<br />int versamento(ContoCorrentePub* ccpub, int ammontare){<br />ContoCorrentePrivate* ccpriv;<br /><br /><br />// controllo che il puntatore sia valido e che l'ammontare sia positivo<br />if( ccpub == NULL || ammontare <= 0 ){   return 0;  }   // effettuo il versamento  ccpriv = Public2Private( ccpub );  ccpriv->Saldo += ammontare;<br />registraMovimento( ccpriv, ammontare );<br />return ammontare;<br />}<br /></pre>Come si nota, il metodo effettua la conversione dalla struttura pubblica a quella privata, dopodiché lavora sui membri privati (es. Saldo). Analogamente, le altre funzioni si comporteranno in modo simile: effettueranno la conversione e lavoreranno sulla parte privata della struttura.<br /><br /><span style="font-weight: bold; font-style: italic;">Creazione di un oggetto Conto Corrente</span><br />Resta da considerare il costruttore di questo tipo di dato astratto. Il costruttore deve allocare la memoria necessaria, nonché agganciare i puntatori della struttura pubblica alle relative funzioni definite nel file privato CC_private.c:<br /><br /><pre>/*<br />* Servizio pubblico di generazione di un nuovo conto corrente. Questa<br />* funzione accetta il numero del nuovo corrente da aprire e crea/inizializza<br />* una struttura dati privata (ContoCorrentePrivate), per poi restituire il<br />* puntatore alla struttura pubblica (ContoCorrentePub).<br />*/<br />ContoCorrentePub* aperturaContoCorrente(int numero_conto){<br /><br />ContoCorrentePrivate* ccpriv = NULL;<br /><br />// alloco memoria per il nuovo conto corrente<br />ccpriv = (ContoCorrentePrivate*) malloc( sizeof(ContoCorrentePrivate) );<br /><br />// controllo se la malloc ha allocato effettivamente memoria<br />if( ccpriv != NULL ){<br />// il nuovo conto corrente è stato generato, lo inizializzo<br />printf("\n\t[aperturaContoCorrente] inizializzazione dati conto corrente");<br />ccpriv->NumeroConto = numero_conto;<br />ccpriv->Saldo       = 0;<br />ccpriv->cur_mov     = 0;<br /><br />// "aggancio" i puntatori alle relative funzioni<br />ccpriv->m_saldo            = getSaldo;<br />ccpriv->m_stampa           = StampaContoCorrente;<br />ccpriv->m_versamento       = versamento;<br />ccpriv->m_prelievo         = prelievo;<br />ccpriv->m_stampa_movimenti = stampaMovimenti;<br /><br />}<br /><br />// restituisco il conto corrente creato (o NULL se non si è riusciti<br />// ad allocare memoria<br />return Private2Public(ccpriv);<br />}</pre><br /><br />Come si può notare, viene allocata la memoria necessaria ad una struttura privata, dopodiché si agganciano i puntatori a funzione e si restituisce il puntatore <span style="font-style: italic;">ristretto</span> alla struttura pubblica.<br /><br /><span style="font-weight: bold; font-style: italic;">Utilizzo del tipo di dato astratto</span><br />Il seguente programma mostra l'utilizzo del conto corrente:<br /><br /><pre>#include <stdio.h><br />#include "CC_pub.h"  // include che definisce la versione pubblica<br /> // della struttura ContoCorrente<br /><br /><br />int main(void){<br />ContoCorrentePub* C1;<br />ContoCorrentePub* C2;<br /><br /><br /><br />printf("\nProgramma in esecuzione\n");<br /><br />// creo i conti corrente<br />C1 = aperturaContoCorrente( 3663 );<br />C2 = aperturaContoCorrente( 8026 );<br /><br /><br />// effettuo dei versamenti<br />C1->m_versamento( C1, 10000 );<br />C2->m_versamento( C2, 7000 );<br /><br />// effettuo un prelievo ed un versamento combinato<br />C1->m_versamento( C1, C2->m_prelievo(C2, 2000) );<br /><br />// richiedo la stampa delle informazioni dei conti<br />C1->m_stampa(C1);<br />C2->m_stampa(C2);<br /><br />// stampa dei movimenti<br />C1->m_stampa_movimenti( C1 );<br />C1->m_stampa_movimenti( C2 );<br /><br /><br />}<br /></stdio.h></pre><br /><br />Si noti che:<br /><ul><li>la struttura privata non è mai visibile, poiché l'apertura di un conto corrente avviene fornendo sempre un puntatore alla struttura pubblica. Se si tenta di accedere ad un campo della struttura pubblica si ottiene un errore di compilazione, poiché il campo non è presente nella struttura pubblica. Se si cerca di convertire manualmente la struttura da pubblica a privata, si ottiene un errore di compilazione (ContoCorrentePrivate non è definito in nessuno degli include del programma).</li><li>ogni chiamata a metodo deve specificare come argomento la struttura alla quale si riferisce.</li></ul>L'ultimo punto potrebbe risultare oscuro, ma segue la prassi della programmazione OOP. Infatti, quando ad esempio in Java si effettua una chiamata<br /><br /><pre>C1.m_versamento(200);</pre><br />il compilatore trasforma la chiamata silenziosamente in<br /><br /><pre>C1.m_versamento(C1, 200);</pre> ciò è necessario per il funzionamento di <span style="font-style: italic;">this</span>. In sostanza, ogni metodo di istanza viene modificato dal compilatore per includere come primo parametro l'istanza stessa sulla quale operare. Tuttavia, mentre in un linguaggio che supporta OOP questo avviene trasparentemente, in una simile soluzione è necessario specificarlo esplicitamente. Questo porta anche alla possibilità di errori quali:<br /><br /><pre> C1->m_versamento( C2, 10000 );</pre> ove si pensa di agire su C1 ma per errore si agisce su C2. E' evidente che errori del genere sono dovuti alla assenza di supporto OOP nel linguaggio, ma come si è visto da questo esempio, è comunque possibile implementare sistemi OOP.<br /><br /><span style="font-weight: bold; font-style: italic;">Ereditarietà</span><br />L'ereditarietà viene implementata in modo simile a quello visto per la conversione da struttura pubblica a privata: è possibile estendere una classe aggiungendo nuovi membri in fondo alla struttura, lasciando inalterate le parti sovrapposte alla superclasse. Ad esempio:<br /><br /><pre>typedef struct{<br />// puntatore alla funzione getSaldo<br />int (*m_saldo)(ContoCorrentePub*);<br /><br />// puntatore alla funzione StampaContoCorrente<br />void (*m_stampa)(ContoCorrentePub*);<br /><br />// puntatore alla funzione versamento<br />int (*m_versamento)(ContoCorrentePub*, int);<br /><br />// puntatore alla funzione di prelievo<br />int (*m_prelievo)(ContoCorrentePub*, int);<br /><br />// puntatore alla funzione di stampa dei movimenti<br />void (*m_stampa_movimenti)(ContoCorrentePub*);<br /><br />//------------------------------------------<br /><br />// dati nascosti<br />int NumeroConto;   // numero del conto corrente<br />int Saldo;    // saldo attuale<br />int Movimenti[MAX_MOVIMENTI];  // lista degli ultimi movimenti<br />int cur_mov;    // indice del movimento corrente<br /><br />// variabili aggiunte nella sottoclasse<br />char* intestatario;   // nome dell'intestario del conto corrente<br />int   numeroCartaCredito;               // numero di carta di credito<br />} ContoCorrentePrivateExt;</pre> In questo caso, si aggiungono altri dati (ma potevano essere aggiunte altre funzioni) al conto corrente. Si noti che, essendo rimaste identiche le parti sovrapposte, il ContoCorrentePrivateExt è compatibile con ContoCorrentePrivate e quindi ne è una classe derivata.<br /><br />Si noti che nell'esempio di cui sopra, l'ereditarietà non mostra tutti i vantaggi: è necessario ricopiare tutti i campi della struttura base. Si può ovviare a questo inserendo come primo campo della struttura la struttura base stessa:<br /><br /><pre>typedef struct{<br />ContoCorrentePrivate* superclasse;  // puntatore alla classe base<br /><br />// variabili aggiunte nella sottoclasse<br />char* intestatario;   // nome dell'intestario del conto corrente<br />int   numeroCartaCredito;               // numero di carta di credito<br />} ContoCorrentePrivateExt;</pre><br /><br /><span style="font-weight: bold; font-style: italic;">Polimorfismo</span><br />Ottenere il polimorfismo è abbastanza semplice: basta definire nuovi costruttori (metodi aperturaContoCorrente()) che aggancino i puntatori di funzioni a nuove implementazioni.<br /><br /><span style="font-weight: bold; font-style: italic;">Considerazioni</span><br />Come si è visto è possibile implementare sistemi OOP anche in linguaggi non OOP, chiaramente con qualche difficoltà e possibilità di errori. Diversi sistemi OOP sono realizzati con linguaggi non OOP per diverse ragioni, le principali sono:<br /><ul><li>assenza di compilatori OOP;</li><li>maggior controllo sul tipo run-time rispetto a quello fornito dal compilatore;</li><li>adattamento ed evoluzione di un sistema originariamente non OOP.<br /></li></ul>Alcune implementazioni, come GTK+, mantengono due strutture separate: quella di classe e quella di istanza. Questo simula meglio ciò che avviene ad esempio in Java, ove una sola classe viene caricata (con la definizione dei metodi) e la memoria allocata per le istanze contiene solo i dati di ciascun oggetto.